//go:build pulsar
// +build pulsar

// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	io "io"
	reflect "reflect"
	sync "sync"
)

var _ protoreflect.List = (*_Params_6_list)(nil)

type _Params_6_list struct {
	list *[]*AuthorizedChannel
}

func (x *_Params_6_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_Params_6_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_Params_6_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*AuthorizedChannel)
	(*x.list)[i] = concreteValue
}

func (x *_Params_6_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*AuthorizedChannel)
	*x.list = append(*x.list, concreteValue)
}

func (x *_Params_6_list) AppendMutable() protoreflect.Value {
	v := new(AuthorizedChannel)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Params_6_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_Params_6_list) NewElement() protoreflect.Value {
	v := new(AuthorizedChannel)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Params_6_list) IsValid() bool {
	return x.list != nil
}

var (
	md_Params                                        protoreflect.MessageDescriptor
	fd_Params_swap_fee                               protoreflect.FieldDescriptor
	fd_Params_lp_fee                                 protoreflect.FieldDescriptor
	fd_Params_protocol_fee                           protoreflect.FieldDescriptor
	fd_Params_min_liquidity                          protoreflect.FieldDescriptor
	fd_Params_max_slippage_percent                   protoreflect.FieldDescriptor
	fd_Params_authorized_channels                    protoreflect.FieldDescriptor
	fd_Params_max_pool_drain_percent                 protoreflect.FieldDescriptor
	fd_Params_flash_loan_protection_blocks           protoreflect.FieldDescriptor
	fd_Params_pool_creation_gas                      protoreflect.FieldDescriptor
	fd_Params_swap_validation_gas                    protoreflect.FieldDescriptor
	fd_Params_liquidity_gas                          protoreflect.FieldDescriptor
	fd_Params_upgrade_preserve_circuit_breaker_state protoreflect.FieldDescriptor
	fd_Params_recommended_max_slippage               protoreflect.FieldDescriptor
	fd_Params_enable_commit_reveal                   protoreflect.FieldDescriptor
	fd_Params_commit_reveal_delay                    protoreflect.FieldDescriptor
	fd_Params_commit_timeout_blocks                  protoreflect.FieldDescriptor
)

func init() {
	file_paw_dex_v1_dex_proto_init()
	md_Params = File_paw_dex_v1_dex_proto.Messages().ByName("Params")
	fd_Params_swap_fee = md_Params.Fields().ByName("swap_fee")
	fd_Params_lp_fee = md_Params.Fields().ByName("lp_fee")
	fd_Params_protocol_fee = md_Params.Fields().ByName("protocol_fee")
	fd_Params_min_liquidity = md_Params.Fields().ByName("min_liquidity")
	fd_Params_max_slippage_percent = md_Params.Fields().ByName("max_slippage_percent")
	fd_Params_authorized_channels = md_Params.Fields().ByName("authorized_channels")
	fd_Params_max_pool_drain_percent = md_Params.Fields().ByName("max_pool_drain_percent")
	fd_Params_flash_loan_protection_blocks = md_Params.Fields().ByName("flash_loan_protection_blocks")
	fd_Params_pool_creation_gas = md_Params.Fields().ByName("pool_creation_gas")
	fd_Params_swap_validation_gas = md_Params.Fields().ByName("swap_validation_gas")
	fd_Params_liquidity_gas = md_Params.Fields().ByName("liquidity_gas")
	fd_Params_upgrade_preserve_circuit_breaker_state = md_Params.Fields().ByName("upgrade_preserve_circuit_breaker_state")
	fd_Params_recommended_max_slippage = md_Params.Fields().ByName("recommended_max_slippage")
	fd_Params_enable_commit_reveal = md_Params.Fields().ByName("enable_commit_reveal")
	fd_Params_commit_reveal_delay = md_Params.Fields().ByName("commit_reveal_delay")
	fd_Params_commit_timeout_blocks = md_Params.Fields().ByName("commit_timeout_blocks")
}

var _ protoreflect.Message = (*fastReflection_Params)(nil)

type fastReflection_Params Params

func (x *Params) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Params)(x)
}

func (x *Params) slowProtoReflect() protoreflect.Message {
	mi := &file_paw_dex_v1_dex_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Params_messageType fastReflection_Params_messageType
var _ protoreflect.MessageType = fastReflection_Params_messageType{}

type fastReflection_Params_messageType struct{}

func (x fastReflection_Params_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Params)(nil)
}
func (x fastReflection_Params_messageType) New() protoreflect.Message {
	return new(fastReflection_Params)
}
func (x fastReflection_Params_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Params
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Params) Descriptor() protoreflect.MessageDescriptor {
	return md_Params
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Params) Type() protoreflect.MessageType {
	return _fastReflection_Params_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Params) New() protoreflect.Message {
	return new(fastReflection_Params)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Params) Interface() protoreflect.ProtoMessage {
	return (*Params)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Params) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.SwapFee != "" {
		value := protoreflect.ValueOfString(x.SwapFee)
		if !f(fd_Params_swap_fee, value) {
			return
		}
	}
	if x.LpFee != "" {
		value := protoreflect.ValueOfString(x.LpFee)
		if !f(fd_Params_lp_fee, value) {
			return
		}
	}
	if x.ProtocolFee != "" {
		value := protoreflect.ValueOfString(x.ProtocolFee)
		if !f(fd_Params_protocol_fee, value) {
			return
		}
	}
	if x.MinLiquidity != "" {
		value := protoreflect.ValueOfString(x.MinLiquidity)
		if !f(fd_Params_min_liquidity, value) {
			return
		}
	}
	if x.MaxSlippagePercent != "" {
		value := protoreflect.ValueOfString(x.MaxSlippagePercent)
		if !f(fd_Params_max_slippage_percent, value) {
			return
		}
	}
	if len(x.AuthorizedChannels) != 0 {
		value := protoreflect.ValueOfList(&_Params_6_list{list: &x.AuthorizedChannels})
		if !f(fd_Params_authorized_channels, value) {
			return
		}
	}
	if x.MaxPoolDrainPercent != "" {
		value := protoreflect.ValueOfString(x.MaxPoolDrainPercent)
		if !f(fd_Params_max_pool_drain_percent, value) {
			return
		}
	}
	if x.FlashLoanProtectionBlocks != uint64(0) {
		value := protoreflect.ValueOfUint64(x.FlashLoanProtectionBlocks)
		if !f(fd_Params_flash_loan_protection_blocks, value) {
			return
		}
	}
	if x.PoolCreationGas != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PoolCreationGas)
		if !f(fd_Params_pool_creation_gas, value) {
			return
		}
	}
	if x.SwapValidationGas != uint64(0) {
		value := protoreflect.ValueOfUint64(x.SwapValidationGas)
		if !f(fd_Params_swap_validation_gas, value) {
			return
		}
	}
	if x.LiquidityGas != uint64(0) {
		value := protoreflect.ValueOfUint64(x.LiquidityGas)
		if !f(fd_Params_liquidity_gas, value) {
			return
		}
	}
	if x.UpgradePreserveCircuitBreakerState != false {
		value := protoreflect.ValueOfBool(x.UpgradePreserveCircuitBreakerState)
		if !f(fd_Params_upgrade_preserve_circuit_breaker_state, value) {
			return
		}
	}
	if x.RecommendedMaxSlippage != "" {
		value := protoreflect.ValueOfString(x.RecommendedMaxSlippage)
		if !f(fd_Params_recommended_max_slippage, value) {
			return
		}
	}
	if x.EnableCommitReveal != false {
		value := protoreflect.ValueOfBool(x.EnableCommitReveal)
		if !f(fd_Params_enable_commit_reveal, value) {
			return
		}
	}
	if x.CommitRevealDelay != uint64(0) {
		value := protoreflect.ValueOfUint64(x.CommitRevealDelay)
		if !f(fd_Params_commit_reveal_delay, value) {
			return
		}
	}
	if x.CommitTimeoutBlocks != uint64(0) {
		value := protoreflect.ValueOfUint64(x.CommitTimeoutBlocks)
		if !f(fd_Params_commit_timeout_blocks, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Params) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "paw.dex.v1.Params.swap_fee":
		return x.SwapFee != ""
	case "paw.dex.v1.Params.lp_fee":
		return x.LpFee != ""
	case "paw.dex.v1.Params.protocol_fee":
		return x.ProtocolFee != ""
	case "paw.dex.v1.Params.min_liquidity":
		return x.MinLiquidity != ""
	case "paw.dex.v1.Params.max_slippage_percent":
		return x.MaxSlippagePercent != ""
	case "paw.dex.v1.Params.authorized_channels":
		return len(x.AuthorizedChannels) != 0
	case "paw.dex.v1.Params.max_pool_drain_percent":
		return x.MaxPoolDrainPercent != ""
	case "paw.dex.v1.Params.flash_loan_protection_blocks":
		return x.FlashLoanProtectionBlocks != uint64(0)
	case "paw.dex.v1.Params.pool_creation_gas":
		return x.PoolCreationGas != uint64(0)
	case "paw.dex.v1.Params.swap_validation_gas":
		return x.SwapValidationGas != uint64(0)
	case "paw.dex.v1.Params.liquidity_gas":
		return x.LiquidityGas != uint64(0)
	case "paw.dex.v1.Params.upgrade_preserve_circuit_breaker_state":
		return x.UpgradePreserveCircuitBreakerState != false
	case "paw.dex.v1.Params.recommended_max_slippage":
		return x.RecommendedMaxSlippage != ""
	case "paw.dex.v1.Params.enable_commit_reveal":
		return x.EnableCommitReveal != false
	case "paw.dex.v1.Params.commit_reveal_delay":
		return x.CommitRevealDelay != uint64(0)
	case "paw.dex.v1.Params.commit_timeout_blocks":
		return x.CommitTimeoutBlocks != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.Params"))
		}
		panic(fmt.Errorf("message paw.dex.v1.Params does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Params) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "paw.dex.v1.Params.swap_fee":
		x.SwapFee = ""
	case "paw.dex.v1.Params.lp_fee":
		x.LpFee = ""
	case "paw.dex.v1.Params.protocol_fee":
		x.ProtocolFee = ""
	case "paw.dex.v1.Params.min_liquidity":
		x.MinLiquidity = ""
	case "paw.dex.v1.Params.max_slippage_percent":
		x.MaxSlippagePercent = ""
	case "paw.dex.v1.Params.authorized_channels":
		x.AuthorizedChannels = nil
	case "paw.dex.v1.Params.max_pool_drain_percent":
		x.MaxPoolDrainPercent = ""
	case "paw.dex.v1.Params.flash_loan_protection_blocks":
		x.FlashLoanProtectionBlocks = uint64(0)
	case "paw.dex.v1.Params.pool_creation_gas":
		x.PoolCreationGas = uint64(0)
	case "paw.dex.v1.Params.swap_validation_gas":
		x.SwapValidationGas = uint64(0)
	case "paw.dex.v1.Params.liquidity_gas":
		x.LiquidityGas = uint64(0)
	case "paw.dex.v1.Params.upgrade_preserve_circuit_breaker_state":
		x.UpgradePreserveCircuitBreakerState = false
	case "paw.dex.v1.Params.recommended_max_slippage":
		x.RecommendedMaxSlippage = ""
	case "paw.dex.v1.Params.enable_commit_reveal":
		x.EnableCommitReveal = false
	case "paw.dex.v1.Params.commit_reveal_delay":
		x.CommitRevealDelay = uint64(0)
	case "paw.dex.v1.Params.commit_timeout_blocks":
		x.CommitTimeoutBlocks = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.Params"))
		}
		panic(fmt.Errorf("message paw.dex.v1.Params does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Params) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "paw.dex.v1.Params.swap_fee":
		value := x.SwapFee
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.Params.lp_fee":
		value := x.LpFee
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.Params.protocol_fee":
		value := x.ProtocolFee
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.Params.min_liquidity":
		value := x.MinLiquidity
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.Params.max_slippage_percent":
		value := x.MaxSlippagePercent
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.Params.authorized_channels":
		if len(x.AuthorizedChannels) == 0 {
			return protoreflect.ValueOfList(&_Params_6_list{})
		}
		listValue := &_Params_6_list{list: &x.AuthorizedChannels}
		return protoreflect.ValueOfList(listValue)
	case "paw.dex.v1.Params.max_pool_drain_percent":
		value := x.MaxPoolDrainPercent
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.Params.flash_loan_protection_blocks":
		value := x.FlashLoanProtectionBlocks
		return protoreflect.ValueOfUint64(value)
	case "paw.dex.v1.Params.pool_creation_gas":
		value := x.PoolCreationGas
		return protoreflect.ValueOfUint64(value)
	case "paw.dex.v1.Params.swap_validation_gas":
		value := x.SwapValidationGas
		return protoreflect.ValueOfUint64(value)
	case "paw.dex.v1.Params.liquidity_gas":
		value := x.LiquidityGas
		return protoreflect.ValueOfUint64(value)
	case "paw.dex.v1.Params.upgrade_preserve_circuit_breaker_state":
		value := x.UpgradePreserveCircuitBreakerState
		return protoreflect.ValueOfBool(value)
	case "paw.dex.v1.Params.recommended_max_slippage":
		value := x.RecommendedMaxSlippage
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.Params.enable_commit_reveal":
		value := x.EnableCommitReveal
		return protoreflect.ValueOfBool(value)
	case "paw.dex.v1.Params.commit_reveal_delay":
		value := x.CommitRevealDelay
		return protoreflect.ValueOfUint64(value)
	case "paw.dex.v1.Params.commit_timeout_blocks":
		value := x.CommitTimeoutBlocks
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.Params"))
		}
		panic(fmt.Errorf("message paw.dex.v1.Params does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Params) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "paw.dex.v1.Params.swap_fee":
		x.SwapFee = value.Interface().(string)
	case "paw.dex.v1.Params.lp_fee":
		x.LpFee = value.Interface().(string)
	case "paw.dex.v1.Params.protocol_fee":
		x.ProtocolFee = value.Interface().(string)
	case "paw.dex.v1.Params.min_liquidity":
		x.MinLiquidity = value.Interface().(string)
	case "paw.dex.v1.Params.max_slippage_percent":
		x.MaxSlippagePercent = value.Interface().(string)
	case "paw.dex.v1.Params.authorized_channels":
		lv := value.List()
		clv := lv.(*_Params_6_list)
		x.AuthorizedChannels = *clv.list
	case "paw.dex.v1.Params.max_pool_drain_percent":
		x.MaxPoolDrainPercent = value.Interface().(string)
	case "paw.dex.v1.Params.flash_loan_protection_blocks":
		x.FlashLoanProtectionBlocks = value.Uint()
	case "paw.dex.v1.Params.pool_creation_gas":
		x.PoolCreationGas = value.Uint()
	case "paw.dex.v1.Params.swap_validation_gas":
		x.SwapValidationGas = value.Uint()
	case "paw.dex.v1.Params.liquidity_gas":
		x.LiquidityGas = value.Uint()
	case "paw.dex.v1.Params.upgrade_preserve_circuit_breaker_state":
		x.UpgradePreserveCircuitBreakerState = value.Bool()
	case "paw.dex.v1.Params.recommended_max_slippage":
		x.RecommendedMaxSlippage = value.Interface().(string)
	case "paw.dex.v1.Params.enable_commit_reveal":
		x.EnableCommitReveal = value.Bool()
	case "paw.dex.v1.Params.commit_reveal_delay":
		x.CommitRevealDelay = value.Uint()
	case "paw.dex.v1.Params.commit_timeout_blocks":
		x.CommitTimeoutBlocks = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.Params"))
		}
		panic(fmt.Errorf("message paw.dex.v1.Params does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Params) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.Params.authorized_channels":
		if x.AuthorizedChannels == nil {
			x.AuthorizedChannels = []*AuthorizedChannel{}
		}
		value := &_Params_6_list{list: &x.AuthorizedChannels}
		return protoreflect.ValueOfList(value)
	case "paw.dex.v1.Params.swap_fee":
		panic(fmt.Errorf("field swap_fee of message paw.dex.v1.Params is not mutable"))
	case "paw.dex.v1.Params.lp_fee":
		panic(fmt.Errorf("field lp_fee of message paw.dex.v1.Params is not mutable"))
	case "paw.dex.v1.Params.protocol_fee":
		panic(fmt.Errorf("field protocol_fee of message paw.dex.v1.Params is not mutable"))
	case "paw.dex.v1.Params.min_liquidity":
		panic(fmt.Errorf("field min_liquidity of message paw.dex.v1.Params is not mutable"))
	case "paw.dex.v1.Params.max_slippage_percent":
		panic(fmt.Errorf("field max_slippage_percent of message paw.dex.v1.Params is not mutable"))
	case "paw.dex.v1.Params.max_pool_drain_percent":
		panic(fmt.Errorf("field max_pool_drain_percent of message paw.dex.v1.Params is not mutable"))
	case "paw.dex.v1.Params.flash_loan_protection_blocks":
		panic(fmt.Errorf("field flash_loan_protection_blocks of message paw.dex.v1.Params is not mutable"))
	case "paw.dex.v1.Params.pool_creation_gas":
		panic(fmt.Errorf("field pool_creation_gas of message paw.dex.v1.Params is not mutable"))
	case "paw.dex.v1.Params.swap_validation_gas":
		panic(fmt.Errorf("field swap_validation_gas of message paw.dex.v1.Params is not mutable"))
	case "paw.dex.v1.Params.liquidity_gas":
		panic(fmt.Errorf("field liquidity_gas of message paw.dex.v1.Params is not mutable"))
	case "paw.dex.v1.Params.upgrade_preserve_circuit_breaker_state":
		panic(fmt.Errorf("field upgrade_preserve_circuit_breaker_state of message paw.dex.v1.Params is not mutable"))
	case "paw.dex.v1.Params.recommended_max_slippage":
		panic(fmt.Errorf("field recommended_max_slippage of message paw.dex.v1.Params is not mutable"))
	case "paw.dex.v1.Params.enable_commit_reveal":
		panic(fmt.Errorf("field enable_commit_reveal of message paw.dex.v1.Params is not mutable"))
	case "paw.dex.v1.Params.commit_reveal_delay":
		panic(fmt.Errorf("field commit_reveal_delay of message paw.dex.v1.Params is not mutable"))
	case "paw.dex.v1.Params.commit_timeout_blocks":
		panic(fmt.Errorf("field commit_timeout_blocks of message paw.dex.v1.Params is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.Params"))
		}
		panic(fmt.Errorf("message paw.dex.v1.Params does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Params) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.Params.swap_fee":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.Params.lp_fee":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.Params.protocol_fee":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.Params.min_liquidity":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.Params.max_slippage_percent":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.Params.authorized_channels":
		list := []*AuthorizedChannel{}
		return protoreflect.ValueOfList(&_Params_6_list{list: &list})
	case "paw.dex.v1.Params.max_pool_drain_percent":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.Params.flash_loan_protection_blocks":
		return protoreflect.ValueOfUint64(uint64(0))
	case "paw.dex.v1.Params.pool_creation_gas":
		return protoreflect.ValueOfUint64(uint64(0))
	case "paw.dex.v1.Params.swap_validation_gas":
		return protoreflect.ValueOfUint64(uint64(0))
	case "paw.dex.v1.Params.liquidity_gas":
		return protoreflect.ValueOfUint64(uint64(0))
	case "paw.dex.v1.Params.upgrade_preserve_circuit_breaker_state":
		return protoreflect.ValueOfBool(false)
	case "paw.dex.v1.Params.recommended_max_slippage":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.Params.enable_commit_reveal":
		return protoreflect.ValueOfBool(false)
	case "paw.dex.v1.Params.commit_reveal_delay":
		return protoreflect.ValueOfUint64(uint64(0))
	case "paw.dex.v1.Params.commit_timeout_blocks":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.Params"))
		}
		panic(fmt.Errorf("message paw.dex.v1.Params does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Params) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in paw.dex.v1.Params", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Params) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Params) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Params) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Params) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Params)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.SwapFee)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LpFee)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ProtocolFee)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MinLiquidity)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MaxSlippagePercent)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.AuthorizedChannels) > 0 {
			for _, e := range x.AuthorizedChannels {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		l = len(x.MaxPoolDrainPercent)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.FlashLoanProtectionBlocks != 0 {
			n += 1 + runtime.Sov(uint64(x.FlashLoanProtectionBlocks))
		}
		if x.PoolCreationGas != 0 {
			n += 1 + runtime.Sov(uint64(x.PoolCreationGas))
		}
		if x.SwapValidationGas != 0 {
			n += 1 + runtime.Sov(uint64(x.SwapValidationGas))
		}
		if x.LiquidityGas != 0 {
			n += 1 + runtime.Sov(uint64(x.LiquidityGas))
		}
		if x.UpgradePreserveCircuitBreakerState {
			n += 2
		}
		l = len(x.RecommendedMaxSlippage)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.EnableCommitReveal {
			n += 2
		}
		if x.CommitRevealDelay != 0 {
			n += 1 + runtime.Sov(uint64(x.CommitRevealDelay))
		}
		if x.CommitTimeoutBlocks != 0 {
			n += 2 + runtime.Sov(uint64(x.CommitTimeoutBlocks))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Params)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.CommitTimeoutBlocks != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.CommitTimeoutBlocks))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x80
		}
		if x.CommitRevealDelay != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.CommitRevealDelay))
			i--
			dAtA[i] = 0x78
		}
		if x.EnableCommitReveal {
			i--
			if x.EnableCommitReveal {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x70
		}
		if len(x.RecommendedMaxSlippage) > 0 {
			i -= len(x.RecommendedMaxSlippage)
			copy(dAtA[i:], x.RecommendedMaxSlippage)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RecommendedMaxSlippage)))
			i--
			dAtA[i] = 0x6a
		}
		if x.UpgradePreserveCircuitBreakerState {
			i--
			if x.UpgradePreserveCircuitBreakerState {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x60
		}
		if x.LiquidityGas != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.LiquidityGas))
			i--
			dAtA[i] = 0x58
		}
		if x.SwapValidationGas != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.SwapValidationGas))
			i--
			dAtA[i] = 0x50
		}
		if x.PoolCreationGas != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PoolCreationGas))
			i--
			dAtA[i] = 0x48
		}
		if x.FlashLoanProtectionBlocks != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.FlashLoanProtectionBlocks))
			i--
			dAtA[i] = 0x40
		}
		if len(x.MaxPoolDrainPercent) > 0 {
			i -= len(x.MaxPoolDrainPercent)
			copy(dAtA[i:], x.MaxPoolDrainPercent)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MaxPoolDrainPercent)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.AuthorizedChannels) > 0 {
			for iNdEx := len(x.AuthorizedChannels) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.AuthorizedChannels[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x32
			}
		}
		if len(x.MaxSlippagePercent) > 0 {
			i -= len(x.MaxSlippagePercent)
			copy(dAtA[i:], x.MaxSlippagePercent)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MaxSlippagePercent)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.MinLiquidity) > 0 {
			i -= len(x.MinLiquidity)
			copy(dAtA[i:], x.MinLiquidity)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MinLiquidity)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.ProtocolFee) > 0 {
			i -= len(x.ProtocolFee)
			copy(dAtA[i:], x.ProtocolFee)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ProtocolFee)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.LpFee) > 0 {
			i -= len(x.LpFee)
			copy(dAtA[i:], x.LpFee)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LpFee)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.SwapFee) > 0 {
			i -= len(x.SwapFee)
			copy(dAtA[i:], x.SwapFee)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SwapFee)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Params)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Params: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SwapFee", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SwapFee = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LpFee", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LpFee = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ProtocolFee", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ProtocolFee = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MinLiquidity", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MinLiquidity = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxSlippagePercent", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MaxSlippagePercent = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AuthorizedChannels", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AuthorizedChannels = append(x.AuthorizedChannels, &AuthorizedChannel{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.AuthorizedChannels[len(x.AuthorizedChannels)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxPoolDrainPercent", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MaxPoolDrainPercent = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FlashLoanProtectionBlocks", wireType)
				}
				x.FlashLoanProtectionBlocks = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.FlashLoanProtectionBlocks |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolCreationGas", wireType)
				}
				x.PoolCreationGas = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PoolCreationGas |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SwapValidationGas", wireType)
				}
				x.SwapValidationGas = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.SwapValidationGas |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 11:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LiquidityGas", wireType)
				}
				x.LiquidityGas = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.LiquidityGas |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 12:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UpgradePreserveCircuitBreakerState", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.UpgradePreserveCircuitBreakerState = bool(v != 0)
			case 13:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RecommendedMaxSlippage", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RecommendedMaxSlippage = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 14:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EnableCommitReveal", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.EnableCommitReveal = bool(v != 0)
			case 15:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CommitRevealDelay", wireType)
				}
				x.CommitRevealDelay = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.CommitRevealDelay |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 16:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CommitTimeoutBlocks", wireType)
				}
				x.CommitTimeoutBlocks = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.CommitTimeoutBlocks |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_AuthorizedChannel            protoreflect.MessageDescriptor
	fd_AuthorizedChannel_port_id    protoreflect.FieldDescriptor
	fd_AuthorizedChannel_channel_id protoreflect.FieldDescriptor
)

func init() {
	file_paw_dex_v1_dex_proto_init()
	md_AuthorizedChannel = File_paw_dex_v1_dex_proto.Messages().ByName("AuthorizedChannel")
	fd_AuthorizedChannel_port_id = md_AuthorizedChannel.Fields().ByName("port_id")
	fd_AuthorizedChannel_channel_id = md_AuthorizedChannel.Fields().ByName("channel_id")
}

var _ protoreflect.Message = (*fastReflection_AuthorizedChannel)(nil)

type fastReflection_AuthorizedChannel AuthorizedChannel

func (x *AuthorizedChannel) ProtoReflect() protoreflect.Message {
	return (*fastReflection_AuthorizedChannel)(x)
}

func (x *AuthorizedChannel) slowProtoReflect() protoreflect.Message {
	mi := &file_paw_dex_v1_dex_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_AuthorizedChannel_messageType fastReflection_AuthorizedChannel_messageType
var _ protoreflect.MessageType = fastReflection_AuthorizedChannel_messageType{}

type fastReflection_AuthorizedChannel_messageType struct{}

func (x fastReflection_AuthorizedChannel_messageType) Zero() protoreflect.Message {
	return (*fastReflection_AuthorizedChannel)(nil)
}
func (x fastReflection_AuthorizedChannel_messageType) New() protoreflect.Message {
	return new(fastReflection_AuthorizedChannel)
}
func (x fastReflection_AuthorizedChannel_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_AuthorizedChannel
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_AuthorizedChannel) Descriptor() protoreflect.MessageDescriptor {
	return md_AuthorizedChannel
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_AuthorizedChannel) Type() protoreflect.MessageType {
	return _fastReflection_AuthorizedChannel_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_AuthorizedChannel) New() protoreflect.Message {
	return new(fastReflection_AuthorizedChannel)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_AuthorizedChannel) Interface() protoreflect.ProtoMessage {
	return (*AuthorizedChannel)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_AuthorizedChannel) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PortId != "" {
		value := protoreflect.ValueOfString(x.PortId)
		if !f(fd_AuthorizedChannel_port_id, value) {
			return
		}
	}
	if x.ChannelId != "" {
		value := protoreflect.ValueOfString(x.ChannelId)
		if !f(fd_AuthorizedChannel_channel_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_AuthorizedChannel) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "paw.dex.v1.AuthorizedChannel.port_id":
		return x.PortId != ""
	case "paw.dex.v1.AuthorizedChannel.channel_id":
		return x.ChannelId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.AuthorizedChannel"))
		}
		panic(fmt.Errorf("message paw.dex.v1.AuthorizedChannel does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AuthorizedChannel) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "paw.dex.v1.AuthorizedChannel.port_id":
		x.PortId = ""
	case "paw.dex.v1.AuthorizedChannel.channel_id":
		x.ChannelId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.AuthorizedChannel"))
		}
		panic(fmt.Errorf("message paw.dex.v1.AuthorizedChannel does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_AuthorizedChannel) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "paw.dex.v1.AuthorizedChannel.port_id":
		value := x.PortId
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.AuthorizedChannel.channel_id":
		value := x.ChannelId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.AuthorizedChannel"))
		}
		panic(fmt.Errorf("message paw.dex.v1.AuthorizedChannel does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AuthorizedChannel) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "paw.dex.v1.AuthorizedChannel.port_id":
		x.PortId = value.Interface().(string)
	case "paw.dex.v1.AuthorizedChannel.channel_id":
		x.ChannelId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.AuthorizedChannel"))
		}
		panic(fmt.Errorf("message paw.dex.v1.AuthorizedChannel does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AuthorizedChannel) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.AuthorizedChannel.port_id":
		panic(fmt.Errorf("field port_id of message paw.dex.v1.AuthorizedChannel is not mutable"))
	case "paw.dex.v1.AuthorizedChannel.channel_id":
		panic(fmt.Errorf("field channel_id of message paw.dex.v1.AuthorizedChannel is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.AuthorizedChannel"))
		}
		panic(fmt.Errorf("message paw.dex.v1.AuthorizedChannel does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_AuthorizedChannel) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.AuthorizedChannel.port_id":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.AuthorizedChannel.channel_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.AuthorizedChannel"))
		}
		panic(fmt.Errorf("message paw.dex.v1.AuthorizedChannel does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_AuthorizedChannel) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in paw.dex.v1.AuthorizedChannel", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_AuthorizedChannel) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AuthorizedChannel) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_AuthorizedChannel) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_AuthorizedChannel) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*AuthorizedChannel)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.PortId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ChannelId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*AuthorizedChannel)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.ChannelId) > 0 {
			i -= len(x.ChannelId)
			copy(dAtA[i:], x.ChannelId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ChannelId)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.PortId) > 0 {
			i -= len(x.PortId)
			copy(dAtA[i:], x.PortId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PortId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*AuthorizedChannel)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AuthorizedChannel: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AuthorizedChannel: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PortId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ChannelId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_Pool              protoreflect.MessageDescriptor
	fd_Pool_id           protoreflect.FieldDescriptor
	fd_Pool_token_a      protoreflect.FieldDescriptor
	fd_Pool_token_b      protoreflect.FieldDescriptor
	fd_Pool_reserve_a    protoreflect.FieldDescriptor
	fd_Pool_reserve_b    protoreflect.FieldDescriptor
	fd_Pool_total_shares protoreflect.FieldDescriptor
	fd_Pool_creator      protoreflect.FieldDescriptor
)

func init() {
	file_paw_dex_v1_dex_proto_init()
	md_Pool = File_paw_dex_v1_dex_proto.Messages().ByName("Pool")
	fd_Pool_id = md_Pool.Fields().ByName("id")
	fd_Pool_token_a = md_Pool.Fields().ByName("token_a")
	fd_Pool_token_b = md_Pool.Fields().ByName("token_b")
	fd_Pool_reserve_a = md_Pool.Fields().ByName("reserve_a")
	fd_Pool_reserve_b = md_Pool.Fields().ByName("reserve_b")
	fd_Pool_total_shares = md_Pool.Fields().ByName("total_shares")
	fd_Pool_creator = md_Pool.Fields().ByName("creator")
}

var _ protoreflect.Message = (*fastReflection_Pool)(nil)

type fastReflection_Pool Pool

func (x *Pool) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Pool)(x)
}

func (x *Pool) slowProtoReflect() protoreflect.Message {
	mi := &file_paw_dex_v1_dex_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Pool_messageType fastReflection_Pool_messageType
var _ protoreflect.MessageType = fastReflection_Pool_messageType{}

type fastReflection_Pool_messageType struct{}

func (x fastReflection_Pool_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Pool)(nil)
}
func (x fastReflection_Pool_messageType) New() protoreflect.Message {
	return new(fastReflection_Pool)
}
func (x fastReflection_Pool_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Pool
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Pool) Descriptor() protoreflect.MessageDescriptor {
	return md_Pool
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Pool) Type() protoreflect.MessageType {
	return _fastReflection_Pool_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Pool) New() protoreflect.Message {
	return new(fastReflection_Pool)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Pool) Interface() protoreflect.ProtoMessage {
	return (*Pool)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Pool) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Id)
		if !f(fd_Pool_id, value) {
			return
		}
	}
	if x.TokenA != "" {
		value := protoreflect.ValueOfString(x.TokenA)
		if !f(fd_Pool_token_a, value) {
			return
		}
	}
	if x.TokenB != "" {
		value := protoreflect.ValueOfString(x.TokenB)
		if !f(fd_Pool_token_b, value) {
			return
		}
	}
	if x.ReserveA != "" {
		value := protoreflect.ValueOfString(x.ReserveA)
		if !f(fd_Pool_reserve_a, value) {
			return
		}
	}
	if x.ReserveB != "" {
		value := protoreflect.ValueOfString(x.ReserveB)
		if !f(fd_Pool_reserve_b, value) {
			return
		}
	}
	if x.TotalShares != "" {
		value := protoreflect.ValueOfString(x.TotalShares)
		if !f(fd_Pool_total_shares, value) {
			return
		}
	}
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_Pool_creator, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Pool) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "paw.dex.v1.Pool.id":
		return x.Id != uint64(0)
	case "paw.dex.v1.Pool.token_a":
		return x.TokenA != ""
	case "paw.dex.v1.Pool.token_b":
		return x.TokenB != ""
	case "paw.dex.v1.Pool.reserve_a":
		return x.ReserveA != ""
	case "paw.dex.v1.Pool.reserve_b":
		return x.ReserveB != ""
	case "paw.dex.v1.Pool.total_shares":
		return x.TotalShares != ""
	case "paw.dex.v1.Pool.creator":
		return x.Creator != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.Pool"))
		}
		panic(fmt.Errorf("message paw.dex.v1.Pool does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Pool) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "paw.dex.v1.Pool.id":
		x.Id = uint64(0)
	case "paw.dex.v1.Pool.token_a":
		x.TokenA = ""
	case "paw.dex.v1.Pool.token_b":
		x.TokenB = ""
	case "paw.dex.v1.Pool.reserve_a":
		x.ReserveA = ""
	case "paw.dex.v1.Pool.reserve_b":
		x.ReserveB = ""
	case "paw.dex.v1.Pool.total_shares":
		x.TotalShares = ""
	case "paw.dex.v1.Pool.creator":
		x.Creator = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.Pool"))
		}
		panic(fmt.Errorf("message paw.dex.v1.Pool does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Pool) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "paw.dex.v1.Pool.id":
		value := x.Id
		return protoreflect.ValueOfUint64(value)
	case "paw.dex.v1.Pool.token_a":
		value := x.TokenA
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.Pool.token_b":
		value := x.TokenB
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.Pool.reserve_a":
		value := x.ReserveA
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.Pool.reserve_b":
		value := x.ReserveB
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.Pool.total_shares":
		value := x.TotalShares
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.Pool.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.Pool"))
		}
		panic(fmt.Errorf("message paw.dex.v1.Pool does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Pool) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "paw.dex.v1.Pool.id":
		x.Id = value.Uint()
	case "paw.dex.v1.Pool.token_a":
		x.TokenA = value.Interface().(string)
	case "paw.dex.v1.Pool.token_b":
		x.TokenB = value.Interface().(string)
	case "paw.dex.v1.Pool.reserve_a":
		x.ReserveA = value.Interface().(string)
	case "paw.dex.v1.Pool.reserve_b":
		x.ReserveB = value.Interface().(string)
	case "paw.dex.v1.Pool.total_shares":
		x.TotalShares = value.Interface().(string)
	case "paw.dex.v1.Pool.creator":
		x.Creator = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.Pool"))
		}
		panic(fmt.Errorf("message paw.dex.v1.Pool does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Pool) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.Pool.id":
		panic(fmt.Errorf("field id of message paw.dex.v1.Pool is not mutable"))
	case "paw.dex.v1.Pool.token_a":
		panic(fmt.Errorf("field token_a of message paw.dex.v1.Pool is not mutable"))
	case "paw.dex.v1.Pool.token_b":
		panic(fmt.Errorf("field token_b of message paw.dex.v1.Pool is not mutable"))
	case "paw.dex.v1.Pool.reserve_a":
		panic(fmt.Errorf("field reserve_a of message paw.dex.v1.Pool is not mutable"))
	case "paw.dex.v1.Pool.reserve_b":
		panic(fmt.Errorf("field reserve_b of message paw.dex.v1.Pool is not mutable"))
	case "paw.dex.v1.Pool.total_shares":
		panic(fmt.Errorf("field total_shares of message paw.dex.v1.Pool is not mutable"))
	case "paw.dex.v1.Pool.creator":
		panic(fmt.Errorf("field creator of message paw.dex.v1.Pool is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.Pool"))
		}
		panic(fmt.Errorf("message paw.dex.v1.Pool does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Pool) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.Pool.id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "paw.dex.v1.Pool.token_a":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.Pool.token_b":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.Pool.reserve_a":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.Pool.reserve_b":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.Pool.total_shares":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.Pool.creator":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.Pool"))
		}
		panic(fmt.Errorf("message paw.dex.v1.Pool does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Pool) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in paw.dex.v1.Pool", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Pool) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Pool) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Pool) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Pool) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Pool)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Id != 0 {
			n += 1 + runtime.Sov(uint64(x.Id))
		}
		l = len(x.TokenA)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TokenB)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ReserveA)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ReserveB)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TotalShares)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Pool)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.TotalShares) > 0 {
			i -= len(x.TotalShares)
			copy(dAtA[i:], x.TotalShares)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalShares)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.ReserveB) > 0 {
			i -= len(x.ReserveB)
			copy(dAtA[i:], x.ReserveB)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReserveB)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.ReserveA) > 0 {
			i -= len(x.ReserveA)
			copy(dAtA[i:], x.ReserveA)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReserveA)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.TokenB) > 0 {
			i -= len(x.TokenB)
			copy(dAtA[i:], x.TokenB)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TokenB)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.TokenA) > 0 {
			i -= len(x.TokenA)
			copy(dAtA[i:], x.TokenA)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TokenA)))
			i--
			dAtA[i] = 0x12
		}
		if x.Id != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Id))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Pool)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Pool: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Pool: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				x.Id = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Id |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TokenA", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TokenA = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TokenB", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TokenB = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReserveA", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReserveA = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReserveB", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReserveB = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalShares", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalShares = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_PoolTWAP                  protoreflect.MessageDescriptor
	fd_PoolTWAP_pool_id          protoreflect.FieldDescriptor
	fd_PoolTWAP_last_price       protoreflect.FieldDescriptor
	fd_PoolTWAP_cumulative_price protoreflect.FieldDescriptor
	fd_PoolTWAP_total_seconds    protoreflect.FieldDescriptor
	fd_PoolTWAP_last_timestamp   protoreflect.FieldDescriptor
	fd_PoolTWAP_twap_price       protoreflect.FieldDescriptor
)

func init() {
	file_paw_dex_v1_dex_proto_init()
	md_PoolTWAP = File_paw_dex_v1_dex_proto.Messages().ByName("PoolTWAP")
	fd_PoolTWAP_pool_id = md_PoolTWAP.Fields().ByName("pool_id")
	fd_PoolTWAP_last_price = md_PoolTWAP.Fields().ByName("last_price")
	fd_PoolTWAP_cumulative_price = md_PoolTWAP.Fields().ByName("cumulative_price")
	fd_PoolTWAP_total_seconds = md_PoolTWAP.Fields().ByName("total_seconds")
	fd_PoolTWAP_last_timestamp = md_PoolTWAP.Fields().ByName("last_timestamp")
	fd_PoolTWAP_twap_price = md_PoolTWAP.Fields().ByName("twap_price")
}

var _ protoreflect.Message = (*fastReflection_PoolTWAP)(nil)

type fastReflection_PoolTWAP PoolTWAP

func (x *PoolTWAP) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PoolTWAP)(x)
}

func (x *PoolTWAP) slowProtoReflect() protoreflect.Message {
	mi := &file_paw_dex_v1_dex_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PoolTWAP_messageType fastReflection_PoolTWAP_messageType
var _ protoreflect.MessageType = fastReflection_PoolTWAP_messageType{}

type fastReflection_PoolTWAP_messageType struct{}

func (x fastReflection_PoolTWAP_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PoolTWAP)(nil)
}
func (x fastReflection_PoolTWAP_messageType) New() protoreflect.Message {
	return new(fastReflection_PoolTWAP)
}
func (x fastReflection_PoolTWAP_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PoolTWAP
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PoolTWAP) Descriptor() protoreflect.MessageDescriptor {
	return md_PoolTWAP
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PoolTWAP) Type() protoreflect.MessageType {
	return _fastReflection_PoolTWAP_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PoolTWAP) New() protoreflect.Message {
	return new(fastReflection_PoolTWAP)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PoolTWAP) Interface() protoreflect.ProtoMessage {
	return (*PoolTWAP)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PoolTWAP) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PoolId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PoolId)
		if !f(fd_PoolTWAP_pool_id, value) {
			return
		}
	}
	if x.LastPrice != "" {
		value := protoreflect.ValueOfString(x.LastPrice)
		if !f(fd_PoolTWAP_last_price, value) {
			return
		}
	}
	if x.CumulativePrice != "" {
		value := protoreflect.ValueOfString(x.CumulativePrice)
		if !f(fd_PoolTWAP_cumulative_price, value) {
			return
		}
	}
	if x.TotalSeconds != uint64(0) {
		value := protoreflect.ValueOfUint64(x.TotalSeconds)
		if !f(fd_PoolTWAP_total_seconds, value) {
			return
		}
	}
	if x.LastTimestamp != int64(0) {
		value := protoreflect.ValueOfInt64(x.LastTimestamp)
		if !f(fd_PoolTWAP_last_timestamp, value) {
			return
		}
	}
	if x.TwapPrice != "" {
		value := protoreflect.ValueOfString(x.TwapPrice)
		if !f(fd_PoolTWAP_twap_price, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PoolTWAP) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "paw.dex.v1.PoolTWAP.pool_id":
		return x.PoolId != uint64(0)
	case "paw.dex.v1.PoolTWAP.last_price":
		return x.LastPrice != ""
	case "paw.dex.v1.PoolTWAP.cumulative_price":
		return x.CumulativePrice != ""
	case "paw.dex.v1.PoolTWAP.total_seconds":
		return x.TotalSeconds != uint64(0)
	case "paw.dex.v1.PoolTWAP.last_timestamp":
		return x.LastTimestamp != int64(0)
	case "paw.dex.v1.PoolTWAP.twap_price":
		return x.TwapPrice != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.PoolTWAP"))
		}
		panic(fmt.Errorf("message paw.dex.v1.PoolTWAP does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolTWAP) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "paw.dex.v1.PoolTWAP.pool_id":
		x.PoolId = uint64(0)
	case "paw.dex.v1.PoolTWAP.last_price":
		x.LastPrice = ""
	case "paw.dex.v1.PoolTWAP.cumulative_price":
		x.CumulativePrice = ""
	case "paw.dex.v1.PoolTWAP.total_seconds":
		x.TotalSeconds = uint64(0)
	case "paw.dex.v1.PoolTWAP.last_timestamp":
		x.LastTimestamp = int64(0)
	case "paw.dex.v1.PoolTWAP.twap_price":
		x.TwapPrice = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.PoolTWAP"))
		}
		panic(fmt.Errorf("message paw.dex.v1.PoolTWAP does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PoolTWAP) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "paw.dex.v1.PoolTWAP.pool_id":
		value := x.PoolId
		return protoreflect.ValueOfUint64(value)
	case "paw.dex.v1.PoolTWAP.last_price":
		value := x.LastPrice
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.PoolTWAP.cumulative_price":
		value := x.CumulativePrice
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.PoolTWAP.total_seconds":
		value := x.TotalSeconds
		return protoreflect.ValueOfUint64(value)
	case "paw.dex.v1.PoolTWAP.last_timestamp":
		value := x.LastTimestamp
		return protoreflect.ValueOfInt64(value)
	case "paw.dex.v1.PoolTWAP.twap_price":
		value := x.TwapPrice
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.PoolTWAP"))
		}
		panic(fmt.Errorf("message paw.dex.v1.PoolTWAP does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolTWAP) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "paw.dex.v1.PoolTWAP.pool_id":
		x.PoolId = value.Uint()
	case "paw.dex.v1.PoolTWAP.last_price":
		x.LastPrice = value.Interface().(string)
	case "paw.dex.v1.PoolTWAP.cumulative_price":
		x.CumulativePrice = value.Interface().(string)
	case "paw.dex.v1.PoolTWAP.total_seconds":
		x.TotalSeconds = value.Uint()
	case "paw.dex.v1.PoolTWAP.last_timestamp":
		x.LastTimestamp = value.Int()
	case "paw.dex.v1.PoolTWAP.twap_price":
		x.TwapPrice = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.PoolTWAP"))
		}
		panic(fmt.Errorf("message paw.dex.v1.PoolTWAP does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolTWAP) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.PoolTWAP.pool_id":
		panic(fmt.Errorf("field pool_id of message paw.dex.v1.PoolTWAP is not mutable"))
	case "paw.dex.v1.PoolTWAP.last_price":
		panic(fmt.Errorf("field last_price of message paw.dex.v1.PoolTWAP is not mutable"))
	case "paw.dex.v1.PoolTWAP.cumulative_price":
		panic(fmt.Errorf("field cumulative_price of message paw.dex.v1.PoolTWAP is not mutable"))
	case "paw.dex.v1.PoolTWAP.total_seconds":
		panic(fmt.Errorf("field total_seconds of message paw.dex.v1.PoolTWAP is not mutable"))
	case "paw.dex.v1.PoolTWAP.last_timestamp":
		panic(fmt.Errorf("field last_timestamp of message paw.dex.v1.PoolTWAP is not mutable"))
	case "paw.dex.v1.PoolTWAP.twap_price":
		panic(fmt.Errorf("field twap_price of message paw.dex.v1.PoolTWAP is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.PoolTWAP"))
		}
		panic(fmt.Errorf("message paw.dex.v1.PoolTWAP does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PoolTWAP) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.PoolTWAP.pool_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "paw.dex.v1.PoolTWAP.last_price":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.PoolTWAP.cumulative_price":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.PoolTWAP.total_seconds":
		return protoreflect.ValueOfUint64(uint64(0))
	case "paw.dex.v1.PoolTWAP.last_timestamp":
		return protoreflect.ValueOfInt64(int64(0))
	case "paw.dex.v1.PoolTWAP.twap_price":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.PoolTWAP"))
		}
		panic(fmt.Errorf("message paw.dex.v1.PoolTWAP does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PoolTWAP) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in paw.dex.v1.PoolTWAP", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PoolTWAP) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolTWAP) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PoolTWAP) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PoolTWAP) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PoolTWAP)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.PoolId != 0 {
			n += 1 + runtime.Sov(uint64(x.PoolId))
		}
		l = len(x.LastPrice)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CumulativePrice)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.TotalSeconds != 0 {
			n += 1 + runtime.Sov(uint64(x.TotalSeconds))
		}
		if x.LastTimestamp != 0 {
			n += 1 + runtime.Sov(uint64(x.LastTimestamp))
		}
		l = len(x.TwapPrice)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PoolTWAP)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TwapPrice) > 0 {
			i -= len(x.TwapPrice)
			copy(dAtA[i:], x.TwapPrice)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TwapPrice)))
			i--
			dAtA[i] = 0x32
		}
		if x.LastTimestamp != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.LastTimestamp))
			i--
			dAtA[i] = 0x28
		}
		if x.TotalSeconds != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.TotalSeconds))
			i--
			dAtA[i] = 0x20
		}
		if len(x.CumulativePrice) > 0 {
			i -= len(x.CumulativePrice)
			copy(dAtA[i:], x.CumulativePrice)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CumulativePrice)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.LastPrice) > 0 {
			i -= len(x.LastPrice)
			copy(dAtA[i:], x.LastPrice)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LastPrice)))
			i--
			dAtA[i] = 0x12
		}
		if x.PoolId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PoolId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PoolTWAP)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PoolTWAP: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PoolTWAP: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
				}
				x.PoolId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PoolId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastPrice", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LastPrice = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CumulativePrice", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CumulativePrice = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalSeconds", wireType)
				}
				x.TotalSeconds = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.TotalSeconds |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastTimestamp", wireType)
				}
				x.LastTimestamp = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.LastTimestamp |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TwapPrice", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TwapPrice = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_LimitOrder                   protoreflect.MessageDescriptor
	fd_LimitOrder_id                protoreflect.FieldDescriptor
	fd_LimitOrder_owner             protoreflect.FieldDescriptor
	fd_LimitOrder_pool_id           protoreflect.FieldDescriptor
	fd_LimitOrder_order_type        protoreflect.FieldDescriptor
	fd_LimitOrder_token_in          protoreflect.FieldDescriptor
	fd_LimitOrder_token_out         protoreflect.FieldDescriptor
	fd_LimitOrder_amount_in         protoreflect.FieldDescriptor
	fd_LimitOrder_min_amount_out    protoreflect.FieldDescriptor
	fd_LimitOrder_limit_price       protoreflect.FieldDescriptor
	fd_LimitOrder_filled_amount     protoreflect.FieldDescriptor
	fd_LimitOrder_received_amount   protoreflect.FieldDescriptor
	fd_LimitOrder_status            protoreflect.FieldDescriptor
	fd_LimitOrder_created_at        protoreflect.FieldDescriptor
	fd_LimitOrder_expires_at        protoreflect.FieldDescriptor
	fd_LimitOrder_created_at_height protoreflect.FieldDescriptor
)

func init() {
	file_paw_dex_v1_dex_proto_init()
	md_LimitOrder = File_paw_dex_v1_dex_proto.Messages().ByName("LimitOrder")
	fd_LimitOrder_id = md_LimitOrder.Fields().ByName("id")
	fd_LimitOrder_owner = md_LimitOrder.Fields().ByName("owner")
	fd_LimitOrder_pool_id = md_LimitOrder.Fields().ByName("pool_id")
	fd_LimitOrder_order_type = md_LimitOrder.Fields().ByName("order_type")
	fd_LimitOrder_token_in = md_LimitOrder.Fields().ByName("token_in")
	fd_LimitOrder_token_out = md_LimitOrder.Fields().ByName("token_out")
	fd_LimitOrder_amount_in = md_LimitOrder.Fields().ByName("amount_in")
	fd_LimitOrder_min_amount_out = md_LimitOrder.Fields().ByName("min_amount_out")
	fd_LimitOrder_limit_price = md_LimitOrder.Fields().ByName("limit_price")
	fd_LimitOrder_filled_amount = md_LimitOrder.Fields().ByName("filled_amount")
	fd_LimitOrder_received_amount = md_LimitOrder.Fields().ByName("received_amount")
	fd_LimitOrder_status = md_LimitOrder.Fields().ByName("status")
	fd_LimitOrder_created_at = md_LimitOrder.Fields().ByName("created_at")
	fd_LimitOrder_expires_at = md_LimitOrder.Fields().ByName("expires_at")
	fd_LimitOrder_created_at_height = md_LimitOrder.Fields().ByName("created_at_height")
}

var _ protoreflect.Message = (*fastReflection_LimitOrder)(nil)

type fastReflection_LimitOrder LimitOrder

func (x *LimitOrder) ProtoReflect() protoreflect.Message {
	return (*fastReflection_LimitOrder)(x)
}

func (x *LimitOrder) slowProtoReflect() protoreflect.Message {
	mi := &file_paw_dex_v1_dex_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_LimitOrder_messageType fastReflection_LimitOrder_messageType
var _ protoreflect.MessageType = fastReflection_LimitOrder_messageType{}

type fastReflection_LimitOrder_messageType struct{}

func (x fastReflection_LimitOrder_messageType) Zero() protoreflect.Message {
	return (*fastReflection_LimitOrder)(nil)
}
func (x fastReflection_LimitOrder_messageType) New() protoreflect.Message {
	return new(fastReflection_LimitOrder)
}
func (x fastReflection_LimitOrder_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_LimitOrder
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_LimitOrder) Descriptor() protoreflect.MessageDescriptor {
	return md_LimitOrder
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_LimitOrder) Type() protoreflect.MessageType {
	return _fastReflection_LimitOrder_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_LimitOrder) New() protoreflect.Message {
	return new(fastReflection_LimitOrder)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_LimitOrder) Interface() protoreflect.ProtoMessage {
	return (*LimitOrder)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_LimitOrder) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Id)
		if !f(fd_LimitOrder_id, value) {
			return
		}
	}
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_LimitOrder_owner, value) {
			return
		}
	}
	if x.PoolId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PoolId)
		if !f(fd_LimitOrder_pool_id, value) {
			return
		}
	}
	if x.OrderType != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.OrderType))
		if !f(fd_LimitOrder_order_type, value) {
			return
		}
	}
	if x.TokenIn != "" {
		value := protoreflect.ValueOfString(x.TokenIn)
		if !f(fd_LimitOrder_token_in, value) {
			return
		}
	}
	if x.TokenOut != "" {
		value := protoreflect.ValueOfString(x.TokenOut)
		if !f(fd_LimitOrder_token_out, value) {
			return
		}
	}
	if x.AmountIn != "" {
		value := protoreflect.ValueOfString(x.AmountIn)
		if !f(fd_LimitOrder_amount_in, value) {
			return
		}
	}
	if x.MinAmountOut != "" {
		value := protoreflect.ValueOfString(x.MinAmountOut)
		if !f(fd_LimitOrder_min_amount_out, value) {
			return
		}
	}
	if x.LimitPrice != "" {
		value := protoreflect.ValueOfString(x.LimitPrice)
		if !f(fd_LimitOrder_limit_price, value) {
			return
		}
	}
	if x.FilledAmount != "" {
		value := protoreflect.ValueOfString(x.FilledAmount)
		if !f(fd_LimitOrder_filled_amount, value) {
			return
		}
	}
	if x.ReceivedAmount != "" {
		value := protoreflect.ValueOfString(x.ReceivedAmount)
		if !f(fd_LimitOrder_received_amount, value) {
			return
		}
	}
	if x.Status != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Status))
		if !f(fd_LimitOrder_status, value) {
			return
		}
	}
	if x.CreatedAt != int64(0) {
		value := protoreflect.ValueOfInt64(x.CreatedAt)
		if !f(fd_LimitOrder_created_at, value) {
			return
		}
	}
	if x.ExpiresAt != int64(0) {
		value := protoreflect.ValueOfInt64(x.ExpiresAt)
		if !f(fd_LimitOrder_expires_at, value) {
			return
		}
	}
	if x.CreatedAtHeight != int64(0) {
		value := protoreflect.ValueOfInt64(x.CreatedAtHeight)
		if !f(fd_LimitOrder_created_at_height, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_LimitOrder) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "paw.dex.v1.LimitOrder.id":
		return x.Id != uint64(0)
	case "paw.dex.v1.LimitOrder.owner":
		return x.Owner != ""
	case "paw.dex.v1.LimitOrder.pool_id":
		return x.PoolId != uint64(0)
	case "paw.dex.v1.LimitOrder.order_type":
		return x.OrderType != 0
	case "paw.dex.v1.LimitOrder.token_in":
		return x.TokenIn != ""
	case "paw.dex.v1.LimitOrder.token_out":
		return x.TokenOut != ""
	case "paw.dex.v1.LimitOrder.amount_in":
		return x.AmountIn != ""
	case "paw.dex.v1.LimitOrder.min_amount_out":
		return x.MinAmountOut != ""
	case "paw.dex.v1.LimitOrder.limit_price":
		return x.LimitPrice != ""
	case "paw.dex.v1.LimitOrder.filled_amount":
		return x.FilledAmount != ""
	case "paw.dex.v1.LimitOrder.received_amount":
		return x.ReceivedAmount != ""
	case "paw.dex.v1.LimitOrder.status":
		return x.Status != 0
	case "paw.dex.v1.LimitOrder.created_at":
		return x.CreatedAt != int64(0)
	case "paw.dex.v1.LimitOrder.expires_at":
		return x.ExpiresAt != int64(0)
	case "paw.dex.v1.LimitOrder.created_at_height":
		return x.CreatedAtHeight != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.LimitOrder"))
		}
		panic(fmt.Errorf("message paw.dex.v1.LimitOrder does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LimitOrder) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "paw.dex.v1.LimitOrder.id":
		x.Id = uint64(0)
	case "paw.dex.v1.LimitOrder.owner":
		x.Owner = ""
	case "paw.dex.v1.LimitOrder.pool_id":
		x.PoolId = uint64(0)
	case "paw.dex.v1.LimitOrder.order_type":
		x.OrderType = 0
	case "paw.dex.v1.LimitOrder.token_in":
		x.TokenIn = ""
	case "paw.dex.v1.LimitOrder.token_out":
		x.TokenOut = ""
	case "paw.dex.v1.LimitOrder.amount_in":
		x.AmountIn = ""
	case "paw.dex.v1.LimitOrder.min_amount_out":
		x.MinAmountOut = ""
	case "paw.dex.v1.LimitOrder.limit_price":
		x.LimitPrice = ""
	case "paw.dex.v1.LimitOrder.filled_amount":
		x.FilledAmount = ""
	case "paw.dex.v1.LimitOrder.received_amount":
		x.ReceivedAmount = ""
	case "paw.dex.v1.LimitOrder.status":
		x.Status = 0
	case "paw.dex.v1.LimitOrder.created_at":
		x.CreatedAt = int64(0)
	case "paw.dex.v1.LimitOrder.expires_at":
		x.ExpiresAt = int64(0)
	case "paw.dex.v1.LimitOrder.created_at_height":
		x.CreatedAtHeight = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.LimitOrder"))
		}
		panic(fmt.Errorf("message paw.dex.v1.LimitOrder does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_LimitOrder) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "paw.dex.v1.LimitOrder.id":
		value := x.Id
		return protoreflect.ValueOfUint64(value)
	case "paw.dex.v1.LimitOrder.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.LimitOrder.pool_id":
		value := x.PoolId
		return protoreflect.ValueOfUint64(value)
	case "paw.dex.v1.LimitOrder.order_type":
		value := x.OrderType
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "paw.dex.v1.LimitOrder.token_in":
		value := x.TokenIn
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.LimitOrder.token_out":
		value := x.TokenOut
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.LimitOrder.amount_in":
		value := x.AmountIn
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.LimitOrder.min_amount_out":
		value := x.MinAmountOut
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.LimitOrder.limit_price":
		value := x.LimitPrice
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.LimitOrder.filled_amount":
		value := x.FilledAmount
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.LimitOrder.received_amount":
		value := x.ReceivedAmount
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.LimitOrder.status":
		value := x.Status
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "paw.dex.v1.LimitOrder.created_at":
		value := x.CreatedAt
		return protoreflect.ValueOfInt64(value)
	case "paw.dex.v1.LimitOrder.expires_at":
		value := x.ExpiresAt
		return protoreflect.ValueOfInt64(value)
	case "paw.dex.v1.LimitOrder.created_at_height":
		value := x.CreatedAtHeight
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.LimitOrder"))
		}
		panic(fmt.Errorf("message paw.dex.v1.LimitOrder does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LimitOrder) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "paw.dex.v1.LimitOrder.id":
		x.Id = value.Uint()
	case "paw.dex.v1.LimitOrder.owner":
		x.Owner = value.Interface().(string)
	case "paw.dex.v1.LimitOrder.pool_id":
		x.PoolId = value.Uint()
	case "paw.dex.v1.LimitOrder.order_type":
		x.OrderType = (OrderType)(value.Enum())
	case "paw.dex.v1.LimitOrder.token_in":
		x.TokenIn = value.Interface().(string)
	case "paw.dex.v1.LimitOrder.token_out":
		x.TokenOut = value.Interface().(string)
	case "paw.dex.v1.LimitOrder.amount_in":
		x.AmountIn = value.Interface().(string)
	case "paw.dex.v1.LimitOrder.min_amount_out":
		x.MinAmountOut = value.Interface().(string)
	case "paw.dex.v1.LimitOrder.limit_price":
		x.LimitPrice = value.Interface().(string)
	case "paw.dex.v1.LimitOrder.filled_amount":
		x.FilledAmount = value.Interface().(string)
	case "paw.dex.v1.LimitOrder.received_amount":
		x.ReceivedAmount = value.Interface().(string)
	case "paw.dex.v1.LimitOrder.status":
		x.Status = (OrderStatus)(value.Enum())
	case "paw.dex.v1.LimitOrder.created_at":
		x.CreatedAt = value.Int()
	case "paw.dex.v1.LimitOrder.expires_at":
		x.ExpiresAt = value.Int()
	case "paw.dex.v1.LimitOrder.created_at_height":
		x.CreatedAtHeight = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.LimitOrder"))
		}
		panic(fmt.Errorf("message paw.dex.v1.LimitOrder does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LimitOrder) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.LimitOrder.id":
		panic(fmt.Errorf("field id of message paw.dex.v1.LimitOrder is not mutable"))
	case "paw.dex.v1.LimitOrder.owner":
		panic(fmt.Errorf("field owner of message paw.dex.v1.LimitOrder is not mutable"))
	case "paw.dex.v1.LimitOrder.pool_id":
		panic(fmt.Errorf("field pool_id of message paw.dex.v1.LimitOrder is not mutable"))
	case "paw.dex.v1.LimitOrder.order_type":
		panic(fmt.Errorf("field order_type of message paw.dex.v1.LimitOrder is not mutable"))
	case "paw.dex.v1.LimitOrder.token_in":
		panic(fmt.Errorf("field token_in of message paw.dex.v1.LimitOrder is not mutable"))
	case "paw.dex.v1.LimitOrder.token_out":
		panic(fmt.Errorf("field token_out of message paw.dex.v1.LimitOrder is not mutable"))
	case "paw.dex.v1.LimitOrder.amount_in":
		panic(fmt.Errorf("field amount_in of message paw.dex.v1.LimitOrder is not mutable"))
	case "paw.dex.v1.LimitOrder.min_amount_out":
		panic(fmt.Errorf("field min_amount_out of message paw.dex.v1.LimitOrder is not mutable"))
	case "paw.dex.v1.LimitOrder.limit_price":
		panic(fmt.Errorf("field limit_price of message paw.dex.v1.LimitOrder is not mutable"))
	case "paw.dex.v1.LimitOrder.filled_amount":
		panic(fmt.Errorf("field filled_amount of message paw.dex.v1.LimitOrder is not mutable"))
	case "paw.dex.v1.LimitOrder.received_amount":
		panic(fmt.Errorf("field received_amount of message paw.dex.v1.LimitOrder is not mutable"))
	case "paw.dex.v1.LimitOrder.status":
		panic(fmt.Errorf("field status of message paw.dex.v1.LimitOrder is not mutable"))
	case "paw.dex.v1.LimitOrder.created_at":
		panic(fmt.Errorf("field created_at of message paw.dex.v1.LimitOrder is not mutable"))
	case "paw.dex.v1.LimitOrder.expires_at":
		panic(fmt.Errorf("field expires_at of message paw.dex.v1.LimitOrder is not mutable"))
	case "paw.dex.v1.LimitOrder.created_at_height":
		panic(fmt.Errorf("field created_at_height of message paw.dex.v1.LimitOrder is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.LimitOrder"))
		}
		panic(fmt.Errorf("message paw.dex.v1.LimitOrder does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_LimitOrder) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.LimitOrder.id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "paw.dex.v1.LimitOrder.owner":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.LimitOrder.pool_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "paw.dex.v1.LimitOrder.order_type":
		return protoreflect.ValueOfEnum(0)
	case "paw.dex.v1.LimitOrder.token_in":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.LimitOrder.token_out":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.LimitOrder.amount_in":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.LimitOrder.min_amount_out":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.LimitOrder.limit_price":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.LimitOrder.filled_amount":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.LimitOrder.received_amount":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.LimitOrder.status":
		return protoreflect.ValueOfEnum(0)
	case "paw.dex.v1.LimitOrder.created_at":
		return protoreflect.ValueOfInt64(int64(0))
	case "paw.dex.v1.LimitOrder.expires_at":
		return protoreflect.ValueOfInt64(int64(0))
	case "paw.dex.v1.LimitOrder.created_at_height":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.LimitOrder"))
		}
		panic(fmt.Errorf("message paw.dex.v1.LimitOrder does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_LimitOrder) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in paw.dex.v1.LimitOrder", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_LimitOrder) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LimitOrder) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_LimitOrder) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_LimitOrder) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*LimitOrder)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Id != 0 {
			n += 1 + runtime.Sov(uint64(x.Id))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.PoolId != 0 {
			n += 1 + runtime.Sov(uint64(x.PoolId))
		}
		if x.OrderType != 0 {
			n += 1 + runtime.Sov(uint64(x.OrderType))
		}
		l = len(x.TokenIn)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TokenOut)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AmountIn)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MinAmountOut)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LimitPrice)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.FilledAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ReceivedAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Status != 0 {
			n += 1 + runtime.Sov(uint64(x.Status))
		}
		if x.CreatedAt != 0 {
			n += 1 + runtime.Sov(uint64(x.CreatedAt))
		}
		if x.ExpiresAt != 0 {
			n += 1 + runtime.Sov(uint64(x.ExpiresAt))
		}
		if x.CreatedAtHeight != 0 {
			n += 1 + runtime.Sov(uint64(x.CreatedAtHeight))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*LimitOrder)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.CreatedAtHeight != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.CreatedAtHeight))
			i--
			dAtA[i] = 0x78
		}
		if x.ExpiresAt != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ExpiresAt))
			i--
			dAtA[i] = 0x70
		}
		if x.CreatedAt != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.CreatedAt))
			i--
			dAtA[i] = 0x68
		}
		if x.Status != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Status))
			i--
			dAtA[i] = 0x60
		}
		if len(x.ReceivedAmount) > 0 {
			i -= len(x.ReceivedAmount)
			copy(dAtA[i:], x.ReceivedAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReceivedAmount)))
			i--
			dAtA[i] = 0x5a
		}
		if len(x.FilledAmount) > 0 {
			i -= len(x.FilledAmount)
			copy(dAtA[i:], x.FilledAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FilledAmount)))
			i--
			dAtA[i] = 0x52
		}
		if len(x.LimitPrice) > 0 {
			i -= len(x.LimitPrice)
			copy(dAtA[i:], x.LimitPrice)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LimitPrice)))
			i--
			dAtA[i] = 0x4a
		}
		if len(x.MinAmountOut) > 0 {
			i -= len(x.MinAmountOut)
			copy(dAtA[i:], x.MinAmountOut)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MinAmountOut)))
			i--
			dAtA[i] = 0x42
		}
		if len(x.AmountIn) > 0 {
			i -= len(x.AmountIn)
			copy(dAtA[i:], x.AmountIn)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AmountIn)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.TokenOut) > 0 {
			i -= len(x.TokenOut)
			copy(dAtA[i:], x.TokenOut)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TokenOut)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.TokenIn) > 0 {
			i -= len(x.TokenIn)
			copy(dAtA[i:], x.TokenIn)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TokenIn)))
			i--
			dAtA[i] = 0x2a
		}
		if x.OrderType != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.OrderType))
			i--
			dAtA[i] = 0x20
		}
		if x.PoolId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PoolId))
			i--
			dAtA[i] = 0x18
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x12
		}
		if x.Id != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Id))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*LimitOrder)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: LimitOrder: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: LimitOrder: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				x.Id = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Id |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
				}
				x.PoolId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PoolId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
				}
				x.OrderType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.OrderType |= OrderType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TokenIn", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TokenIn = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TokenOut", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TokenOut = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AmountIn", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AmountIn = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MinAmountOut", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MinAmountOut = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LimitPrice", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LimitPrice = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FilledAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FilledAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReceivedAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReceivedAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 12:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
				}
				x.Status = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Status |= OrderStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 13:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
				}
				x.CreatedAt = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.CreatedAt |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 14:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
				}
				x.ExpiresAt = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ExpiresAt |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 15:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CreatedAtHeight", wireType)
				}
				x.CreatedAtHeight = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.CreatedAtHeight |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_CircuitBreakerStateExport                    protoreflect.MessageDescriptor
	fd_CircuitBreakerStateExport_pool_id            protoreflect.FieldDescriptor
	fd_CircuitBreakerStateExport_enabled            protoreflect.FieldDescriptor
	fd_CircuitBreakerStateExport_paused_until       protoreflect.FieldDescriptor
	fd_CircuitBreakerStateExport_last_price         protoreflect.FieldDescriptor
	fd_CircuitBreakerStateExport_triggered_by       protoreflect.FieldDescriptor
	fd_CircuitBreakerStateExport_trigger_reason     protoreflect.FieldDescriptor
	fd_CircuitBreakerStateExport_notifications_sent protoreflect.FieldDescriptor
	fd_CircuitBreakerStateExport_last_notification  protoreflect.FieldDescriptor
	fd_CircuitBreakerStateExport_persistence_key    protoreflect.FieldDescriptor
)

func init() {
	file_paw_dex_v1_dex_proto_init()
	md_CircuitBreakerStateExport = File_paw_dex_v1_dex_proto.Messages().ByName("CircuitBreakerStateExport")
	fd_CircuitBreakerStateExport_pool_id = md_CircuitBreakerStateExport.Fields().ByName("pool_id")
	fd_CircuitBreakerStateExport_enabled = md_CircuitBreakerStateExport.Fields().ByName("enabled")
	fd_CircuitBreakerStateExport_paused_until = md_CircuitBreakerStateExport.Fields().ByName("paused_until")
	fd_CircuitBreakerStateExport_last_price = md_CircuitBreakerStateExport.Fields().ByName("last_price")
	fd_CircuitBreakerStateExport_triggered_by = md_CircuitBreakerStateExport.Fields().ByName("triggered_by")
	fd_CircuitBreakerStateExport_trigger_reason = md_CircuitBreakerStateExport.Fields().ByName("trigger_reason")
	fd_CircuitBreakerStateExport_notifications_sent = md_CircuitBreakerStateExport.Fields().ByName("notifications_sent")
	fd_CircuitBreakerStateExport_last_notification = md_CircuitBreakerStateExport.Fields().ByName("last_notification")
	fd_CircuitBreakerStateExport_persistence_key = md_CircuitBreakerStateExport.Fields().ByName("persistence_key")
}

var _ protoreflect.Message = (*fastReflection_CircuitBreakerStateExport)(nil)

type fastReflection_CircuitBreakerStateExport CircuitBreakerStateExport

func (x *CircuitBreakerStateExport) ProtoReflect() protoreflect.Message {
	return (*fastReflection_CircuitBreakerStateExport)(x)
}

func (x *CircuitBreakerStateExport) slowProtoReflect() protoreflect.Message {
	mi := &file_paw_dex_v1_dex_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_CircuitBreakerStateExport_messageType fastReflection_CircuitBreakerStateExport_messageType
var _ protoreflect.MessageType = fastReflection_CircuitBreakerStateExport_messageType{}

type fastReflection_CircuitBreakerStateExport_messageType struct{}

func (x fastReflection_CircuitBreakerStateExport_messageType) Zero() protoreflect.Message {
	return (*fastReflection_CircuitBreakerStateExport)(nil)
}
func (x fastReflection_CircuitBreakerStateExport_messageType) New() protoreflect.Message {
	return new(fastReflection_CircuitBreakerStateExport)
}
func (x fastReflection_CircuitBreakerStateExport_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_CircuitBreakerStateExport
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_CircuitBreakerStateExport) Descriptor() protoreflect.MessageDescriptor {
	return md_CircuitBreakerStateExport
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_CircuitBreakerStateExport) Type() protoreflect.MessageType {
	return _fastReflection_CircuitBreakerStateExport_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_CircuitBreakerStateExport) New() protoreflect.Message {
	return new(fastReflection_CircuitBreakerStateExport)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_CircuitBreakerStateExport) Interface() protoreflect.ProtoMessage {
	return (*CircuitBreakerStateExport)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_CircuitBreakerStateExport) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PoolId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PoolId)
		if !f(fd_CircuitBreakerStateExport_pool_id, value) {
			return
		}
	}
	if x.Enabled != false {
		value := protoreflect.ValueOfBool(x.Enabled)
		if !f(fd_CircuitBreakerStateExport_enabled, value) {
			return
		}
	}
	if x.PausedUntil != int64(0) {
		value := protoreflect.ValueOfInt64(x.PausedUntil)
		if !f(fd_CircuitBreakerStateExport_paused_until, value) {
			return
		}
	}
	if x.LastPrice != "" {
		value := protoreflect.ValueOfString(x.LastPrice)
		if !f(fd_CircuitBreakerStateExport_last_price, value) {
			return
		}
	}
	if x.TriggeredBy != "" {
		value := protoreflect.ValueOfString(x.TriggeredBy)
		if !f(fd_CircuitBreakerStateExport_triggered_by, value) {
			return
		}
	}
	if x.TriggerReason != "" {
		value := protoreflect.ValueOfString(x.TriggerReason)
		if !f(fd_CircuitBreakerStateExport_trigger_reason, value) {
			return
		}
	}
	if x.NotificationsSent != int32(0) {
		value := protoreflect.ValueOfInt32(x.NotificationsSent)
		if !f(fd_CircuitBreakerStateExport_notifications_sent, value) {
			return
		}
	}
	if x.LastNotification != int64(0) {
		value := protoreflect.ValueOfInt64(x.LastNotification)
		if !f(fd_CircuitBreakerStateExport_last_notification, value) {
			return
		}
	}
	if x.PersistenceKey != "" {
		value := protoreflect.ValueOfString(x.PersistenceKey)
		if !f(fd_CircuitBreakerStateExport_persistence_key, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_CircuitBreakerStateExport) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "paw.dex.v1.CircuitBreakerStateExport.pool_id":
		return x.PoolId != uint64(0)
	case "paw.dex.v1.CircuitBreakerStateExport.enabled":
		return x.Enabled != false
	case "paw.dex.v1.CircuitBreakerStateExport.paused_until":
		return x.PausedUntil != int64(0)
	case "paw.dex.v1.CircuitBreakerStateExport.last_price":
		return x.LastPrice != ""
	case "paw.dex.v1.CircuitBreakerStateExport.triggered_by":
		return x.TriggeredBy != ""
	case "paw.dex.v1.CircuitBreakerStateExport.trigger_reason":
		return x.TriggerReason != ""
	case "paw.dex.v1.CircuitBreakerStateExport.notifications_sent":
		return x.NotificationsSent != int32(0)
	case "paw.dex.v1.CircuitBreakerStateExport.last_notification":
		return x.LastNotification != int64(0)
	case "paw.dex.v1.CircuitBreakerStateExport.persistence_key":
		return x.PersistenceKey != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.CircuitBreakerStateExport"))
		}
		panic(fmt.Errorf("message paw.dex.v1.CircuitBreakerStateExport does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CircuitBreakerStateExport) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "paw.dex.v1.CircuitBreakerStateExport.pool_id":
		x.PoolId = uint64(0)
	case "paw.dex.v1.CircuitBreakerStateExport.enabled":
		x.Enabled = false
	case "paw.dex.v1.CircuitBreakerStateExport.paused_until":
		x.PausedUntil = int64(0)
	case "paw.dex.v1.CircuitBreakerStateExport.last_price":
		x.LastPrice = ""
	case "paw.dex.v1.CircuitBreakerStateExport.triggered_by":
		x.TriggeredBy = ""
	case "paw.dex.v1.CircuitBreakerStateExport.trigger_reason":
		x.TriggerReason = ""
	case "paw.dex.v1.CircuitBreakerStateExport.notifications_sent":
		x.NotificationsSent = int32(0)
	case "paw.dex.v1.CircuitBreakerStateExport.last_notification":
		x.LastNotification = int64(0)
	case "paw.dex.v1.CircuitBreakerStateExport.persistence_key":
		x.PersistenceKey = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.CircuitBreakerStateExport"))
		}
		panic(fmt.Errorf("message paw.dex.v1.CircuitBreakerStateExport does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_CircuitBreakerStateExport) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "paw.dex.v1.CircuitBreakerStateExport.pool_id":
		value := x.PoolId
		return protoreflect.ValueOfUint64(value)
	case "paw.dex.v1.CircuitBreakerStateExport.enabled":
		value := x.Enabled
		return protoreflect.ValueOfBool(value)
	case "paw.dex.v1.CircuitBreakerStateExport.paused_until":
		value := x.PausedUntil
		return protoreflect.ValueOfInt64(value)
	case "paw.dex.v1.CircuitBreakerStateExport.last_price":
		value := x.LastPrice
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.CircuitBreakerStateExport.triggered_by":
		value := x.TriggeredBy
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.CircuitBreakerStateExport.trigger_reason":
		value := x.TriggerReason
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.CircuitBreakerStateExport.notifications_sent":
		value := x.NotificationsSent
		return protoreflect.ValueOfInt32(value)
	case "paw.dex.v1.CircuitBreakerStateExport.last_notification":
		value := x.LastNotification
		return protoreflect.ValueOfInt64(value)
	case "paw.dex.v1.CircuitBreakerStateExport.persistence_key":
		value := x.PersistenceKey
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.CircuitBreakerStateExport"))
		}
		panic(fmt.Errorf("message paw.dex.v1.CircuitBreakerStateExport does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CircuitBreakerStateExport) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "paw.dex.v1.CircuitBreakerStateExport.pool_id":
		x.PoolId = value.Uint()
	case "paw.dex.v1.CircuitBreakerStateExport.enabled":
		x.Enabled = value.Bool()
	case "paw.dex.v1.CircuitBreakerStateExport.paused_until":
		x.PausedUntil = value.Int()
	case "paw.dex.v1.CircuitBreakerStateExport.last_price":
		x.LastPrice = value.Interface().(string)
	case "paw.dex.v1.CircuitBreakerStateExport.triggered_by":
		x.TriggeredBy = value.Interface().(string)
	case "paw.dex.v1.CircuitBreakerStateExport.trigger_reason":
		x.TriggerReason = value.Interface().(string)
	case "paw.dex.v1.CircuitBreakerStateExport.notifications_sent":
		x.NotificationsSent = int32(value.Int())
	case "paw.dex.v1.CircuitBreakerStateExport.last_notification":
		x.LastNotification = value.Int()
	case "paw.dex.v1.CircuitBreakerStateExport.persistence_key":
		x.PersistenceKey = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.CircuitBreakerStateExport"))
		}
		panic(fmt.Errorf("message paw.dex.v1.CircuitBreakerStateExport does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CircuitBreakerStateExport) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.CircuitBreakerStateExport.pool_id":
		panic(fmt.Errorf("field pool_id of message paw.dex.v1.CircuitBreakerStateExport is not mutable"))
	case "paw.dex.v1.CircuitBreakerStateExport.enabled":
		panic(fmt.Errorf("field enabled of message paw.dex.v1.CircuitBreakerStateExport is not mutable"))
	case "paw.dex.v1.CircuitBreakerStateExport.paused_until":
		panic(fmt.Errorf("field paused_until of message paw.dex.v1.CircuitBreakerStateExport is not mutable"))
	case "paw.dex.v1.CircuitBreakerStateExport.last_price":
		panic(fmt.Errorf("field last_price of message paw.dex.v1.CircuitBreakerStateExport is not mutable"))
	case "paw.dex.v1.CircuitBreakerStateExport.triggered_by":
		panic(fmt.Errorf("field triggered_by of message paw.dex.v1.CircuitBreakerStateExport is not mutable"))
	case "paw.dex.v1.CircuitBreakerStateExport.trigger_reason":
		panic(fmt.Errorf("field trigger_reason of message paw.dex.v1.CircuitBreakerStateExport is not mutable"))
	case "paw.dex.v1.CircuitBreakerStateExport.notifications_sent":
		panic(fmt.Errorf("field notifications_sent of message paw.dex.v1.CircuitBreakerStateExport is not mutable"))
	case "paw.dex.v1.CircuitBreakerStateExport.last_notification":
		panic(fmt.Errorf("field last_notification of message paw.dex.v1.CircuitBreakerStateExport is not mutable"))
	case "paw.dex.v1.CircuitBreakerStateExport.persistence_key":
		panic(fmt.Errorf("field persistence_key of message paw.dex.v1.CircuitBreakerStateExport is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.CircuitBreakerStateExport"))
		}
		panic(fmt.Errorf("message paw.dex.v1.CircuitBreakerStateExport does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_CircuitBreakerStateExport) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.CircuitBreakerStateExport.pool_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "paw.dex.v1.CircuitBreakerStateExport.enabled":
		return protoreflect.ValueOfBool(false)
	case "paw.dex.v1.CircuitBreakerStateExport.paused_until":
		return protoreflect.ValueOfInt64(int64(0))
	case "paw.dex.v1.CircuitBreakerStateExport.last_price":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.CircuitBreakerStateExport.triggered_by":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.CircuitBreakerStateExport.trigger_reason":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.CircuitBreakerStateExport.notifications_sent":
		return protoreflect.ValueOfInt32(int32(0))
	case "paw.dex.v1.CircuitBreakerStateExport.last_notification":
		return protoreflect.ValueOfInt64(int64(0))
	case "paw.dex.v1.CircuitBreakerStateExport.persistence_key":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.CircuitBreakerStateExport"))
		}
		panic(fmt.Errorf("message paw.dex.v1.CircuitBreakerStateExport does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_CircuitBreakerStateExport) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in paw.dex.v1.CircuitBreakerStateExport", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_CircuitBreakerStateExport) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CircuitBreakerStateExport) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_CircuitBreakerStateExport) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_CircuitBreakerStateExport) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*CircuitBreakerStateExport)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.PoolId != 0 {
			n += 1 + runtime.Sov(uint64(x.PoolId))
		}
		if x.Enabled {
			n += 2
		}
		if x.PausedUntil != 0 {
			n += 1 + runtime.Sov(uint64(x.PausedUntil))
		}
		l = len(x.LastPrice)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TriggeredBy)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TriggerReason)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.NotificationsSent != 0 {
			n += 1 + runtime.Sov(uint64(x.NotificationsSent))
		}
		if x.LastNotification != 0 {
			n += 1 + runtime.Sov(uint64(x.LastNotification))
		}
		l = len(x.PersistenceKey)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*CircuitBreakerStateExport)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.PersistenceKey) > 0 {
			i -= len(x.PersistenceKey)
			copy(dAtA[i:], x.PersistenceKey)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PersistenceKey)))
			i--
			dAtA[i] = 0x4a
		}
		if x.LastNotification != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.LastNotification))
			i--
			dAtA[i] = 0x40
		}
		if x.NotificationsSent != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.NotificationsSent))
			i--
			dAtA[i] = 0x38
		}
		if len(x.TriggerReason) > 0 {
			i -= len(x.TriggerReason)
			copy(dAtA[i:], x.TriggerReason)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TriggerReason)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.TriggeredBy) > 0 {
			i -= len(x.TriggeredBy)
			copy(dAtA[i:], x.TriggeredBy)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TriggeredBy)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.LastPrice) > 0 {
			i -= len(x.LastPrice)
			copy(dAtA[i:], x.LastPrice)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LastPrice)))
			i--
			dAtA[i] = 0x22
		}
		if x.PausedUntil != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PausedUntil))
			i--
			dAtA[i] = 0x18
		}
		if x.Enabled {
			i--
			if x.Enabled {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
		}
		if x.PoolId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PoolId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*CircuitBreakerStateExport)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CircuitBreakerStateExport: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CircuitBreakerStateExport: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
				}
				x.PoolId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PoolId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Enabled = bool(v != 0)
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PausedUntil", wireType)
				}
				x.PausedUntil = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PausedUntil |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastPrice", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LastPrice = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TriggeredBy", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TriggeredBy = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TriggerReason", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TriggerReason = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NotificationsSent", wireType)
				}
				x.NotificationsSent = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.NotificationsSent |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastNotification", wireType)
				}
				x.LastNotification = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.LastNotification |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PersistenceKey", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PersistenceKey = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_LiquidityPositionExport          protoreflect.MessageDescriptor
	fd_LiquidityPositionExport_pool_id  protoreflect.FieldDescriptor
	fd_LiquidityPositionExport_provider protoreflect.FieldDescriptor
	fd_LiquidityPositionExport_shares   protoreflect.FieldDescriptor
)

func init() {
	file_paw_dex_v1_dex_proto_init()
	md_LiquidityPositionExport = File_paw_dex_v1_dex_proto.Messages().ByName("LiquidityPositionExport")
	fd_LiquidityPositionExport_pool_id = md_LiquidityPositionExport.Fields().ByName("pool_id")
	fd_LiquidityPositionExport_provider = md_LiquidityPositionExport.Fields().ByName("provider")
	fd_LiquidityPositionExport_shares = md_LiquidityPositionExport.Fields().ByName("shares")
}

var _ protoreflect.Message = (*fastReflection_LiquidityPositionExport)(nil)

type fastReflection_LiquidityPositionExport LiquidityPositionExport

func (x *LiquidityPositionExport) ProtoReflect() protoreflect.Message {
	return (*fastReflection_LiquidityPositionExport)(x)
}

func (x *LiquidityPositionExport) slowProtoReflect() protoreflect.Message {
	mi := &file_paw_dex_v1_dex_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_LiquidityPositionExport_messageType fastReflection_LiquidityPositionExport_messageType
var _ protoreflect.MessageType = fastReflection_LiquidityPositionExport_messageType{}

type fastReflection_LiquidityPositionExport_messageType struct{}

func (x fastReflection_LiquidityPositionExport_messageType) Zero() protoreflect.Message {
	return (*fastReflection_LiquidityPositionExport)(nil)
}
func (x fastReflection_LiquidityPositionExport_messageType) New() protoreflect.Message {
	return new(fastReflection_LiquidityPositionExport)
}
func (x fastReflection_LiquidityPositionExport_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_LiquidityPositionExport
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_LiquidityPositionExport) Descriptor() protoreflect.MessageDescriptor {
	return md_LiquidityPositionExport
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_LiquidityPositionExport) Type() protoreflect.MessageType {
	return _fastReflection_LiquidityPositionExport_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_LiquidityPositionExport) New() protoreflect.Message {
	return new(fastReflection_LiquidityPositionExport)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_LiquidityPositionExport) Interface() protoreflect.ProtoMessage {
	return (*LiquidityPositionExport)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_LiquidityPositionExport) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PoolId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PoolId)
		if !f(fd_LiquidityPositionExport_pool_id, value) {
			return
		}
	}
	if x.Provider != "" {
		value := protoreflect.ValueOfString(x.Provider)
		if !f(fd_LiquidityPositionExport_provider, value) {
			return
		}
	}
	if x.Shares != "" {
		value := protoreflect.ValueOfString(x.Shares)
		if !f(fd_LiquidityPositionExport_shares, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_LiquidityPositionExport) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "paw.dex.v1.LiquidityPositionExport.pool_id":
		return x.PoolId != uint64(0)
	case "paw.dex.v1.LiquidityPositionExport.provider":
		return x.Provider != ""
	case "paw.dex.v1.LiquidityPositionExport.shares":
		return x.Shares != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.LiquidityPositionExport"))
		}
		panic(fmt.Errorf("message paw.dex.v1.LiquidityPositionExport does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LiquidityPositionExport) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "paw.dex.v1.LiquidityPositionExport.pool_id":
		x.PoolId = uint64(0)
	case "paw.dex.v1.LiquidityPositionExport.provider":
		x.Provider = ""
	case "paw.dex.v1.LiquidityPositionExport.shares":
		x.Shares = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.LiquidityPositionExport"))
		}
		panic(fmt.Errorf("message paw.dex.v1.LiquidityPositionExport does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_LiquidityPositionExport) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "paw.dex.v1.LiquidityPositionExport.pool_id":
		value := x.PoolId
		return protoreflect.ValueOfUint64(value)
	case "paw.dex.v1.LiquidityPositionExport.provider":
		value := x.Provider
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.LiquidityPositionExport.shares":
		value := x.Shares
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.LiquidityPositionExport"))
		}
		panic(fmt.Errorf("message paw.dex.v1.LiquidityPositionExport does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LiquidityPositionExport) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "paw.dex.v1.LiquidityPositionExport.pool_id":
		x.PoolId = value.Uint()
	case "paw.dex.v1.LiquidityPositionExport.provider":
		x.Provider = value.Interface().(string)
	case "paw.dex.v1.LiquidityPositionExport.shares":
		x.Shares = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.LiquidityPositionExport"))
		}
		panic(fmt.Errorf("message paw.dex.v1.LiquidityPositionExport does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LiquidityPositionExport) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.LiquidityPositionExport.pool_id":
		panic(fmt.Errorf("field pool_id of message paw.dex.v1.LiquidityPositionExport is not mutable"))
	case "paw.dex.v1.LiquidityPositionExport.provider":
		panic(fmt.Errorf("field provider of message paw.dex.v1.LiquidityPositionExport is not mutable"))
	case "paw.dex.v1.LiquidityPositionExport.shares":
		panic(fmt.Errorf("field shares of message paw.dex.v1.LiquidityPositionExport is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.LiquidityPositionExport"))
		}
		panic(fmt.Errorf("message paw.dex.v1.LiquidityPositionExport does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_LiquidityPositionExport) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.LiquidityPositionExport.pool_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "paw.dex.v1.LiquidityPositionExport.provider":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.LiquidityPositionExport.shares":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.LiquidityPositionExport"))
		}
		panic(fmt.Errorf("message paw.dex.v1.LiquidityPositionExport does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_LiquidityPositionExport) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in paw.dex.v1.LiquidityPositionExport", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_LiquidityPositionExport) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_LiquidityPositionExport) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_LiquidityPositionExport) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_LiquidityPositionExport) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*LiquidityPositionExport)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.PoolId != 0 {
			n += 1 + runtime.Sov(uint64(x.PoolId))
		}
		l = len(x.Provider)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Shares)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*LiquidityPositionExport)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Shares) > 0 {
			i -= len(x.Shares)
			copy(dAtA[i:], x.Shares)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Shares)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Provider) > 0 {
			i -= len(x.Provider)
			copy(dAtA[i:], x.Provider)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Provider)))
			i--
			dAtA[i] = 0x12
		}
		if x.PoolId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PoolId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*LiquidityPositionExport)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: LiquidityPositionExport: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: LiquidityPositionExport: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
				}
				x.PoolId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PoolId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Provider = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Shares = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_SwapCommit               protoreflect.MessageDescriptor
	fd_SwapCommit_trader        protoreflect.FieldDescriptor
	fd_SwapCommit_swap_hash     protoreflect.FieldDescriptor
	fd_SwapCommit_commit_height protoreflect.FieldDescriptor
	fd_SwapCommit_expiry_height protoreflect.FieldDescriptor
)

func init() {
	file_paw_dex_v1_dex_proto_init()
	md_SwapCommit = File_paw_dex_v1_dex_proto.Messages().ByName("SwapCommit")
	fd_SwapCommit_trader = md_SwapCommit.Fields().ByName("trader")
	fd_SwapCommit_swap_hash = md_SwapCommit.Fields().ByName("swap_hash")
	fd_SwapCommit_commit_height = md_SwapCommit.Fields().ByName("commit_height")
	fd_SwapCommit_expiry_height = md_SwapCommit.Fields().ByName("expiry_height")
}

var _ protoreflect.Message = (*fastReflection_SwapCommit)(nil)

type fastReflection_SwapCommit SwapCommit

func (x *SwapCommit) ProtoReflect() protoreflect.Message {
	return (*fastReflection_SwapCommit)(x)
}

func (x *SwapCommit) slowProtoReflect() protoreflect.Message {
	mi := &file_paw_dex_v1_dex_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_SwapCommit_messageType fastReflection_SwapCommit_messageType
var _ protoreflect.MessageType = fastReflection_SwapCommit_messageType{}

type fastReflection_SwapCommit_messageType struct{}

func (x fastReflection_SwapCommit_messageType) Zero() protoreflect.Message {
	return (*fastReflection_SwapCommit)(nil)
}
func (x fastReflection_SwapCommit_messageType) New() protoreflect.Message {
	return new(fastReflection_SwapCommit)
}
func (x fastReflection_SwapCommit_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_SwapCommit
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_SwapCommit) Descriptor() protoreflect.MessageDescriptor {
	return md_SwapCommit
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_SwapCommit) Type() protoreflect.MessageType {
	return _fastReflection_SwapCommit_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_SwapCommit) New() protoreflect.Message {
	return new(fastReflection_SwapCommit)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_SwapCommit) Interface() protoreflect.ProtoMessage {
	return (*SwapCommit)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_SwapCommit) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Trader != "" {
		value := protoreflect.ValueOfString(x.Trader)
		if !f(fd_SwapCommit_trader, value) {
			return
		}
	}
	if x.SwapHash != "" {
		value := protoreflect.ValueOfString(x.SwapHash)
		if !f(fd_SwapCommit_swap_hash, value) {
			return
		}
	}
	if x.CommitHeight != int64(0) {
		value := protoreflect.ValueOfInt64(x.CommitHeight)
		if !f(fd_SwapCommit_commit_height, value) {
			return
		}
	}
	if x.ExpiryHeight != int64(0) {
		value := protoreflect.ValueOfInt64(x.ExpiryHeight)
		if !f(fd_SwapCommit_expiry_height, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_SwapCommit) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "paw.dex.v1.SwapCommit.trader":
		return x.Trader != ""
	case "paw.dex.v1.SwapCommit.swap_hash":
		return x.SwapHash != ""
	case "paw.dex.v1.SwapCommit.commit_height":
		return x.CommitHeight != int64(0)
	case "paw.dex.v1.SwapCommit.expiry_height":
		return x.ExpiryHeight != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.SwapCommit"))
		}
		panic(fmt.Errorf("message paw.dex.v1.SwapCommit does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SwapCommit) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "paw.dex.v1.SwapCommit.trader":
		x.Trader = ""
	case "paw.dex.v1.SwapCommit.swap_hash":
		x.SwapHash = ""
	case "paw.dex.v1.SwapCommit.commit_height":
		x.CommitHeight = int64(0)
	case "paw.dex.v1.SwapCommit.expiry_height":
		x.ExpiryHeight = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.SwapCommit"))
		}
		panic(fmt.Errorf("message paw.dex.v1.SwapCommit does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_SwapCommit) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "paw.dex.v1.SwapCommit.trader":
		value := x.Trader
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.SwapCommit.swap_hash":
		value := x.SwapHash
		return protoreflect.ValueOfString(value)
	case "paw.dex.v1.SwapCommit.commit_height":
		value := x.CommitHeight
		return protoreflect.ValueOfInt64(value)
	case "paw.dex.v1.SwapCommit.expiry_height":
		value := x.ExpiryHeight
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.SwapCommit"))
		}
		panic(fmt.Errorf("message paw.dex.v1.SwapCommit does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SwapCommit) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "paw.dex.v1.SwapCommit.trader":
		x.Trader = value.Interface().(string)
	case "paw.dex.v1.SwapCommit.swap_hash":
		x.SwapHash = value.Interface().(string)
	case "paw.dex.v1.SwapCommit.commit_height":
		x.CommitHeight = value.Int()
	case "paw.dex.v1.SwapCommit.expiry_height":
		x.ExpiryHeight = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.SwapCommit"))
		}
		panic(fmt.Errorf("message paw.dex.v1.SwapCommit does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SwapCommit) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.SwapCommit.trader":
		panic(fmt.Errorf("field trader of message paw.dex.v1.SwapCommit is not mutable"))
	case "paw.dex.v1.SwapCommit.swap_hash":
		panic(fmt.Errorf("field swap_hash of message paw.dex.v1.SwapCommit is not mutable"))
	case "paw.dex.v1.SwapCommit.commit_height":
		panic(fmt.Errorf("field commit_height of message paw.dex.v1.SwapCommit is not mutable"))
	case "paw.dex.v1.SwapCommit.expiry_height":
		panic(fmt.Errorf("field expiry_height of message paw.dex.v1.SwapCommit is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.SwapCommit"))
		}
		panic(fmt.Errorf("message paw.dex.v1.SwapCommit does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_SwapCommit) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.SwapCommit.trader":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.SwapCommit.swap_hash":
		return protoreflect.ValueOfString("")
	case "paw.dex.v1.SwapCommit.commit_height":
		return protoreflect.ValueOfInt64(int64(0))
	case "paw.dex.v1.SwapCommit.expiry_height":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.SwapCommit"))
		}
		panic(fmt.Errorf("message paw.dex.v1.SwapCommit does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_SwapCommit) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in paw.dex.v1.SwapCommit", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_SwapCommit) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SwapCommit) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_SwapCommit) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_SwapCommit) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*SwapCommit)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Trader)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SwapHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CommitHeight != 0 {
			n += 1 + runtime.Sov(uint64(x.CommitHeight))
		}
		if x.ExpiryHeight != 0 {
			n += 1 + runtime.Sov(uint64(x.ExpiryHeight))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*SwapCommit)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ExpiryHeight != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ExpiryHeight))
			i--
			dAtA[i] = 0x20
		}
		if x.CommitHeight != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.CommitHeight))
			i--
			dAtA[i] = 0x18
		}
		if len(x.SwapHash) > 0 {
			i -= len(x.SwapHash)
			copy(dAtA[i:], x.SwapHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SwapHash)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Trader) > 0 {
			i -= len(x.Trader)
			copy(dAtA[i:], x.Trader)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Trader)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*SwapCommit)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SwapCommit: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SwapCommit: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Trader", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Trader = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SwapHash", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SwapHash = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CommitHeight", wireType)
				}
				x.CommitHeight = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.CommitHeight |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
				}
				x.ExpiryHeight = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ExpiryHeight |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_GenesisState_2_list)(nil)

type _GenesisState_2_list struct {
	list *[]*Pool
}

func (x *_GenesisState_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_GenesisState_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_GenesisState_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Pool)
	(*x.list)[i] = concreteValue
}

func (x *_GenesisState_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Pool)
	*x.list = append(*x.list, concreteValue)
}

func (x *_GenesisState_2_list) AppendMutable() protoreflect.Value {
	v := new(Pool)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GenesisState_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_GenesisState_2_list) NewElement() protoreflect.Value {
	v := new(Pool)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GenesisState_2_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_GenesisState_4_list)(nil)

type _GenesisState_4_list struct {
	list *[]*LimitOrder
}

func (x *_GenesisState_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_GenesisState_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_GenesisState_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*LimitOrder)
	(*x.list)[i] = concreteValue
}

func (x *_GenesisState_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*LimitOrder)
	*x.list = append(*x.list, concreteValue)
}

func (x *_GenesisState_4_list) AppendMutable() protoreflect.Value {
	v := new(LimitOrder)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GenesisState_4_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_GenesisState_4_list) NewElement() protoreflect.Value {
	v := new(LimitOrder)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GenesisState_4_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_GenesisState_6_list)(nil)

type _GenesisState_6_list struct {
	list *[]*PoolTWAP
}

func (x *_GenesisState_6_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_GenesisState_6_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_GenesisState_6_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*PoolTWAP)
	(*x.list)[i] = concreteValue
}

func (x *_GenesisState_6_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*PoolTWAP)
	*x.list = append(*x.list, concreteValue)
}

func (x *_GenesisState_6_list) AppendMutable() protoreflect.Value {
	v := new(PoolTWAP)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GenesisState_6_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_GenesisState_6_list) NewElement() protoreflect.Value {
	v := new(PoolTWAP)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GenesisState_6_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_GenesisState_7_list)(nil)

type _GenesisState_7_list struct {
	list *[]*CircuitBreakerStateExport
}

func (x *_GenesisState_7_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_GenesisState_7_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_GenesisState_7_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*CircuitBreakerStateExport)
	(*x.list)[i] = concreteValue
}

func (x *_GenesisState_7_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*CircuitBreakerStateExport)
	*x.list = append(*x.list, concreteValue)
}

func (x *_GenesisState_7_list) AppendMutable() protoreflect.Value {
	v := new(CircuitBreakerStateExport)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GenesisState_7_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_GenesisState_7_list) NewElement() protoreflect.Value {
	v := new(CircuitBreakerStateExport)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GenesisState_7_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_GenesisState_8_list)(nil)

type _GenesisState_8_list struct {
	list *[]*LiquidityPositionExport
}

func (x *_GenesisState_8_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_GenesisState_8_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_GenesisState_8_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*LiquidityPositionExport)
	(*x.list)[i] = concreteValue
}

func (x *_GenesisState_8_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*LiquidityPositionExport)
	*x.list = append(*x.list, concreteValue)
}

func (x *_GenesisState_8_list) AppendMutable() protoreflect.Value {
	v := new(LiquidityPositionExport)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GenesisState_8_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_GenesisState_8_list) NewElement() protoreflect.Value {
	v := new(LiquidityPositionExport)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GenesisState_8_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_GenesisState_9_list)(nil)

type _GenesisState_9_list struct {
	list *[]*SwapCommit
}

func (x *_GenesisState_9_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_GenesisState_9_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_GenesisState_9_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*SwapCommit)
	(*x.list)[i] = concreteValue
}

func (x *_GenesisState_9_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*SwapCommit)
	*x.list = append(*x.list, concreteValue)
}

func (x *_GenesisState_9_list) AppendMutable() protoreflect.Value {
	v := new(SwapCommit)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GenesisState_9_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_GenesisState_9_list) NewElement() protoreflect.Value {
	v := new(SwapCommit)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_GenesisState_9_list) IsValid() bool {
	return x.list != nil
}

var (
	md_GenesisState                        protoreflect.MessageDescriptor
	fd_GenesisState_params                 protoreflect.FieldDescriptor
	fd_GenesisState_pools                  protoreflect.FieldDescriptor
	fd_GenesisState_next_pool_id           protoreflect.FieldDescriptor
	fd_GenesisState_limit_orders           protoreflect.FieldDescriptor
	fd_GenesisState_next_order_id          protoreflect.FieldDescriptor
	fd_GenesisState_pool_twap_records      protoreflect.FieldDescriptor
	fd_GenesisState_circuit_breaker_states protoreflect.FieldDescriptor
	fd_GenesisState_liquidity_positions    protoreflect.FieldDescriptor
	fd_GenesisState_swap_commits           protoreflect.FieldDescriptor
)

func init() {
	file_paw_dex_v1_dex_proto_init()
	md_GenesisState = File_paw_dex_v1_dex_proto.Messages().ByName("GenesisState")
	fd_GenesisState_params = md_GenesisState.Fields().ByName("params")
	fd_GenesisState_pools = md_GenesisState.Fields().ByName("pools")
	fd_GenesisState_next_pool_id = md_GenesisState.Fields().ByName("next_pool_id")
	fd_GenesisState_limit_orders = md_GenesisState.Fields().ByName("limit_orders")
	fd_GenesisState_next_order_id = md_GenesisState.Fields().ByName("next_order_id")
	fd_GenesisState_pool_twap_records = md_GenesisState.Fields().ByName("pool_twap_records")
	fd_GenesisState_circuit_breaker_states = md_GenesisState.Fields().ByName("circuit_breaker_states")
	fd_GenesisState_liquidity_positions = md_GenesisState.Fields().ByName("liquidity_positions")
	fd_GenesisState_swap_commits = md_GenesisState.Fields().ByName("swap_commits")
}

var _ protoreflect.Message = (*fastReflection_GenesisState)(nil)

type fastReflection_GenesisState GenesisState

func (x *GenesisState) ProtoReflect() protoreflect.Message {
	return (*fastReflection_GenesisState)(x)
}

func (x *GenesisState) slowProtoReflect() protoreflect.Message {
	mi := &file_paw_dex_v1_dex_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_GenesisState_messageType fastReflection_GenesisState_messageType
var _ protoreflect.MessageType = fastReflection_GenesisState_messageType{}

type fastReflection_GenesisState_messageType struct{}

func (x fastReflection_GenesisState_messageType) Zero() protoreflect.Message {
	return (*fastReflection_GenesisState)(nil)
}
func (x fastReflection_GenesisState_messageType) New() protoreflect.Message {
	return new(fastReflection_GenesisState)
}
func (x fastReflection_GenesisState_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_GenesisState
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_GenesisState) Descriptor() protoreflect.MessageDescriptor {
	return md_GenesisState
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_GenesisState) Type() protoreflect.MessageType {
	return _fastReflection_GenesisState_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_GenesisState) New() protoreflect.Message {
	return new(fastReflection_GenesisState)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_GenesisState) Interface() protoreflect.ProtoMessage {
	return (*GenesisState)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_GenesisState) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Params != nil {
		value := protoreflect.ValueOfMessage(x.Params.ProtoReflect())
		if !f(fd_GenesisState_params, value) {
			return
		}
	}
	if len(x.Pools) != 0 {
		value := protoreflect.ValueOfList(&_GenesisState_2_list{list: &x.Pools})
		if !f(fd_GenesisState_pools, value) {
			return
		}
	}
	if x.NextPoolId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.NextPoolId)
		if !f(fd_GenesisState_next_pool_id, value) {
			return
		}
	}
	if len(x.LimitOrders) != 0 {
		value := protoreflect.ValueOfList(&_GenesisState_4_list{list: &x.LimitOrders})
		if !f(fd_GenesisState_limit_orders, value) {
			return
		}
	}
	if x.NextOrderId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.NextOrderId)
		if !f(fd_GenesisState_next_order_id, value) {
			return
		}
	}
	if len(x.PoolTwapRecords) != 0 {
		value := protoreflect.ValueOfList(&_GenesisState_6_list{list: &x.PoolTwapRecords})
		if !f(fd_GenesisState_pool_twap_records, value) {
			return
		}
	}
	if len(x.CircuitBreakerStates) != 0 {
		value := protoreflect.ValueOfList(&_GenesisState_7_list{list: &x.CircuitBreakerStates})
		if !f(fd_GenesisState_circuit_breaker_states, value) {
			return
		}
	}
	if len(x.LiquidityPositions) != 0 {
		value := protoreflect.ValueOfList(&_GenesisState_8_list{list: &x.LiquidityPositions})
		if !f(fd_GenesisState_liquidity_positions, value) {
			return
		}
	}
	if len(x.SwapCommits) != 0 {
		value := protoreflect.ValueOfList(&_GenesisState_9_list{list: &x.SwapCommits})
		if !f(fd_GenesisState_swap_commits, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_GenesisState) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "paw.dex.v1.GenesisState.params":
		return x.Params != nil
	case "paw.dex.v1.GenesisState.pools":
		return len(x.Pools) != 0
	case "paw.dex.v1.GenesisState.next_pool_id":
		return x.NextPoolId != uint64(0)
	case "paw.dex.v1.GenesisState.limit_orders":
		return len(x.LimitOrders) != 0
	case "paw.dex.v1.GenesisState.next_order_id":
		return x.NextOrderId != uint64(0)
	case "paw.dex.v1.GenesisState.pool_twap_records":
		return len(x.PoolTwapRecords) != 0
	case "paw.dex.v1.GenesisState.circuit_breaker_states":
		return len(x.CircuitBreakerStates) != 0
	case "paw.dex.v1.GenesisState.liquidity_positions":
		return len(x.LiquidityPositions) != 0
	case "paw.dex.v1.GenesisState.swap_commits":
		return len(x.SwapCommits) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.GenesisState"))
		}
		panic(fmt.Errorf("message paw.dex.v1.GenesisState does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_GenesisState) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "paw.dex.v1.GenesisState.params":
		x.Params = nil
	case "paw.dex.v1.GenesisState.pools":
		x.Pools = nil
	case "paw.dex.v1.GenesisState.next_pool_id":
		x.NextPoolId = uint64(0)
	case "paw.dex.v1.GenesisState.limit_orders":
		x.LimitOrders = nil
	case "paw.dex.v1.GenesisState.next_order_id":
		x.NextOrderId = uint64(0)
	case "paw.dex.v1.GenesisState.pool_twap_records":
		x.PoolTwapRecords = nil
	case "paw.dex.v1.GenesisState.circuit_breaker_states":
		x.CircuitBreakerStates = nil
	case "paw.dex.v1.GenesisState.liquidity_positions":
		x.LiquidityPositions = nil
	case "paw.dex.v1.GenesisState.swap_commits":
		x.SwapCommits = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.GenesisState"))
		}
		panic(fmt.Errorf("message paw.dex.v1.GenesisState does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_GenesisState) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "paw.dex.v1.GenesisState.params":
		value := x.Params
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "paw.dex.v1.GenesisState.pools":
		if len(x.Pools) == 0 {
			return protoreflect.ValueOfList(&_GenesisState_2_list{})
		}
		listValue := &_GenesisState_2_list{list: &x.Pools}
		return protoreflect.ValueOfList(listValue)
	case "paw.dex.v1.GenesisState.next_pool_id":
		value := x.NextPoolId
		return protoreflect.ValueOfUint64(value)
	case "paw.dex.v1.GenesisState.limit_orders":
		if len(x.LimitOrders) == 0 {
			return protoreflect.ValueOfList(&_GenesisState_4_list{})
		}
		listValue := &_GenesisState_4_list{list: &x.LimitOrders}
		return protoreflect.ValueOfList(listValue)
	case "paw.dex.v1.GenesisState.next_order_id":
		value := x.NextOrderId
		return protoreflect.ValueOfUint64(value)
	case "paw.dex.v1.GenesisState.pool_twap_records":
		if len(x.PoolTwapRecords) == 0 {
			return protoreflect.ValueOfList(&_GenesisState_6_list{})
		}
		listValue := &_GenesisState_6_list{list: &x.PoolTwapRecords}
		return protoreflect.ValueOfList(listValue)
	case "paw.dex.v1.GenesisState.circuit_breaker_states":
		if len(x.CircuitBreakerStates) == 0 {
			return protoreflect.ValueOfList(&_GenesisState_7_list{})
		}
		listValue := &_GenesisState_7_list{list: &x.CircuitBreakerStates}
		return protoreflect.ValueOfList(listValue)
	case "paw.dex.v1.GenesisState.liquidity_positions":
		if len(x.LiquidityPositions) == 0 {
			return protoreflect.ValueOfList(&_GenesisState_8_list{})
		}
		listValue := &_GenesisState_8_list{list: &x.LiquidityPositions}
		return protoreflect.ValueOfList(listValue)
	case "paw.dex.v1.GenesisState.swap_commits":
		if len(x.SwapCommits) == 0 {
			return protoreflect.ValueOfList(&_GenesisState_9_list{})
		}
		listValue := &_GenesisState_9_list{list: &x.SwapCommits}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.GenesisState"))
		}
		panic(fmt.Errorf("message paw.dex.v1.GenesisState does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_GenesisState) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "paw.dex.v1.GenesisState.params":
		x.Params = value.Message().Interface().(*Params)
	case "paw.dex.v1.GenesisState.pools":
		lv := value.List()
		clv := lv.(*_GenesisState_2_list)
		x.Pools = *clv.list
	case "paw.dex.v1.GenesisState.next_pool_id":
		x.NextPoolId = value.Uint()
	case "paw.dex.v1.GenesisState.limit_orders":
		lv := value.List()
		clv := lv.(*_GenesisState_4_list)
		x.LimitOrders = *clv.list
	case "paw.dex.v1.GenesisState.next_order_id":
		x.NextOrderId = value.Uint()
	case "paw.dex.v1.GenesisState.pool_twap_records":
		lv := value.List()
		clv := lv.(*_GenesisState_6_list)
		x.PoolTwapRecords = *clv.list
	case "paw.dex.v1.GenesisState.circuit_breaker_states":
		lv := value.List()
		clv := lv.(*_GenesisState_7_list)
		x.CircuitBreakerStates = *clv.list
	case "paw.dex.v1.GenesisState.liquidity_positions":
		lv := value.List()
		clv := lv.(*_GenesisState_8_list)
		x.LiquidityPositions = *clv.list
	case "paw.dex.v1.GenesisState.swap_commits":
		lv := value.List()
		clv := lv.(*_GenesisState_9_list)
		x.SwapCommits = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.GenesisState"))
		}
		panic(fmt.Errorf("message paw.dex.v1.GenesisState does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_GenesisState) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.GenesisState.params":
		if x.Params == nil {
			x.Params = new(Params)
		}
		return protoreflect.ValueOfMessage(x.Params.ProtoReflect())
	case "paw.dex.v1.GenesisState.pools":
		if x.Pools == nil {
			x.Pools = []*Pool{}
		}
		value := &_GenesisState_2_list{list: &x.Pools}
		return protoreflect.ValueOfList(value)
	case "paw.dex.v1.GenesisState.limit_orders":
		if x.LimitOrders == nil {
			x.LimitOrders = []*LimitOrder{}
		}
		value := &_GenesisState_4_list{list: &x.LimitOrders}
		return protoreflect.ValueOfList(value)
	case "paw.dex.v1.GenesisState.pool_twap_records":
		if x.PoolTwapRecords == nil {
			x.PoolTwapRecords = []*PoolTWAP{}
		}
		value := &_GenesisState_6_list{list: &x.PoolTwapRecords}
		return protoreflect.ValueOfList(value)
	case "paw.dex.v1.GenesisState.circuit_breaker_states":
		if x.CircuitBreakerStates == nil {
			x.CircuitBreakerStates = []*CircuitBreakerStateExport{}
		}
		value := &_GenesisState_7_list{list: &x.CircuitBreakerStates}
		return protoreflect.ValueOfList(value)
	case "paw.dex.v1.GenesisState.liquidity_positions":
		if x.LiquidityPositions == nil {
			x.LiquidityPositions = []*LiquidityPositionExport{}
		}
		value := &_GenesisState_8_list{list: &x.LiquidityPositions}
		return protoreflect.ValueOfList(value)
	case "paw.dex.v1.GenesisState.swap_commits":
		if x.SwapCommits == nil {
			x.SwapCommits = []*SwapCommit{}
		}
		value := &_GenesisState_9_list{list: &x.SwapCommits}
		return protoreflect.ValueOfList(value)
	case "paw.dex.v1.GenesisState.next_pool_id":
		panic(fmt.Errorf("field next_pool_id of message paw.dex.v1.GenesisState is not mutable"))
	case "paw.dex.v1.GenesisState.next_order_id":
		panic(fmt.Errorf("field next_order_id of message paw.dex.v1.GenesisState is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.GenesisState"))
		}
		panic(fmt.Errorf("message paw.dex.v1.GenesisState does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_GenesisState) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "paw.dex.v1.GenesisState.params":
		m := new(Params)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "paw.dex.v1.GenesisState.pools":
		list := []*Pool{}
		return protoreflect.ValueOfList(&_GenesisState_2_list{list: &list})
	case "paw.dex.v1.GenesisState.next_pool_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "paw.dex.v1.GenesisState.limit_orders":
		list := []*LimitOrder{}
		return protoreflect.ValueOfList(&_GenesisState_4_list{list: &list})
	case "paw.dex.v1.GenesisState.next_order_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "paw.dex.v1.GenesisState.pool_twap_records":
		list := []*PoolTWAP{}
		return protoreflect.ValueOfList(&_GenesisState_6_list{list: &list})
	case "paw.dex.v1.GenesisState.circuit_breaker_states":
		list := []*CircuitBreakerStateExport{}
		return protoreflect.ValueOfList(&_GenesisState_7_list{list: &list})
	case "paw.dex.v1.GenesisState.liquidity_positions":
		list := []*LiquidityPositionExport{}
		return protoreflect.ValueOfList(&_GenesisState_8_list{list: &list})
	case "paw.dex.v1.GenesisState.swap_commits":
		list := []*SwapCommit{}
		return protoreflect.ValueOfList(&_GenesisState_9_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: paw.dex.v1.GenesisState"))
		}
		panic(fmt.Errorf("message paw.dex.v1.GenesisState does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_GenesisState) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in paw.dex.v1.GenesisState", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_GenesisState) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_GenesisState) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_GenesisState) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_GenesisState) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*GenesisState)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Params != nil {
			l = options.Size(x.Params)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Pools) > 0 {
			for _, e := range x.Pools {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.NextPoolId != 0 {
			n += 1 + runtime.Sov(uint64(x.NextPoolId))
		}
		if len(x.LimitOrders) > 0 {
			for _, e := range x.LimitOrders {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.NextOrderId != 0 {
			n += 1 + runtime.Sov(uint64(x.NextOrderId))
		}
		if len(x.PoolTwapRecords) > 0 {
			for _, e := range x.PoolTwapRecords {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.CircuitBreakerStates) > 0 {
			for _, e := range x.CircuitBreakerStates {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.LiquidityPositions) > 0 {
			for _, e := range x.LiquidityPositions {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.SwapCommits) > 0 {
			for _, e := range x.SwapCommits {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*GenesisState)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.SwapCommits) > 0 {
			for iNdEx := len(x.SwapCommits) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.SwapCommits[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x4a
			}
		}
		if len(x.LiquidityPositions) > 0 {
			for iNdEx := len(x.LiquidityPositions) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.LiquidityPositions[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x42
			}
		}
		if len(x.CircuitBreakerStates) > 0 {
			for iNdEx := len(x.CircuitBreakerStates) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.CircuitBreakerStates[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x3a
			}
		}
		if len(x.PoolTwapRecords) > 0 {
			for iNdEx := len(x.PoolTwapRecords) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.PoolTwapRecords[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x32
			}
		}
		if x.NextOrderId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.NextOrderId))
			i--
			dAtA[i] = 0x28
		}
		if len(x.LimitOrders) > 0 {
			for iNdEx := len(x.LimitOrders) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.LimitOrders[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x22
			}
		}
		if x.NextPoolId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.NextPoolId))
			i--
			dAtA[i] = 0x18
		}
		if len(x.Pools) > 0 {
			for iNdEx := len(x.Pools) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Pools[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if x.Params != nil {
			encoded, err := options.Marshal(x.Params)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*GenesisState)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Params == nil {
					x.Params = &Params{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Params); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Pools = append(x.Pools, &Pool{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Pools[len(x.Pools)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NextPoolId", wireType)
				}
				x.NextPoolId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.NextPoolId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LimitOrders", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LimitOrders = append(x.LimitOrders, &LimitOrder{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.LimitOrders[len(x.LimitOrders)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NextOrderId", wireType)
				}
				x.NextOrderId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.NextOrderId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolTwapRecords", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PoolTwapRecords = append(x.PoolTwapRecords, &PoolTWAP{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.PoolTwapRecords[len(x.PoolTwapRecords)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CircuitBreakerStates", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CircuitBreakerStates = append(x.CircuitBreakerStates, &CircuitBreakerStateExport{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CircuitBreakerStates[len(x.CircuitBreakerStates)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LiquidityPositions", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LiquidityPositions = append(x.LiquidityPositions, &LiquidityPositionExport{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.LiquidityPositions[len(x.LiquidityPositions)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SwapCommits", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SwapCommits = append(x.SwapCommits, &SwapCommit{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.SwapCommits[len(x.SwapCommits)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: paw/dex/v1/dex.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// OrderType defines whether an order is a buy or sell
type OrderType int32

const (
	OrderType_ORDER_TYPE_UNSPECIFIED OrderType = 0
	OrderType_ORDER_TYPE_BUY         OrderType = 1
	OrderType_ORDER_TYPE_SELL        OrderType = 2
)

// Enum value maps for OrderType.
var (
	OrderType_name = map[int32]string{
		0: "ORDER_TYPE_UNSPECIFIED",
		1: "ORDER_TYPE_BUY",
		2: "ORDER_TYPE_SELL",
	}
	OrderType_value = map[string]int32{
		"ORDER_TYPE_UNSPECIFIED": 0,
		"ORDER_TYPE_BUY":         1,
		"ORDER_TYPE_SELL":        2,
	}
)

func (x OrderType) Enum() *OrderType {
	p := new(OrderType)
	*p = x
	return p
}

func (x OrderType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OrderType) Descriptor() protoreflect.EnumDescriptor {
	return file_paw_dex_v1_dex_proto_enumTypes[0].Descriptor()
}

func (OrderType) Type() protoreflect.EnumType {
	return &file_paw_dex_v1_dex_proto_enumTypes[0]
}

func (x OrderType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OrderType.Descriptor instead.
func (OrderType) EnumDescriptor() ([]byte, []int) {
	return file_paw_dex_v1_dex_proto_rawDescGZIP(), []int{0}
}

// OrderStatus defines the status of a limit order
type OrderStatus int32

const (
	OrderStatus_ORDER_STATUS_UNSPECIFIED      OrderStatus = 0
	OrderStatus_ORDER_STATUS_OPEN             OrderStatus = 1
	OrderStatus_ORDER_STATUS_PARTIALLY_FILLED OrderStatus = 2
	OrderStatus_ORDER_STATUS_FILLED           OrderStatus = 3
	OrderStatus_ORDER_STATUS_CANCELLED        OrderStatus = 4
	OrderStatus_ORDER_STATUS_EXPIRED          OrderStatus = 5
)

// Enum value maps for OrderStatus.
var (
	OrderStatus_name = map[int32]string{
		0: "ORDER_STATUS_UNSPECIFIED",
		1: "ORDER_STATUS_OPEN",
		2: "ORDER_STATUS_PARTIALLY_FILLED",
		3: "ORDER_STATUS_FILLED",
		4: "ORDER_STATUS_CANCELLED",
		5: "ORDER_STATUS_EXPIRED",
	}
	OrderStatus_value = map[string]int32{
		"ORDER_STATUS_UNSPECIFIED":      0,
		"ORDER_STATUS_OPEN":             1,
		"ORDER_STATUS_PARTIALLY_FILLED": 2,
		"ORDER_STATUS_FILLED":           3,
		"ORDER_STATUS_CANCELLED":        4,
		"ORDER_STATUS_EXPIRED":          5,
	}
)

func (x OrderStatus) Enum() *OrderStatus {
	p := new(OrderStatus)
	*p = x
	return p
}

func (x OrderStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OrderStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_paw_dex_v1_dex_proto_enumTypes[1].Descriptor()
}

func (OrderStatus) Type() protoreflect.EnumType {
	return &file_paw_dex_v1_dex_proto_enumTypes[1]
}

func (x OrderStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OrderStatus.Descriptor instead.
func (OrderStatus) EnumDescriptor() ([]byte, []int) {
	return file_paw_dex_v1_dex_proto_rawDescGZIP(), []int{1}
}

// Params defines the parameters for the dex module.
type Params struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// swap_fee is the total swap fee percentage (e.g., 0.003 for 0.3%)
	SwapFee string `protobuf:"bytes,1,opt,name=swap_fee,json=swapFee,proto3" json:"swap_fee,omitempty"`
	// lp_fee is the portion of swap fee that goes to liquidity providers
	LpFee string `protobuf:"bytes,2,opt,name=lp_fee,json=lpFee,proto3" json:"lp_fee,omitempty"`
	// protocol_fee is the portion of swap fee that goes to the protocol treasury
	ProtocolFee string `protobuf:"bytes,3,opt,name=protocol_fee,json=protocolFee,proto3" json:"protocol_fee,omitempty"`
	// min_liquidity is the minimum liquidity required to create a pool
	MinLiquidity string `protobuf:"bytes,4,opt,name=min_liquidity,json=minLiquidity,proto3" json:"min_liquidity,omitempty"`
	// max_slippage_percent is the maximum allowed slippage percentage
	MaxSlippagePercent string `protobuf:"bytes,5,opt,name=max_slippage_percent,json=maxSlippagePercent,proto3" json:"max_slippage_percent,omitempty"`
	// authorized_channels defines which IBC channels are allowed to send packets
	AuthorizedChannels []*AuthorizedChannel `protobuf:"bytes,6,rep,name=authorized_channels,json=authorizedChannels,proto3" json:"authorized_channels,omitempty"`
	// max_pool_drain_percent limits how much of a pool's reserves can be removed in a single swap
	MaxPoolDrainPercent string `protobuf:"bytes,7,opt,name=max_pool_drain_percent,json=maxPoolDrainPercent,proto3" json:"max_pool_drain_percent,omitempty"`
	// flash_loan_protection_blocks enforces a minimum delay between LP add/remove actions
	FlashLoanProtectionBlocks uint64 `protobuf:"varint,8,opt,name=flash_loan_protection_blocks,json=flashLoanProtectionBlocks,proto3" json:"flash_loan_protection_blocks,omitempty"`
	// pool_creation_gas defines the gas consumed by the ante handler when validating MsgCreatePool
	PoolCreationGas uint64 `protobuf:"varint,9,opt,name=pool_creation_gas,json=poolCreationGas,proto3" json:"pool_creation_gas,omitempty"`
	// swap_validation_gas defines the gas consumed when validating MsgSwap
	SwapValidationGas uint64 `protobuf:"varint,10,opt,name=swap_validation_gas,json=swapValidationGas,proto3" json:"swap_validation_gas,omitempty"`
	// liquidity_gas defines the gas consumed when validating liquidity add/remove operations
	LiquidityGas uint64 `protobuf:"varint,11,opt,name=liquidity_gas,json=liquidityGas,proto3" json:"liquidity_gas,omitempty"`
	// upgrade_preserve_circuit_breaker_state controls whether circuit breaker pause state
	// is preserved during chain upgrades (genesis export/import).
	// When true (default), paused pools remain paused after upgrade.
	// When false, all pause states are cleared on upgrade (for intentional reset).
	UpgradePreserveCircuitBreakerState bool `protobuf:"varint,12,opt,name=upgrade_preserve_circuit_breaker_state,json=upgradePreserveCircuitBreakerState,proto3" json:"upgrade_preserve_circuit_breaker_state,omitempty"`
	// recommended_max_slippage is the recommended maximum slippage percentage for UI warnings
	// UIs should warn users when their slippage tolerance exceeds this value
	// This helps protect users from excessive MEV extraction
	// Default: 0.03 (3%)
	RecommendedMaxSlippage string `protobuf:"bytes,13,opt,name=recommended_max_slippage,json=recommendedMaxSlippage,proto3" json:"recommended_max_slippage,omitempty"`
	// enable_commit_reveal enables the commit-reveal MEV protection scheme
	// When enabled, users can use MsgCommitSwap/MsgRevealSwap for MEV-resistant swaps
	// When disabled, only instant swaps (MsgSwap) are allowed
	// Default: false (disabled for testnet, enable for mainnet)
	EnableCommitReveal bool `protobuf:"varint,14,opt,name=enable_commit_reveal,json=enableCommitReveal,proto3" json:"enable_commit_reveal,omitempty"`
	// commit_reveal_delay is the minimum number of blocks between commit and reveal
	// This prevents validators from front-running the reveal based on mempool observation
	// Recommended: 10 blocks (~60 seconds with 6s block time)
	// Default: 10
	CommitRevealDelay uint64 `protobuf:"varint,15,opt,name=commit_reveal_delay,json=commitRevealDelay,proto3" json:"commit_reveal_delay,omitempty"`
	// commit_timeout_blocks is the maximum number of blocks a commit remains valid
	// If not revealed within this period, the commit expires and is pruned
	// Recommended: 100 blocks (~10 minutes)
	// Default: 100
	CommitTimeoutBlocks uint64 `protobuf:"varint,16,opt,name=commit_timeout_blocks,json=commitTimeoutBlocks,proto3" json:"commit_timeout_blocks,omitempty"`
}

func (x *Params) Reset() {
	*x = Params{}
	if protoimpl.UnsafeEnabled {
		mi := &file_paw_dex_v1_dex_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Params) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Params) ProtoMessage() {}

// Deprecated: Use Params.ProtoReflect.Descriptor instead.
func (*Params) Descriptor() ([]byte, []int) {
	return file_paw_dex_v1_dex_proto_rawDescGZIP(), []int{0}
}

func (x *Params) GetSwapFee() string {
	if x != nil {
		return x.SwapFee
	}
	return ""
}

func (x *Params) GetLpFee() string {
	if x != nil {
		return x.LpFee
	}
	return ""
}

func (x *Params) GetProtocolFee() string {
	if x != nil {
		return x.ProtocolFee
	}
	return ""
}

func (x *Params) GetMinLiquidity() string {
	if x != nil {
		return x.MinLiquidity
	}
	return ""
}

func (x *Params) GetMaxSlippagePercent() string {
	if x != nil {
		return x.MaxSlippagePercent
	}
	return ""
}

func (x *Params) GetAuthorizedChannels() []*AuthorizedChannel {
	if x != nil {
		return x.AuthorizedChannels
	}
	return nil
}

func (x *Params) GetMaxPoolDrainPercent() string {
	if x != nil {
		return x.MaxPoolDrainPercent
	}
	return ""
}

func (x *Params) GetFlashLoanProtectionBlocks() uint64 {
	if x != nil {
		return x.FlashLoanProtectionBlocks
	}
	return 0
}

func (x *Params) GetPoolCreationGas() uint64 {
	if x != nil {
		return x.PoolCreationGas
	}
	return 0
}

func (x *Params) GetSwapValidationGas() uint64 {
	if x != nil {
		return x.SwapValidationGas
	}
	return 0
}

func (x *Params) GetLiquidityGas() uint64 {
	if x != nil {
		return x.LiquidityGas
	}
	return 0
}

func (x *Params) GetUpgradePreserveCircuitBreakerState() bool {
	if x != nil {
		return x.UpgradePreserveCircuitBreakerState
	}
	return false
}

func (x *Params) GetRecommendedMaxSlippage() string {
	if x != nil {
		return x.RecommendedMaxSlippage
	}
	return ""
}

func (x *Params) GetEnableCommitReveal() bool {
	if x != nil {
		return x.EnableCommitReveal
	}
	return false
}

func (x *Params) GetCommitRevealDelay() uint64 {
	if x != nil {
		return x.CommitRevealDelay
	}
	return 0
}

func (x *Params) GetCommitTimeoutBlocks() uint64 {
	if x != nil {
		return x.CommitTimeoutBlocks
	}
	return 0
}

// AuthorizedChannel represents a port/channel pair permitted to send packets
type AuthorizedChannel struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PortId    string `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
	ChannelId string `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
}

func (x *AuthorizedChannel) Reset() {
	*x = AuthorizedChannel{}
	if protoimpl.UnsafeEnabled {
		mi := &file_paw_dex_v1_dex_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AuthorizedChannel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthorizedChannel) ProtoMessage() {}

// Deprecated: Use AuthorizedChannel.ProtoReflect.Descriptor instead.
func (*AuthorizedChannel) Descriptor() ([]byte, []int) {
	return file_paw_dex_v1_dex_proto_rawDescGZIP(), []int{1}
}

func (x *AuthorizedChannel) GetPortId() string {
	if x != nil {
		return x.PortId
	}
	return ""
}

func (x *AuthorizedChannel) GetChannelId() string {
	if x != nil {
		return x.ChannelId
	}
	return ""
}

// Pool represents a liquidity pool for token pairs
type Pool struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id          uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TokenA      string `protobuf:"bytes,2,opt,name=token_a,json=tokenA,proto3" json:"token_a,omitempty"`
	TokenB      string `protobuf:"bytes,3,opt,name=token_b,json=tokenB,proto3" json:"token_b,omitempty"`
	ReserveA    string `protobuf:"bytes,4,opt,name=reserve_a,json=reserveA,proto3" json:"reserve_a,omitempty"`
	ReserveB    string `protobuf:"bytes,5,opt,name=reserve_b,json=reserveB,proto3" json:"reserve_b,omitempty"`
	TotalShares string `protobuf:"bytes,6,opt,name=total_shares,json=totalShares,proto3" json:"total_shares,omitempty"`
	Creator     string `protobuf:"bytes,7,opt,name=creator,proto3" json:"creator,omitempty"`
}

func (x *Pool) Reset() {
	*x = Pool{}
	if protoimpl.UnsafeEnabled {
		mi := &file_paw_dex_v1_dex_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Pool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Pool) ProtoMessage() {}

// Deprecated: Use Pool.ProtoReflect.Descriptor instead.
func (*Pool) Descriptor() ([]byte, []int) {
	return file_paw_dex_v1_dex_proto_rawDescGZIP(), []int{2}
}

func (x *Pool) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Pool) GetTokenA() string {
	if x != nil {
		return x.TokenA
	}
	return ""
}

func (x *Pool) GetTokenB() string {
	if x != nil {
		return x.TokenB
	}
	return ""
}

func (x *Pool) GetReserveA() string {
	if x != nil {
		return x.ReserveA
	}
	return ""
}

func (x *Pool) GetReserveB() string {
	if x != nil {
		return x.ReserveB
	}
	return ""
}

func (x *Pool) GetTotalShares() string {
	if x != nil {
		return x.TotalShares
	}
	return ""
}

func (x *Pool) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

// PoolTWAP tracks TWAP metadata per pool
type PoolTWAP struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PoolId          uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	LastPrice       string `protobuf:"bytes,2,opt,name=last_price,json=lastPrice,proto3" json:"last_price,omitempty"`
	CumulativePrice string `protobuf:"bytes,3,opt,name=cumulative_price,json=cumulativePrice,proto3" json:"cumulative_price,omitempty"`
	TotalSeconds    uint64 `protobuf:"varint,4,opt,name=total_seconds,json=totalSeconds,proto3" json:"total_seconds,omitempty"`
	LastTimestamp   int64  `protobuf:"varint,5,opt,name=last_timestamp,json=lastTimestamp,proto3" json:"last_timestamp,omitempty"`
	TwapPrice       string `protobuf:"bytes,6,opt,name=twap_price,json=twapPrice,proto3" json:"twap_price,omitempty"`
}

func (x *PoolTWAP) Reset() {
	*x = PoolTWAP{}
	if protoimpl.UnsafeEnabled {
		mi := &file_paw_dex_v1_dex_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PoolTWAP) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PoolTWAP) ProtoMessage() {}

// Deprecated: Use PoolTWAP.ProtoReflect.Descriptor instead.
func (*PoolTWAP) Descriptor() ([]byte, []int) {
	return file_paw_dex_v1_dex_proto_rawDescGZIP(), []int{3}
}

func (x *PoolTWAP) GetPoolId() uint64 {
	if x != nil {
		return x.PoolId
	}
	return 0
}

func (x *PoolTWAP) GetLastPrice() string {
	if x != nil {
		return x.LastPrice
	}
	return ""
}

func (x *PoolTWAP) GetCumulativePrice() string {
	if x != nil {
		return x.CumulativePrice
	}
	return ""
}

func (x *PoolTWAP) GetTotalSeconds() uint64 {
	if x != nil {
		return x.TotalSeconds
	}
	return 0
}

func (x *PoolTWAP) GetLastTimestamp() int64 {
	if x != nil {
		return x.LastTimestamp
	}
	return 0
}

func (x *PoolTWAP) GetTwapPrice() string {
	if x != nil {
		return x.TwapPrice
	}
	return ""
}

// LimitOrder represents a limit order in the order book
type LimitOrder struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id              uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Owner           string      `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	PoolId          uint64      `protobuf:"varint,3,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	OrderType       OrderType   `protobuf:"varint,4,opt,name=order_type,json=orderType,proto3,enum=paw.dex.v1.OrderType" json:"order_type,omitempty"`
	TokenIn         string      `protobuf:"bytes,5,opt,name=token_in,json=tokenIn,proto3" json:"token_in,omitempty"`
	TokenOut        string      `protobuf:"bytes,6,opt,name=token_out,json=tokenOut,proto3" json:"token_out,omitempty"`
	AmountIn        string      `protobuf:"bytes,7,opt,name=amount_in,json=amountIn,proto3" json:"amount_in,omitempty"`
	MinAmountOut    string      `protobuf:"bytes,8,opt,name=min_amount_out,json=minAmountOut,proto3" json:"min_amount_out,omitempty"`
	LimitPrice      string      `protobuf:"bytes,9,opt,name=limit_price,json=limitPrice,proto3" json:"limit_price,omitempty"`
	FilledAmount    string      `protobuf:"bytes,10,opt,name=filled_amount,json=filledAmount,proto3" json:"filled_amount,omitempty"`
	ReceivedAmount  string      `protobuf:"bytes,11,opt,name=received_amount,json=receivedAmount,proto3" json:"received_amount,omitempty"`
	Status          OrderStatus `protobuf:"varint,12,opt,name=status,proto3,enum=paw.dex.v1.OrderStatus" json:"status,omitempty"`
	CreatedAt       int64       `protobuf:"varint,13,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	ExpiresAt       int64       `protobuf:"varint,14,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	CreatedAtHeight int64       `protobuf:"varint,15,opt,name=created_at_height,json=createdAtHeight,proto3" json:"created_at_height,omitempty"`
}

func (x *LimitOrder) Reset() {
	*x = LimitOrder{}
	if protoimpl.UnsafeEnabled {
		mi := &file_paw_dex_v1_dex_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LimitOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LimitOrder) ProtoMessage() {}

// Deprecated: Use LimitOrder.ProtoReflect.Descriptor instead.
func (*LimitOrder) Descriptor() ([]byte, []int) {
	return file_paw_dex_v1_dex_proto_rawDescGZIP(), []int{4}
}

func (x *LimitOrder) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *LimitOrder) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *LimitOrder) GetPoolId() uint64 {
	if x != nil {
		return x.PoolId
	}
	return 0
}

func (x *LimitOrder) GetOrderType() OrderType {
	if x != nil {
		return x.OrderType
	}
	return OrderType_ORDER_TYPE_UNSPECIFIED
}

func (x *LimitOrder) GetTokenIn() string {
	if x != nil {
		return x.TokenIn
	}
	return ""
}

func (x *LimitOrder) GetTokenOut() string {
	if x != nil {
		return x.TokenOut
	}
	return ""
}

func (x *LimitOrder) GetAmountIn() string {
	if x != nil {
		return x.AmountIn
	}
	return ""
}

func (x *LimitOrder) GetMinAmountOut() string {
	if x != nil {
		return x.MinAmountOut
	}
	return ""
}

func (x *LimitOrder) GetLimitPrice() string {
	if x != nil {
		return x.LimitPrice
	}
	return ""
}

func (x *LimitOrder) GetFilledAmount() string {
	if x != nil {
		return x.FilledAmount
	}
	return ""
}

func (x *LimitOrder) GetReceivedAmount() string {
	if x != nil {
		return x.ReceivedAmount
	}
	return ""
}

func (x *LimitOrder) GetStatus() OrderStatus {
	if x != nil {
		return x.Status
	}
	return OrderStatus_ORDER_STATUS_UNSPECIFIED
}

func (x *LimitOrder) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *LimitOrder) GetExpiresAt() int64 {
	if x != nil {
		return x.ExpiresAt
	}
	return 0
}

func (x *LimitOrder) GetCreatedAtHeight() int64 {
	if x != nil {
		return x.CreatedAtHeight
	}
	return 0
}

// CircuitBreakerStateExport represents circuit breaker state for genesis export
type CircuitBreakerStateExport struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PoolId            uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	Enabled           bool   `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	PausedUntil       int64  `protobuf:"varint,3,opt,name=paused_until,json=pausedUntil,proto3" json:"paused_until,omitempty"` // Unix timestamp
	LastPrice         string `protobuf:"bytes,4,opt,name=last_price,json=lastPrice,proto3" json:"last_price,omitempty"`
	TriggeredBy       string `protobuf:"bytes,5,opt,name=triggered_by,json=triggeredBy,proto3" json:"triggered_by,omitempty"`
	TriggerReason     string `protobuf:"bytes,6,opt,name=trigger_reason,json=triggerReason,proto3" json:"trigger_reason,omitempty"`
	NotificationsSent int32  `protobuf:"varint,7,opt,name=notifications_sent,json=notificationsSent,proto3" json:"notifications_sent,omitempty"`
	LastNotification  int64  `protobuf:"varint,8,opt,name=last_notification,json=lastNotification,proto3" json:"last_notification,omitempty"` // Unix timestamp
	PersistenceKey    string `protobuf:"bytes,9,opt,name=persistence_key,json=persistenceKey,proto3" json:"persistence_key,omitempty"`
}

func (x *CircuitBreakerStateExport) Reset() {
	*x = CircuitBreakerStateExport{}
	if protoimpl.UnsafeEnabled {
		mi := &file_paw_dex_v1_dex_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CircuitBreakerStateExport) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CircuitBreakerStateExport) ProtoMessage() {}

// Deprecated: Use CircuitBreakerStateExport.ProtoReflect.Descriptor instead.
func (*CircuitBreakerStateExport) Descriptor() ([]byte, []int) {
	return file_paw_dex_v1_dex_proto_rawDescGZIP(), []int{5}
}

func (x *CircuitBreakerStateExport) GetPoolId() uint64 {
	if x != nil {
		return x.PoolId
	}
	return 0
}

func (x *CircuitBreakerStateExport) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *CircuitBreakerStateExport) GetPausedUntil() int64 {
	if x != nil {
		return x.PausedUntil
	}
	return 0
}

func (x *CircuitBreakerStateExport) GetLastPrice() string {
	if x != nil {
		return x.LastPrice
	}
	return ""
}

func (x *CircuitBreakerStateExport) GetTriggeredBy() string {
	if x != nil {
		return x.TriggeredBy
	}
	return ""
}

func (x *CircuitBreakerStateExport) GetTriggerReason() string {
	if x != nil {
		return x.TriggerReason
	}
	return ""
}

func (x *CircuitBreakerStateExport) GetNotificationsSent() int32 {
	if x != nil {
		return x.NotificationsSent
	}
	return 0
}

func (x *CircuitBreakerStateExport) GetLastNotification() int64 {
	if x != nil {
		return x.LastNotification
	}
	return 0
}

func (x *CircuitBreakerStateExport) GetPersistenceKey() string {
	if x != nil {
		return x.PersistenceKey
	}
	return ""
}

// LiquidityPositionExport represents a liquidity position for genesis export
type LiquidityPositionExport struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PoolId   uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	Provider string `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"`
	Shares   string `protobuf:"bytes,3,opt,name=shares,proto3" json:"shares,omitempty"`
}

func (x *LiquidityPositionExport) Reset() {
	*x = LiquidityPositionExport{}
	if protoimpl.UnsafeEnabled {
		mi := &file_paw_dex_v1_dex_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LiquidityPositionExport) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LiquidityPositionExport) ProtoMessage() {}

// Deprecated: Use LiquidityPositionExport.ProtoReflect.Descriptor instead.
func (*LiquidityPositionExport) Descriptor() ([]byte, []int) {
	return file_paw_dex_v1_dex_proto_rawDescGZIP(), []int{6}
}

func (x *LiquidityPositionExport) GetPoolId() uint64 {
	if x != nil {
		return x.PoolId
	}
	return 0
}

func (x *LiquidityPositionExport) GetProvider() string {
	if x != nil {
		return x.Provider
	}
	return ""
}

func (x *LiquidityPositionExport) GetShares() string {
	if x != nil {
		return x.Shares
	}
	return ""
}

// SwapCommit represents a committed swap in the commit-reveal scheme
type SwapCommit struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Trader       string `protobuf:"bytes,1,opt,name=trader,proto3" json:"trader,omitempty"`
	SwapHash     string `protobuf:"bytes,2,opt,name=swap_hash,json=swapHash,proto3" json:"swap_hash,omitempty"`
	CommitHeight int64  `protobuf:"varint,3,opt,name=commit_height,json=commitHeight,proto3" json:"commit_height,omitempty"`
	ExpiryHeight int64  `protobuf:"varint,4,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height,omitempty"`
}

func (x *SwapCommit) Reset() {
	*x = SwapCommit{}
	if protoimpl.UnsafeEnabled {
		mi := &file_paw_dex_v1_dex_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SwapCommit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwapCommit) ProtoMessage() {}

// Deprecated: Use SwapCommit.ProtoReflect.Descriptor instead.
func (*SwapCommit) Descriptor() ([]byte, []int) {
	return file_paw_dex_v1_dex_proto_rawDescGZIP(), []int{7}
}

func (x *SwapCommit) GetTrader() string {
	if x != nil {
		return x.Trader
	}
	return ""
}

func (x *SwapCommit) GetSwapHash() string {
	if x != nil {
		return x.SwapHash
	}
	return ""
}

func (x *SwapCommit) GetCommitHeight() int64 {
	if x != nil {
		return x.CommitHeight
	}
	return 0
}

func (x *SwapCommit) GetExpiryHeight() int64 {
	if x != nil {
		return x.ExpiryHeight
	}
	return 0
}

// GenesisState defines the dex module's genesis state.
type GenesisState struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Params               *Params                      `protobuf:"bytes,1,opt,name=params,proto3" json:"params,omitempty"`
	Pools                []*Pool                      `protobuf:"bytes,2,rep,name=pools,proto3" json:"pools,omitempty"`
	NextPoolId           uint64                       `protobuf:"varint,3,opt,name=next_pool_id,json=nextPoolId,proto3" json:"next_pool_id,omitempty"`
	LimitOrders          []*LimitOrder                `protobuf:"bytes,4,rep,name=limit_orders,json=limitOrders,proto3" json:"limit_orders,omitempty"`
	NextOrderId          uint64                       `protobuf:"varint,5,opt,name=next_order_id,json=nextOrderId,proto3" json:"next_order_id,omitempty"`
	PoolTwapRecords      []*PoolTWAP                  `protobuf:"bytes,6,rep,name=pool_twap_records,json=poolTwapRecords,proto3" json:"pool_twap_records,omitempty"`
	CircuitBreakerStates []*CircuitBreakerStateExport `protobuf:"bytes,7,rep,name=circuit_breaker_states,json=circuitBreakerStates,proto3" json:"circuit_breaker_states,omitempty"`
	LiquidityPositions   []*LiquidityPositionExport   `protobuf:"bytes,8,rep,name=liquidity_positions,json=liquidityPositions,proto3" json:"liquidity_positions,omitempty"`
	SwapCommits          []*SwapCommit                `protobuf:"bytes,9,rep,name=swap_commits,json=swapCommits,proto3" json:"swap_commits,omitempty"`
}

func (x *GenesisState) Reset() {
	*x = GenesisState{}
	if protoimpl.UnsafeEnabled {
		mi := &file_paw_dex_v1_dex_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GenesisState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GenesisState) ProtoMessage() {}

// Deprecated: Use GenesisState.ProtoReflect.Descriptor instead.
func (*GenesisState) Descriptor() ([]byte, []int) {
	return file_paw_dex_v1_dex_proto_rawDescGZIP(), []int{8}
}

func (x *GenesisState) GetParams() *Params {
	if x != nil {
		return x.Params
	}
	return nil
}

func (x *GenesisState) GetPools() []*Pool {
	if x != nil {
		return x.Pools
	}
	return nil
}

func (x *GenesisState) GetNextPoolId() uint64 {
	if x != nil {
		return x.NextPoolId
	}
	return 0
}

func (x *GenesisState) GetLimitOrders() []*LimitOrder {
	if x != nil {
		return x.LimitOrders
	}
	return nil
}

func (x *GenesisState) GetNextOrderId() uint64 {
	if x != nil {
		return x.NextOrderId
	}
	return 0
}

func (x *GenesisState) GetPoolTwapRecords() []*PoolTWAP {
	if x != nil {
		return x.PoolTwapRecords
	}
	return nil
}

func (x *GenesisState) GetCircuitBreakerStates() []*CircuitBreakerStateExport {
	if x != nil {
		return x.CircuitBreakerStates
	}
	return nil
}

func (x *GenesisState) GetLiquidityPositions() []*LiquidityPositionExport {
	if x != nil {
		return x.LiquidityPositions
	}
	return nil
}

func (x *GenesisState) GetSwapCommits() []*SwapCommit {
	if x != nil {
		return x.SwapCommits
	}
	return nil
}

var File_paw_dex_v1_dex_proto protoreflect.FileDescriptor

var file_paw_dex_v1_dex_proto_rawDesc = []byte{
	0x0a, 0x14, 0x70, 0x61, 0x77, 0x2f, 0x64, 0x65, 0x78, 0x2f, 0x76, 0x31, 0x2f, 0x64, 0x65, 0x78,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x70, 0x61, 0x77, 0x2e, 0x64, 0x65, 0x78, 0x2e,
	0x76, 0x31, 0x1a, 0x14, 0x67, 0x6f, 0x67, 0x6f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f,
	0x67, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x22, 0x84, 0x09, 0x0a, 0x06, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x12, 0x4c,
	0x0a, 0x08, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x66, 0x65, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x31, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61,
	0x63, 0x79, 0x44, 0x65, 0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e,
	0x44, 0x65, 0x63, 0x52, 0x07, 0x73, 0x77, 0x61, 0x70, 0x46, 0x65, 0x65, 0x12, 0x48, 0x0a, 0x06,
	0x6c, 0x70, 0x5f, 0x66, 0x65, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x31, 0xc8, 0xde,
	0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e,
	0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x65,
	0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63, 0x52,
	0x05, 0x6c, 0x70, 0x46, 0x65, 0x65, 0x12, 0x54, 0x0a, 0x0c, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
	0x6f, 0x6c, 0x5f, 0x66, 0x65, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x31, 0xc8, 0xde,
	0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e,
	0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x65,
	0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63, 0x52,
	0x0b, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x46, 0x65, 0x65, 0x12, 0x50, 0x0a, 0x0d,
	0x6d, 0x69, 0x6e, 0x5f, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69, 0x74, 0x79, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x2b, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49,
	0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74,
	0x52, 0x0c, 0x6d, 0x69, 0x6e, 0x4c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69, 0x74, 0x79, 0x12, 0x63,
	0x0a, 0x14, 0x6d, 0x61, 0x78, 0x5f, 0x73, 0x6c, 0x69, 0x70, 0x70, 0x61, 0x67, 0x65, 0x5f, 0x70,
	0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x31, 0xc8, 0xde,
	0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e,
	0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x65,
	0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63, 0x52,
	0x12, 0x6d, 0x61, 0x78, 0x53, 0x6c, 0x69, 0x70, 0x70, 0x61, 0x67, 0x65, 0x50, 0x65, 0x72, 0x63,
	0x65, 0x6e, 0x74, 0x12, 0x54, 0x0a, 0x13, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65,
	0x64, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x1d, 0x2e, 0x70, 0x61, 0x77, 0x2e, 0x64, 0x65, 0x78, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x75,
	0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65, 0x64, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x42,
	0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x12, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65,
	0x64, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x12, 0x66, 0x0a, 0x16, 0x6d, 0x61, 0x78,
	0x5f, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x64, 0x72, 0x61, 0x69, 0x6e, 0x5f, 0x70, 0x65, 0x72, 0x63,
	0x65, 0x6e, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x42, 0x31, 0xc8, 0xde, 0x1f, 0x00, 0xda,
	0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f,
	0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x65, 0x63, 0xd2, 0xb4,
	0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63, 0x52, 0x13, 0x6d, 0x61,
	0x78, 0x50, 0x6f, 0x6f, 0x6c, 0x44, 0x72, 0x61, 0x69, 0x6e, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e,
	0x74, 0x12, 0x3f, 0x0a, 0x1c, 0x66, 0x6c, 0x61, 0x73, 0x68, 0x5f, 0x6c, 0x6f, 0x61, 0x6e, 0x5f,
	0x70, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b,
	0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x19, 0x66, 0x6c, 0x61, 0x73, 0x68, 0x4c, 0x6f,
	0x61, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x6c, 0x6f, 0x63,
	0x6b, 0x73, 0x12, 0x2a, 0x0a, 0x11, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x5f, 0x67, 0x61, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0f, 0x70,
	0x6f, 0x6f, 0x6c, 0x43, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x47, 0x61, 0x73, 0x12, 0x2e,
	0x0a, 0x13, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x5f, 0x67, 0x61, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x52, 0x11, 0x73, 0x77, 0x61,
	0x70, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x47, 0x61, 0x73, 0x12, 0x23,
	0x0a, 0x0d, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69, 0x74, 0x79, 0x5f, 0x67, 0x61, 0x73, 0x18,
	0x0b, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0c, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69, 0x74, 0x79,
	0x47, 0x61, 0x73, 0x12, 0x52, 0x0a, 0x26, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x5f, 0x70,
	0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x5f, 0x63, 0x69, 0x72, 0x63, 0x75, 0x69, 0x74, 0x5f,
	0x62, 0x72, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x0c, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x22, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x50, 0x72, 0x65, 0x73,
	0x65, 0x72, 0x76, 0x65, 0x43, 0x69, 0x72, 0x63, 0x75, 0x69, 0x74, 0x42, 0x72, 0x65, 0x61, 0x6b,
	0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x6b, 0x0a, 0x18, 0x72, 0x65, 0x63, 0x6f, 0x6d,
	0x6d, 0x65, 0x6e, 0x64, 0x65, 0x64, 0x5f, 0x6d, 0x61, 0x78, 0x5f, 0x73, 0x6c, 0x69, 0x70, 0x70,
	0x61, 0x67, 0x65, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x42, 0x31, 0xc8, 0xde, 0x1f, 0x00, 0xda,
	0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f,
	0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x65, 0x63, 0xd2, 0xb4,
	0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63, 0x52, 0x16, 0x72, 0x65,
	0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x64, 0x65, 0x64, 0x4d, 0x61, 0x78, 0x53, 0x6c, 0x69, 0x70,
	0x70, 0x61, 0x67, 0x65, 0x12, 0x30, 0x0a, 0x14, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x63,
	0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x5f, 0x72, 0x65, 0x76, 0x65, 0x61, 0x6c, 0x18, 0x0e, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x12, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74,
	0x52, 0x65, 0x76, 0x65, 0x61, 0x6c, 0x12, 0x2e, 0x0a, 0x13, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74,
	0x5f, 0x72, 0x65, 0x76, 0x65, 0x61, 0x6c, 0x5f, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x18, 0x0f, 0x20,
	0x01, 0x28, 0x04, 0x52, 0x11, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x52, 0x65, 0x76, 0x65, 0x61,
	0x6c, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x12, 0x32, 0x0a, 0x15, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74,
	0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x18,
	0x10, 0x20, 0x01, 0x28, 0x04, 0x52, 0x13, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x54, 0x69, 0x6d,
	0x65, 0x6f, 0x75, 0x74, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x22, 0x51, 0x0a, 0x11, 0x41, 0x75,
	0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65, 0x64, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x12,
	0x17, 0x0a, 0x07, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x06, 0x70, 0x6f, 0x72, 0x74, 0x49, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x68, 0x61, 0x6e,
	0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x63, 0x68,
	0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x49, 0x64, 0x3a, 0x04, 0xe8, 0xa0, 0x1f, 0x01, 0x22, 0xe0, 0x02,
	0x0a, 0x04, 0x50, 0x6f, 0x6f, 0x6c, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x02, 0x69, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f,
	0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x41, 0x12,
	0x17, 0x0a, 0x07, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x62, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x06, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x42, 0x12, 0x48, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x65,
	0x72, 0x76, 0x65, 0x5f, 0x61, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x2b, 0xc8, 0xde, 0x1f,
	0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69,
	0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x08, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76,
	0x65, 0x41, 0x12, 0x48, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x5f, 0x62, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x2b, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68,
	0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49,
	0x6e, 0x74, 0x52, 0x08, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x42, 0x12, 0x4e, 0x0a, 0x0c,
	0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x68, 0x61, 0x72, 0x65, 0x73, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x2b, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e,
	0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0x52,
	0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x68, 0x61, 0x72, 0x65, 0x73, 0x12, 0x32, 0x0a, 0x07,
	0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2,
	0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72,
	0x22, 0xf1, 0x02, 0x0a, 0x08, 0x50, 0x6f, 0x6f, 0x6c, 0x54, 0x57, 0x41, 0x50, 0x12, 0x17, 0x0a,
	0x07, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06,
	0x70, 0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x12, 0x50, 0x0a, 0x0a, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x70,
	0x72, 0x69, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x31, 0xc8, 0xde, 0x1f, 0x00,
	0xda, 0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f,
	0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x65, 0x63, 0xd2,
	0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63, 0x52, 0x09, 0x6c,
	0x61, 0x73, 0x74, 0x50, 0x72, 0x69, 0x63, 0x65, 0x12, 0x5c, 0x0a, 0x10, 0x63, 0x75, 0x6d, 0x75,
	0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x70, 0x72, 0x69, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x31, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65,
	0x67, 0x61, 0x63, 0x79, 0x44, 0x65, 0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x44, 0x65, 0x63, 0x52, 0x0f, 0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x76,
	0x65, 0x50, 0x72, 0x69, 0x63, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f,
	0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0c, 0x74,
	0x6f, 0x74, 0x61, 0x6c, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x6c,
	0x61, 0x73, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x03, 0x52, 0x0d, 0x6c, 0x61, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
	0x6d, 0x70, 0x12, 0x50, 0x0a, 0x0a, 0x74, 0x77, 0x61, 0x70, 0x5f, 0x70, 0x72, 0x69, 0x63, 0x65,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x42, 0x31, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74,
	0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x65, 0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63, 0x52, 0x09, 0x74, 0x77, 0x61, 0x70, 0x50,
	0x72, 0x69, 0x63, 0x65, 0x22, 0x87, 0x06, 0x0a, 0x0a, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x4f, 0x72,
	0x64, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x02, 0x69, 0x64, 0x12, 0x2e, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x05, 0x6f, 0x77,
	0x6e, 0x65, 0x72, 0x12, 0x17, 0x0a, 0x07, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x70, 0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x12, 0x34, 0x0a, 0x0a,
	0x6f, 0x72, 0x64, 0x65, 0x72, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x15, 0x2e, 0x70, 0x61, 0x77, 0x2e, 0x64, 0x65, 0x78, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x72,
	0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x52, 0x09, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x69, 0x6e, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x49, 0x6e, 0x12, 0x1b, 0x0a,
	0x09, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x6f, 0x75, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x4f, 0x75, 0x74, 0x12, 0x48, 0x0a, 0x09, 0x61, 0x6d,
	0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x42, 0x2b, 0xc8,
	0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b,
	0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x08, 0x61, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x49, 0x6e, 0x12, 0x51, 0x0a, 0x0e, 0x6d, 0x69, 0x6e, 0x5f, 0x61, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x5f, 0x6f, 0x75, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x42, 0x2b, 0xc8, 0xde,
	0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e,
	0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x0c, 0x6d, 0x69, 0x6e, 0x41, 0x6d,
	0x6f, 0x75, 0x6e, 0x74, 0x4f, 0x75, 0x74, 0x12, 0x52, 0x0a, 0x0b, 0x6c, 0x69, 0x6d, 0x69, 0x74,
	0x5f, 0x70, 0x72, 0x69, 0x63, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x42, 0x31, 0xc8, 0xde,
	0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e,
	0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x65,
	0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63, 0x52,
	0x0a, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x50, 0x72, 0x69, 0x63, 0x65, 0x12, 0x50, 0x0a, 0x0d, 0x66,
	0x69, 0x6c, 0x6c, 0x65, 0x64, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x0a, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x2b, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e,
	0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0x52,
	0x0c, 0x66, 0x69, 0x6c, 0x6c, 0x65, 0x64, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x54, 0x0a,
	0x0f, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74,
	0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x42, 0x2b, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74,
	0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e,
	0x49, 0x6e, 0x74, 0x52, 0x0e, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x41, 0x6d, 0x6f,
	0x75, 0x6e, 0x74, 0x12, 0x2f, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x0c, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x17, 0x2e, 0x70, 0x61, 0x77, 0x2e, 0x64, 0x65, 0x78, 0x2e, 0x76, 0x31,
	0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f,
	0x61, 0x74, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x64, 0x41, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x5f, 0x61,
	0x74, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73,
	0x41, 0x74, 0x12, 0x2a, 0x0a, 0x11, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74,
	0x5f, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0f, 0x63,
	0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74, 0x22, 0x92,
	0x03, 0x0a, 0x19, 0x43, 0x69, 0x72, 0x63, 0x75, 0x69, 0x74, 0x42, 0x72, 0x65, 0x61, 0x6b, 0x65,
	0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x45, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x17, 0x0a, 0x07,
	0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x70,
	0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12,
	0x21, 0x0a, 0x0c, 0x70, 0x61, 0x75, 0x73, 0x65, 0x64, 0x5f, 0x75, 0x6e, 0x74, 0x69, 0x6c, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x70, 0x61, 0x75, 0x73, 0x65, 0x64, 0x55, 0x6e, 0x74,
	0x69, 0x6c, 0x12, 0x50, 0x0a, 0x0a, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x70, 0x72, 0x69, 0x63, 0x65,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x31, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74,
	0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x65, 0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63, 0x52, 0x09, 0x6c, 0x61, 0x73, 0x74, 0x50,
	0x72, 0x69, 0x63, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x74, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x65,
	0x64, 0x5f, 0x62, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x74, 0x72, 0x69, 0x67,
	0x67, 0x65, 0x72, 0x65, 0x64, 0x42, 0x79, 0x12, 0x25, 0x0a, 0x0e, 0x74, 0x72, 0x69, 0x67, 0x67,
	0x65, 0x72, 0x5f, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0d, 0x74, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x12, 0x2d,
	0x0a, 0x12, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f,
	0x73, 0x65, 0x6e, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x11, 0x6e, 0x6f, 0x74, 0x69,
	0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x53, 0x65, 0x6e, 0x74, 0x12, 0x2b, 0x0a,
	0x11, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x03, 0x52, 0x10, 0x6c, 0x61, 0x73, 0x74, 0x4e, 0x6f,
	0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x27, 0x0a, 0x0f, 0x70, 0x65,
	0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x09, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0e, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65,
	0x4b, 0x65, 0x79, 0x22, 0xad, 0x01, 0x0a, 0x17, 0x4c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69, 0x74,
	0x79, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x12,
	0x17, 0x0a, 0x07, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04,
	0x52, 0x06, 0x70, 0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x12, 0x34, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x76,
	0x69, 0x64, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74,
	0x72, 0x69, 0x6e, 0x67, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x43,
	0x0a, 0x06, 0x73, 0x68, 0x61, 0x72, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x2b,
	0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64,
	0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d,
	0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x06, 0x73, 0x68, 0x61,
	0x72, 0x65, 0x73, 0x22, 0xa5, 0x01, 0x0a, 0x0a, 0x53, 0x77, 0x61, 0x70, 0x43, 0x6f, 0x6d, 0x6d,
	0x69, 0x74, 0x12, 0x30, 0x0a, 0x06, 0x74, 0x72, 0x61, 0x64, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x06, 0x74, 0x72,
	0x61, 0x64, 0x65, 0x72, 0x12, 0x1b, 0x0a, 0x09, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x68, 0x61, 0x73,
	0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x73, 0x77, 0x61, 0x70, 0x48, 0x61, 0x73,
	0x68, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x5f, 0x68, 0x65, 0x69, 0x67,
	0x68, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0c, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74,
	0x48, 0x65, 0x69, 0x67, 0x68, 0x74, 0x12, 0x23, 0x0a, 0x0d, 0x65, 0x78, 0x70, 0x69, 0x72, 0x79,
	0x5f, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0c, 0x65,
	0x78, 0x70, 0x69, 0x72, 0x79, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74, 0x22, 0xbd, 0x04, 0x0a, 0x0c,
	0x47, 0x65, 0x6e, 0x65, 0x73, 0x69, 0x73, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x30, 0x0a, 0x06,
	0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x70,
	0x61, 0x77, 0x2e, 0x64, 0x65, 0x78, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73,
	0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x06, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x12, 0x2c,
	0x0a, 0x05, 0x70, 0x6f, 0x6f, 0x6c, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x10, 0x2e,
	0x70, 0x61, 0x77, 0x2e, 0x64, 0x65, 0x78, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x6f, 0x6f, 0x6c, 0x42,
	0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x05, 0x70, 0x6f, 0x6f, 0x6c, 0x73, 0x12, 0x20, 0x0a, 0x0c,
	0x6e, 0x65, 0x78, 0x74, 0x5f, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x0a, 0x6e, 0x65, 0x78, 0x74, 0x50, 0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x12, 0x3f,
	0x0a, 0x0c, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x18, 0x04,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x70, 0x61, 0x77, 0x2e, 0x64, 0x65, 0x78, 0x2e, 0x76,
	0x31, 0x2e, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x42, 0x04, 0xc8, 0xde,
	0x1f, 0x00, 0x52, 0x0b, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x73, 0x12,
	0x22, 0x0a, 0x0d, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x5f, 0x69, 0x64,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x6e, 0x65, 0x78, 0x74, 0x4f, 0x72, 0x64, 0x65,
	0x72, 0x49, 0x64, 0x12, 0x46, 0x0a, 0x11, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x74, 0x77, 0x61, 0x70,
	0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14,
	0x2e, 0x70, 0x61, 0x77, 0x2e, 0x64, 0x65, 0x78, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x6f, 0x6f, 0x6c,
	0x54, 0x57, 0x41, 0x50, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x0f, 0x70, 0x6f, 0x6f, 0x6c,
	0x54, 0x77, 0x61, 0x70, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x12, 0x61, 0x0a, 0x16, 0x63,
	0x69, 0x72, 0x63, 0x75, 0x69, 0x74, 0x5f, 0x62, 0x72, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x5f, 0x73,
	0x74, 0x61, 0x74, 0x65, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x70, 0x61,
	0x77, 0x2e, 0x64, 0x65, 0x78, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x69, 0x72, 0x63, 0x75, 0x69, 0x74,
	0x42, 0x72, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x45, 0x78, 0x70, 0x6f,
	0x72, 0x74, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x14, 0x63, 0x69, 0x72, 0x63, 0x75, 0x69,
	0x74, 0x42, 0x72, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x73, 0x12, 0x5a,
	0x0a, 0x13, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69, 0x74, 0x79, 0x5f, 0x70, 0x6f, 0x73, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x70, 0x61,
	0x77, 0x2e, 0x64, 0x65, 0x78, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69,
	0x74, 0x79, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x78, 0x70, 0x6f, 0x72, 0x74,
	0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x12, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69, 0x74,
	0x79, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x3f, 0x0a, 0x0c, 0x73, 0x77,
	0x61, 0x70, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x16, 0x2e, 0x70, 0x61, 0x77, 0x2e, 0x64, 0x65, 0x78, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x77,
	0x61, 0x70, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x0b,
	0x73, 0x77, 0x61, 0x70, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x73, 0x2a, 0x50, 0x0a, 0x09, 0x4f,
	0x72, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1a, 0x0a, 0x16, 0x4f, 0x52, 0x44, 0x45,
	0x52, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49,
	0x45, 0x44, 0x10, 0x00, 0x12, 0x12, 0x0a, 0x0e, 0x4f, 0x52, 0x44, 0x45, 0x52, 0x5f, 0x54, 0x59,
	0x50, 0x45, 0x5f, 0x42, 0x55, 0x59, 0x10, 0x01, 0x12, 0x13, 0x0a, 0x0f, 0x4f, 0x52, 0x44, 0x45,
	0x52, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x53, 0x45, 0x4c, 0x4c, 0x10, 0x02, 0x2a, 0xb4, 0x01,
	0x0a, 0x0b, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1c, 0x0a,
	0x18, 0x4f, 0x52, 0x44, 0x45, 0x52, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55, 0x4e,
	0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x15, 0x0a, 0x11, 0x4f,
	0x52, 0x44, 0x45, 0x52, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x4f, 0x50, 0x45, 0x4e,
	0x10, 0x01, 0x12, 0x21, 0x0a, 0x1d, 0x4f, 0x52, 0x44, 0x45, 0x52, 0x5f, 0x53, 0x54, 0x41, 0x54,
	0x55, 0x53, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x49, 0x41, 0x4c, 0x4c, 0x59, 0x5f, 0x46, 0x49, 0x4c,
	0x4c, 0x45, 0x44, 0x10, 0x02, 0x12, 0x17, 0x0a, 0x13, 0x4f, 0x52, 0x44, 0x45, 0x52, 0x5f, 0x53,
	0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x46, 0x49, 0x4c, 0x4c, 0x45, 0x44, 0x10, 0x03, 0x12, 0x1a,
	0x0a, 0x16, 0x4f, 0x52, 0x44, 0x45, 0x52, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x43,
	0x41, 0x4e, 0x43, 0x45, 0x4c, 0x4c, 0x45, 0x44, 0x10, 0x04, 0x12, 0x18, 0x0a, 0x14, 0x4f, 0x52,
	0x44, 0x45, 0x52, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x45, 0x58, 0x50, 0x49, 0x52,
	0x45, 0x44, 0x10, 0x05, 0x42, 0x26, 0x5a, 0x24, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x70, 0x61, 0x77, 0x2d, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x70, 0x61, 0x77,
	0x2f, 0x78, 0x2f, 0x64, 0x65, 0x78, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x62, 0x06, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_paw_dex_v1_dex_proto_rawDescOnce sync.Once
	file_paw_dex_v1_dex_proto_rawDescData = file_paw_dex_v1_dex_proto_rawDesc
)

func file_paw_dex_v1_dex_proto_rawDescGZIP() []byte {
	file_paw_dex_v1_dex_proto_rawDescOnce.Do(func() {
		file_paw_dex_v1_dex_proto_rawDescData = protoimpl.X.CompressGZIP(file_paw_dex_v1_dex_proto_rawDescData)
	})
	return file_paw_dex_v1_dex_proto_rawDescData
}

var file_paw_dex_v1_dex_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_paw_dex_v1_dex_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_paw_dex_v1_dex_proto_goTypes = []interface{}{
	(OrderType)(0),                    // 0: paw.dex.v1.OrderType
	(OrderStatus)(0),                  // 1: paw.dex.v1.OrderStatus
	(*Params)(nil),                    // 2: paw.dex.v1.Params
	(*AuthorizedChannel)(nil),         // 3: paw.dex.v1.AuthorizedChannel
	(*Pool)(nil),                      // 4: paw.dex.v1.Pool
	(*PoolTWAP)(nil),                  // 5: paw.dex.v1.PoolTWAP
	(*LimitOrder)(nil),                // 6: paw.dex.v1.LimitOrder
	(*CircuitBreakerStateExport)(nil), // 7: paw.dex.v1.CircuitBreakerStateExport
	(*LiquidityPositionExport)(nil),   // 8: paw.dex.v1.LiquidityPositionExport
	(*SwapCommit)(nil),                // 9: paw.dex.v1.SwapCommit
	(*GenesisState)(nil),              // 10: paw.dex.v1.GenesisState
}
var file_paw_dex_v1_dex_proto_depIdxs = []int32{
	3,  // 0: paw.dex.v1.Params.authorized_channels:type_name -> paw.dex.v1.AuthorizedChannel
	0,  // 1: paw.dex.v1.LimitOrder.order_type:type_name -> paw.dex.v1.OrderType
	1,  // 2: paw.dex.v1.LimitOrder.status:type_name -> paw.dex.v1.OrderStatus
	2,  // 3: paw.dex.v1.GenesisState.params:type_name -> paw.dex.v1.Params
	4,  // 4: paw.dex.v1.GenesisState.pools:type_name -> paw.dex.v1.Pool
	6,  // 5: paw.dex.v1.GenesisState.limit_orders:type_name -> paw.dex.v1.LimitOrder
	5,  // 6: paw.dex.v1.GenesisState.pool_twap_records:type_name -> paw.dex.v1.PoolTWAP
	7,  // 7: paw.dex.v1.GenesisState.circuit_breaker_states:type_name -> paw.dex.v1.CircuitBreakerStateExport
	8,  // 8: paw.dex.v1.GenesisState.liquidity_positions:type_name -> paw.dex.v1.LiquidityPositionExport
	9,  // 9: paw.dex.v1.GenesisState.swap_commits:type_name -> paw.dex.v1.SwapCommit
	10, // [10:10] is the sub-list for method output_type
	10, // [10:10] is the sub-list for method input_type
	10, // [10:10] is the sub-list for extension type_name
	10, // [10:10] is the sub-list for extension extendee
	0,  // [0:10] is the sub-list for field type_name
}

func init() { file_paw_dex_v1_dex_proto_init() }
func file_paw_dex_v1_dex_proto_init() {
	if File_paw_dex_v1_dex_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_paw_dex_v1_dex_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Params); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_paw_dex_v1_dex_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AuthorizedChannel); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_paw_dex_v1_dex_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Pool); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_paw_dex_v1_dex_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PoolTWAP); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_paw_dex_v1_dex_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LimitOrder); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_paw_dex_v1_dex_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CircuitBreakerStateExport); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_paw_dex_v1_dex_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LiquidityPositionExport); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_paw_dex_v1_dex_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SwapCommit); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_paw_dex_v1_dex_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GenesisState); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_paw_dex_v1_dex_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_paw_dex_v1_dex_proto_goTypes,
		DependencyIndexes: file_paw_dex_v1_dex_proto_depIdxs,
		EnumInfos:         file_paw_dex_v1_dex_proto_enumTypes,
		MessageInfos:      file_paw_dex_v1_dex_proto_msgTypes,
	}.Build()
	File_paw_dex_v1_dex_proto = out.File
	file_paw_dex_v1_dex_proto_rawDesc = nil
	file_paw_dex_v1_dex_proto_goTypes = nil
	file_paw_dex_v1_dex_proto_depIdxs = nil
}
