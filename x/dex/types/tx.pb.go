// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: paw/dex/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	cosmossdk_io_math "cosmossdk.io/math"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCreatePool defines the message for creating a new liquidity pool
type MsgCreatePool struct {
	Creator string                `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	TokenA  string                `protobuf:"bytes,2,opt,name=token_a,json=tokenA,proto3" json:"token_a,omitempty"`
	TokenB  string                `protobuf:"bytes,3,opt,name=token_b,json=tokenB,proto3" json:"token_b,omitempty"`
	AmountA cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=amount_a,json=amountA,proto3,customtype=cosmossdk.io/math.Int" json:"amount_a"`
	AmountB cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=amount_b,json=amountB,proto3,customtype=cosmossdk.io/math.Int" json:"amount_b"`
}

func (m *MsgCreatePool) Reset()         { *m = MsgCreatePool{} }
func (m *MsgCreatePool) String() string { return proto.CompactTextString(m) }
func (*MsgCreatePool) ProtoMessage()    {}
func (*MsgCreatePool) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{0}
}
func (m *MsgCreatePool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreatePool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreatePool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreatePool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreatePool.Merge(m, src)
}
func (m *MsgCreatePool) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreatePool) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreatePool.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreatePool proto.InternalMessageInfo

func (m *MsgCreatePool) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreatePool) GetTokenA() string {
	if m != nil {
		return m.TokenA
	}
	return ""
}

func (m *MsgCreatePool) GetTokenB() string {
	if m != nil {
		return m.TokenB
	}
	return ""
}

// MsgCreatePoolResponse defines the response for MsgCreatePool
type MsgCreatePoolResponse struct {
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
}

func (m *MsgCreatePoolResponse) Reset()         { *m = MsgCreatePoolResponse{} }
func (m *MsgCreatePoolResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreatePoolResponse) ProtoMessage()    {}
func (*MsgCreatePoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{1}
}
func (m *MsgCreatePoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreatePoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreatePoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreatePoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreatePoolResponse.Merge(m, src)
}
func (m *MsgCreatePoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreatePoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreatePoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreatePoolResponse proto.InternalMessageInfo

func (m *MsgCreatePoolResponse) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

// MsgAddLiquidity defines the message for adding liquidity to a pool
type MsgAddLiquidity struct {
	Provider string                `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	PoolId   uint64                `protobuf:"varint,2,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	AmountA  cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount_a,json=amountA,proto3,customtype=cosmossdk.io/math.Int" json:"amount_a"`
	AmountB  cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=amount_b,json=amountB,proto3,customtype=cosmossdk.io/math.Int" json:"amount_b"`
}

func (m *MsgAddLiquidity) Reset()         { *m = MsgAddLiquidity{} }
func (m *MsgAddLiquidity) String() string { return proto.CompactTextString(m) }
func (*MsgAddLiquidity) ProtoMessage()    {}
func (*MsgAddLiquidity) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{2}
}
func (m *MsgAddLiquidity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddLiquidity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddLiquidity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddLiquidity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddLiquidity.Merge(m, src)
}
func (m *MsgAddLiquidity) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddLiquidity) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddLiquidity.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddLiquidity proto.InternalMessageInfo

func (m *MsgAddLiquidity) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *MsgAddLiquidity) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

// MsgAddLiquidityResponse defines the response for MsgAddLiquidity
type MsgAddLiquidityResponse struct {
	Shares cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=shares,proto3,customtype=cosmossdk.io/math.Int" json:"shares"`
}

func (m *MsgAddLiquidityResponse) Reset()         { *m = MsgAddLiquidityResponse{} }
func (m *MsgAddLiquidityResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAddLiquidityResponse) ProtoMessage()    {}
func (*MsgAddLiquidityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{3}
}
func (m *MsgAddLiquidityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddLiquidityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddLiquidityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddLiquidityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddLiquidityResponse.Merge(m, src)
}
func (m *MsgAddLiquidityResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddLiquidityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddLiquidityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddLiquidityResponse proto.InternalMessageInfo

// MsgRemoveLiquidity defines the message for removing liquidity from a pool
type MsgRemoveLiquidity struct {
	Provider string                `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	PoolId   uint64                `protobuf:"varint,2,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	Shares   cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=shares,proto3,customtype=cosmossdk.io/math.Int" json:"shares"`
}

func (m *MsgRemoveLiquidity) Reset()         { *m = MsgRemoveLiquidity{} }
func (m *MsgRemoveLiquidity) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveLiquidity) ProtoMessage()    {}
func (*MsgRemoveLiquidity) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{4}
}
func (m *MsgRemoveLiquidity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveLiquidity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveLiquidity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveLiquidity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveLiquidity.Merge(m, src)
}
func (m *MsgRemoveLiquidity) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveLiquidity) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveLiquidity.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveLiquidity proto.InternalMessageInfo

func (m *MsgRemoveLiquidity) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *MsgRemoveLiquidity) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

// MsgRemoveLiquidityResponse defines the response for MsgRemoveLiquidity
type MsgRemoveLiquidityResponse struct {
	AmountA cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=amount_a,json=amountA,proto3,customtype=cosmossdk.io/math.Int" json:"amount_a"`
	AmountB cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount_b,json=amountB,proto3,customtype=cosmossdk.io/math.Int" json:"amount_b"`
}

func (m *MsgRemoveLiquidityResponse) Reset()         { *m = MsgRemoveLiquidityResponse{} }
func (m *MsgRemoveLiquidityResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveLiquidityResponse) ProtoMessage()    {}
func (*MsgRemoveLiquidityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{5}
}
func (m *MsgRemoveLiquidityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveLiquidityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveLiquidityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveLiquidityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveLiquidityResponse.Merge(m, src)
}
func (m *MsgRemoveLiquidityResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveLiquidityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveLiquidityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveLiquidityResponse proto.InternalMessageInfo

// MsgSwap defines the message for swapping tokens
//
// MEV RISK WARNING:
// This message is visible in the public mempool before execution, exposing it to:
// - Front-running: Validators/bots can execute swaps before yours to move price against you
// - Sandwich attacks: Attackers can trade before AND after your swap to extract value
// - Slippage extraction: MEV searchers can manipulate price to your exact slippage limit
//
// CURRENT PROTECTIONS (Testnet):
// - min_amount_out: Enforces minimum acceptable output (slippage protection)
// - deadline: Transaction expires if not executed by deadline
// - max_pool_drain_percent: Governance limit on single-swap liquidity extraction
//
// RECOMMENDED USER PRACTICES:
// - Use tight slippage (0.5-1% for liquid pairs, up to 3% for illiquid pairs)
// - Set short deadlines (30-120 seconds)
// - Split large orders into smaller swaps across multiple blocks
// - Monitor mempool congestion before submitting large swaps
//
// FUTURE MAINNET PROTECTIONS:
// - Commit-reveal scheme (MsgCommitSwap/MsgRevealSwap) to hide swap details
// - Private mempool integration with supporting validators
// - Batch auction execution for MEV-resistant pricing
//
// See docs/security/MEV_RISKS.md for detailed information.
type MsgSwap struct {
	Trader   string                `protobuf:"bytes,1,opt,name=trader,proto3" json:"trader,omitempty"`
	PoolId   uint64                `protobuf:"varint,2,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	TokenIn  string                `protobuf:"bytes,3,opt,name=token_in,json=tokenIn,proto3" json:"token_in,omitempty"`
	TokenOut string                `protobuf:"bytes,4,opt,name=token_out,json=tokenOut,proto3" json:"token_out,omitempty"`
	AmountIn cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=amount_in,json=amountIn,proto3,customtype=cosmossdk.io/math.Int" json:"amount_in"`
	// min_amount_out enforces slippage protection - swap fails if output is less than this value
	// This is your PRIMARY defense against MEV - set it carefully based on expected price impact
	MinAmountOut cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=min_amount_out,json=minAmountOut,proto3,customtype=cosmossdk.io/math.Int" json:"min_amount_out"`
	// deadline is the unix timestamp (in seconds) after which the swap is no longer valid
	// This protects against transaction delays that could result in unfavorable execution
	// Recommended: 30-120 seconds from submission time
	Deadline int64 `protobuf:"varint,7,opt,name=deadline,proto3" json:"deadline,omitempty"`
}

func (m *MsgSwap) Reset()         { *m = MsgSwap{} }
func (m *MsgSwap) String() string { return proto.CompactTextString(m) }
func (*MsgSwap) ProtoMessage()    {}
func (*MsgSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{6}
}
func (m *MsgSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSwap.Merge(m, src)
}
func (m *MsgSwap) XXX_Size() int {
	return m.Size()
}
func (m *MsgSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSwap.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSwap proto.InternalMessageInfo

func (m *MsgSwap) GetTrader() string {
	if m != nil {
		return m.Trader
	}
	return ""
}

func (m *MsgSwap) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *MsgSwap) GetTokenIn() string {
	if m != nil {
		return m.TokenIn
	}
	return ""
}

func (m *MsgSwap) GetTokenOut() string {
	if m != nil {
		return m.TokenOut
	}
	return ""
}

func (m *MsgSwap) GetDeadline() int64 {
	if m != nil {
		return m.Deadline
	}
	return 0
}

// MsgSwapResponse defines the response for MsgSwap
type MsgSwapResponse struct {
	AmountOut cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=amount_out,json=amountOut,proto3,customtype=cosmossdk.io/math.Int" json:"amount_out"`
}

func (m *MsgSwapResponse) Reset()         { *m = MsgSwapResponse{} }
func (m *MsgSwapResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSwapResponse) ProtoMessage()    {}
func (*MsgSwapResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{7}
}
func (m *MsgSwapResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSwapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSwapResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSwapResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSwapResponse.Merge(m, src)
}
func (m *MsgSwapResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSwapResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSwapResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSwapResponse proto.InternalMessageInfo

// MsgCommitSwap defines the message for committing to a swap (MEV protection - phase 1)
//
// COMMIT-REVEAL SCHEME:
// This two-phase mechanism protects against MEV by hiding swap details until after commitment.
//
// Phase 1 (MsgCommitSwap): Submit a hash of your swap parameters
// - Hash must be: keccak256(trader, pool_id, token_in, token_out, amount_in, min_amount_out, deadline, nonce)
// - Nonce must be random to prevent hash grinding attacks
// - Commit is valid for commit_timeout_blocks (default: 100 blocks)
//
// Phase 2 (MsgRevealSwap): After commit_reveal_delay blocks, reveal actual parameters
// - All revealed parameters must match the committed hash
// - If validation passes, swap executes with revealed parameters
// - If reveal doesn't match or timeout expires, commit is invalidated
//
// BENEFITS:
// - Front-runners cannot see your swap details during commit phase
// - Sandwich attacks become economically infeasible
// - Your slippage tolerance remains hidden until reveal
//
// TRADEOFFS:
// - Requires two transactions (higher gas cost)
// - Minimum delay of commit_reveal_delay blocks (~60 seconds with 6s blocks)
// - More complex UX compared to instant swaps
//
// WHEN TO USE:
// - Large swaps where MEV risk exceeds additional gas cost
// - High-value trades in volatile markets
// - When mempool congestion is high
//
// This feature must be enabled via governance (enable_commit_reveal parameter).
type MsgCommitSwap struct {
	Trader string `protobuf:"bytes,1,opt,name=trader,proto3" json:"trader,omitempty"`
	// swap_hash is keccak256(trader, pool_id, token_in, token_out, amount_in, min_amount_out, deadline, nonce)
	// All parameters must be in their canonical encoding (addresses as bech32, amounts as decimal strings, etc.)
	SwapHash string `protobuf:"bytes,2,opt,name=swap_hash,json=swapHash,proto3" json:"swap_hash,omitempty"`
}

func (m *MsgCommitSwap) Reset()         { *m = MsgCommitSwap{} }
func (m *MsgCommitSwap) String() string { return proto.CompactTextString(m) }
func (*MsgCommitSwap) ProtoMessage()    {}
func (*MsgCommitSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{8}
}
func (m *MsgCommitSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCommitSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCommitSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCommitSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCommitSwap.Merge(m, src)
}
func (m *MsgCommitSwap) XXX_Size() int {
	return m.Size()
}
func (m *MsgCommitSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCommitSwap.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCommitSwap proto.InternalMessageInfo

func (m *MsgCommitSwap) GetTrader() string {
	if m != nil {
		return m.Trader
	}
	return ""
}

func (m *MsgCommitSwap) GetSwapHash() string {
	if m != nil {
		return m.SwapHash
	}
	return ""
}

// MsgCommitSwapResponse defines the response for MsgCommitSwap
type MsgCommitSwapResponse struct {
	// commit_height is the block height at which the commit was included
	// Reveal is allowed after commit_height + commit_reveal_delay
	CommitHeight int64 `protobuf:"varint,1,opt,name=commit_height,json=commitHeight,proto3" json:"commit_height,omitempty"`
	// earliest_reveal_height is the earliest block at which reveal is allowed
	EarliestRevealHeight int64 `protobuf:"varint,2,opt,name=earliest_reveal_height,json=earliestRevealHeight,proto3" json:"earliest_reveal_height,omitempty"`
	// expiry_height is the block height at which the commit expires if not revealed
	ExpiryHeight int64 `protobuf:"varint,3,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height,omitempty"`
}

func (m *MsgCommitSwapResponse) Reset()         { *m = MsgCommitSwapResponse{} }
func (m *MsgCommitSwapResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCommitSwapResponse) ProtoMessage()    {}
func (*MsgCommitSwapResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{9}
}
func (m *MsgCommitSwapResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCommitSwapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCommitSwapResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCommitSwapResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCommitSwapResponse.Merge(m, src)
}
func (m *MsgCommitSwapResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCommitSwapResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCommitSwapResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCommitSwapResponse proto.InternalMessageInfo

func (m *MsgCommitSwapResponse) GetCommitHeight() int64 {
	if m != nil {
		return m.CommitHeight
	}
	return 0
}

func (m *MsgCommitSwapResponse) GetEarliestRevealHeight() int64 {
	if m != nil {
		return m.EarliestRevealHeight
	}
	return 0
}

func (m *MsgCommitSwapResponse) GetExpiryHeight() int64 {
	if m != nil {
		return m.ExpiryHeight
	}
	return 0
}

// MsgRevealSwap defines the message for revealing and executing a committed swap (MEV protection - phase 2)
//
// This message reveals the parameters committed in MsgCommitSwap and executes the swap if valid.
//
// VALIDATION:
// - Commit must exist for this trader and hash
// - Current block height must be >= commit_height + commit_reveal_delay
// - Current block height must be < commit expiry
// - Hash of revealed parameters must match committed hash
// - All standard swap validations apply (deadline, slippage, etc.)
//
// If all validations pass, the swap executes with the revealed parameters.
type MsgRevealSwap struct {
	Trader       string                `protobuf:"bytes,1,opt,name=trader,proto3" json:"trader,omitempty"`
	PoolId       uint64                `protobuf:"varint,2,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	TokenIn      string                `protobuf:"bytes,3,opt,name=token_in,json=tokenIn,proto3" json:"token_in,omitempty"`
	TokenOut     string                `protobuf:"bytes,4,opt,name=token_out,json=tokenOut,proto3" json:"token_out,omitempty"`
	AmountIn     cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=amount_in,json=amountIn,proto3,customtype=cosmossdk.io/math.Int" json:"amount_in"`
	MinAmountOut cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=min_amount_out,json=minAmountOut,proto3,customtype=cosmossdk.io/math.Int" json:"min_amount_out"`
	Deadline     int64                 `protobuf:"varint,7,opt,name=deadline,proto3" json:"deadline,omitempty"`
	// nonce is the random value used when creating the commit hash
	// Must match the nonce used in the original commitment
	Nonce string `protobuf:"bytes,8,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *MsgRevealSwap) Reset()         { *m = MsgRevealSwap{} }
func (m *MsgRevealSwap) String() string { return proto.CompactTextString(m) }
func (*MsgRevealSwap) ProtoMessage()    {}
func (*MsgRevealSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{10}
}
func (m *MsgRevealSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevealSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevealSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevealSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevealSwap.Merge(m, src)
}
func (m *MsgRevealSwap) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevealSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevealSwap.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevealSwap proto.InternalMessageInfo

func (m *MsgRevealSwap) GetTrader() string {
	if m != nil {
		return m.Trader
	}
	return ""
}

func (m *MsgRevealSwap) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *MsgRevealSwap) GetTokenIn() string {
	if m != nil {
		return m.TokenIn
	}
	return ""
}

func (m *MsgRevealSwap) GetTokenOut() string {
	if m != nil {
		return m.TokenOut
	}
	return ""
}

func (m *MsgRevealSwap) GetDeadline() int64 {
	if m != nil {
		return m.Deadline
	}
	return 0
}

func (m *MsgRevealSwap) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

// MsgRevealSwapResponse defines the response for MsgRevealSwap
type MsgRevealSwapResponse struct {
	AmountOut cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=amount_out,json=amountOut,proto3,customtype=cosmossdk.io/math.Int" json:"amount_out"`
}

func (m *MsgRevealSwapResponse) Reset()         { *m = MsgRevealSwapResponse{} }
func (m *MsgRevealSwapResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRevealSwapResponse) ProtoMessage()    {}
func (*MsgRevealSwapResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{11}
}
func (m *MsgRevealSwapResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevealSwapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevealSwapResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevealSwapResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevealSwapResponse.Merge(m, src)
}
func (m *MsgRevealSwapResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevealSwapResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevealSwapResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevealSwapResponse proto.InternalMessageInfo

// SwapRequest defines a single swap within a batch operation
// AGENT-1: Individual swap parameters for batch processing
type SwapRequest struct {
	PoolId       uint64                `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	TokenIn      string                `protobuf:"bytes,2,opt,name=token_in,json=tokenIn,proto3" json:"token_in,omitempty"`
	TokenOut     string                `protobuf:"bytes,3,opt,name=token_out,json=tokenOut,proto3" json:"token_out,omitempty"`
	AmountIn     cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=amount_in,json=amountIn,proto3,customtype=cosmossdk.io/math.Int" json:"amount_in"`
	MinAmountOut cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=min_amount_out,json=minAmountOut,proto3,customtype=cosmossdk.io/math.Int" json:"min_amount_out"`
}

func (m *SwapRequest) Reset()         { *m = SwapRequest{} }
func (m *SwapRequest) String() string { return proto.CompactTextString(m) }
func (*SwapRequest) ProtoMessage()    {}
func (*SwapRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{12}
}
func (m *SwapRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapRequest.Merge(m, src)
}
func (m *SwapRequest) XXX_Size() int {
	return m.Size()
}
func (m *SwapRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwapRequest proto.InternalMessageInfo

func (m *SwapRequest) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *SwapRequest) GetTokenIn() string {
	if m != nil {
		return m.TokenIn
	}
	return ""
}

func (m *SwapRequest) GetTokenOut() string {
	if m != nil {
		return m.TokenOut
	}
	return ""
}

// MsgBatchSwap defines the message for executing multiple swaps atomically
// AGENT-1: Enables agents to submit batch swap requests with lower gas overhead
//
// BENEFITS:
// - Reduced gas cost per swap due to shared transaction overhead
// - Atomic execution (all succeed or all fail)
// - MEV protection through batching (harder to sandwich individual swaps)
//
// LIMITS:
// - Maximum 10 swaps per batch (gas metering constraint)
// - All swaps share the same deadline
// - Each swap is validated independently
type MsgBatchSwap struct {
	Trader string        `protobuf:"bytes,1,opt,name=trader,proto3" json:"trader,omitempty"`
	Swaps  []SwapRequest `protobuf:"bytes,2,rep,name=swaps,proto3" json:"swaps"`
	// deadline applies to all swaps in the batch
	Deadline int64 `protobuf:"varint,3,opt,name=deadline,proto3" json:"deadline,omitempty"`
}

func (m *MsgBatchSwap) Reset()         { *m = MsgBatchSwap{} }
func (m *MsgBatchSwap) String() string { return proto.CompactTextString(m) }
func (*MsgBatchSwap) ProtoMessage()    {}
func (*MsgBatchSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{13}
}
func (m *MsgBatchSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchSwap.Merge(m, src)
}
func (m *MsgBatchSwap) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchSwap.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchSwap proto.InternalMessageInfo

func (m *MsgBatchSwap) GetTrader() string {
	if m != nil {
		return m.Trader
	}
	return ""
}

func (m *MsgBatchSwap) GetSwaps() []SwapRequest {
	if m != nil {
		return m.Swaps
	}
	return nil
}

func (m *MsgBatchSwap) GetDeadline() int64 {
	if m != nil {
		return m.Deadline
	}
	return 0
}

// BatchSwapResult defines the result of a single swap in a batch
type BatchSwapResult struct {
	PoolId    uint64                `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	AmountOut cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount_out,json=amountOut,proto3,customtype=cosmossdk.io/math.Int" json:"amount_out"`
	Success   bool                  `protobuf:"varint,3,opt,name=success,proto3" json:"success,omitempty"`
	Error     string                `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *BatchSwapResult) Reset()         { *m = BatchSwapResult{} }
func (m *BatchSwapResult) String() string { return proto.CompactTextString(m) }
func (*BatchSwapResult) ProtoMessage()    {}
func (*BatchSwapResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{14}
}
func (m *BatchSwapResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSwapResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSwapResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSwapResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSwapResult.Merge(m, src)
}
func (m *BatchSwapResult) XXX_Size() int {
	return m.Size()
}
func (m *BatchSwapResult) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSwapResult.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSwapResult proto.InternalMessageInfo

func (m *BatchSwapResult) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *BatchSwapResult) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *BatchSwapResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// MsgBatchSwapResponse defines the response for MsgBatchSwap
type MsgBatchSwapResponse struct {
	Results []BatchSwapResult `protobuf:"bytes,1,rep,name=results,proto3" json:"results"`
	// total_swaps is the number of swaps attempted
	TotalSwaps uint64 `protobuf:"varint,2,opt,name=total_swaps,json=totalSwaps,proto3" json:"total_swaps,omitempty"`
	// successful_swaps is the number of swaps that succeeded
	SuccessfulSwaps uint64 `protobuf:"varint,3,opt,name=successful_swaps,json=successfulSwaps,proto3" json:"successful_swaps,omitempty"`
}

func (m *MsgBatchSwapResponse) Reset()         { *m = MsgBatchSwapResponse{} }
func (m *MsgBatchSwapResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBatchSwapResponse) ProtoMessage()    {}
func (*MsgBatchSwapResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_326d282660a60ef8, []int{15}
}
func (m *MsgBatchSwapResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBatchSwapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBatchSwapResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBatchSwapResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBatchSwapResponse.Merge(m, src)
}
func (m *MsgBatchSwapResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBatchSwapResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBatchSwapResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBatchSwapResponse proto.InternalMessageInfo

func (m *MsgBatchSwapResponse) GetResults() []BatchSwapResult {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *MsgBatchSwapResponse) GetTotalSwaps() uint64 {
	if m != nil {
		return m.TotalSwaps
	}
	return 0
}

func (m *MsgBatchSwapResponse) GetSuccessfulSwaps() uint64 {
	if m != nil {
		return m.SuccessfulSwaps
	}
	return 0
}

func init() {
	proto.RegisterType((*MsgCreatePool)(nil), "paw.dex.v1.MsgCreatePool")
	proto.RegisterType((*MsgCreatePoolResponse)(nil), "paw.dex.v1.MsgCreatePoolResponse")
	proto.RegisterType((*MsgAddLiquidity)(nil), "paw.dex.v1.MsgAddLiquidity")
	proto.RegisterType((*MsgAddLiquidityResponse)(nil), "paw.dex.v1.MsgAddLiquidityResponse")
	proto.RegisterType((*MsgRemoveLiquidity)(nil), "paw.dex.v1.MsgRemoveLiquidity")
	proto.RegisterType((*MsgRemoveLiquidityResponse)(nil), "paw.dex.v1.MsgRemoveLiquidityResponse")
	proto.RegisterType((*MsgSwap)(nil), "paw.dex.v1.MsgSwap")
	proto.RegisterType((*MsgSwapResponse)(nil), "paw.dex.v1.MsgSwapResponse")
	proto.RegisterType((*MsgCommitSwap)(nil), "paw.dex.v1.MsgCommitSwap")
	proto.RegisterType((*MsgCommitSwapResponse)(nil), "paw.dex.v1.MsgCommitSwapResponse")
	proto.RegisterType((*MsgRevealSwap)(nil), "paw.dex.v1.MsgRevealSwap")
	proto.RegisterType((*MsgRevealSwapResponse)(nil), "paw.dex.v1.MsgRevealSwapResponse")
	proto.RegisterType((*SwapRequest)(nil), "paw.dex.v1.SwapRequest")
	proto.RegisterType((*MsgBatchSwap)(nil), "paw.dex.v1.MsgBatchSwap")
	proto.RegisterType((*BatchSwapResult)(nil), "paw.dex.v1.BatchSwapResult")
	proto.RegisterType((*MsgBatchSwapResponse)(nil), "paw.dex.v1.MsgBatchSwapResponse")
}

func init() { proto.RegisterFile("paw/dex/v1/tx.proto", fileDescriptor_326d282660a60ef8) }

var fileDescriptor_326d282660a60ef8 = []byte{
	// 1135 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0x7a, 0x1d, 0xdb, 0x79, 0x4d, 0x09, 0x6c, 0x5d, 0xe2, 0x38, 0x92, 0x13, 0x36, 0xa5,
	0x4a, 0x03, 0xf1, 0x36, 0x69, 0x0f, 0x28, 0x48, 0x48, 0x71, 0x25, 0x48, 0x2a, 0xac, 0x96, 0xcd,
	0x09, 0x24, 0xb0, 0xc6, 0xbb, 0xc3, 0x7a, 0x55, 0xef, 0xce, 0x76, 0x67, 0xec, 0x24, 0x37, 0x84,
	0x84, 0x84, 0x38, 0x71, 0xe3, 0xc0, 0x01, 0x4e, 0x9c, 0x40, 0xca, 0xa1, 0x12, 0x5f, 0xa1, 0xc7,
	0xaa, 0x07, 0x84, 0x38, 0x54, 0x28, 0x91, 0xc8, 0x87, 0xe0, 0x82, 0x66, 0x66, 0x77, 0xbd, 0x5e,
	0x37, 0x86, 0x3a, 0xe9, 0x8d, 0x8b, 0xb5, 0xf3, 0xfe, 0xcd, 0x7b, 0xbf, 0xf7, 0x9b, 0x37, 0x63,
	0xb8, 0x12, 0xa0, 0x7d, 0xc3, 0xc6, 0x07, 0x46, 0x7f, 0xc3, 0x60, 0x07, 0xf5, 0x20, 0x24, 0x8c,
	0x68, 0x10, 0xa0, 0xfd, 0xba, 0x8d, 0x0f, 0xea, 0xfd, 0x8d, 0x6a, 0xd9, 0x21, 0x0e, 0x11, 0x62,
	0x83, 0x7f, 0x49, 0x8b, 0x6a, 0xcd, 0x22, 0xd4, 0x23, 0xd4, 0x68, 0x23, 0x8a, 0x8d, 0xfe, 0x46,
	0x1b, 0x33, 0xb4, 0x61, 0x58, 0xc4, 0xf5, 0x23, 0xfd, 0x82, 0xd4, 0xb7, 0xa4, 0xa3, 0x5c, 0x44,
	0xaa, 0xf9, 0xc8, 0xd5, 0xa3, 0x0e, 0xdf, 0xd4, 0xa3, 0x4e, 0xa4, 0x78, 0x0d, 0x79, 0xae, 0x4f,
	0x0c, 0xf1, 0x2b, 0x45, 0xfa, 0x2f, 0x39, 0xb8, 0xdc, 0xa4, 0xce, 0x9d, 0x10, 0x23, 0x86, 0xef,
	0x13, 0xd2, 0xd5, 0x36, 0xa1, 0x68, 0xf1, 0x15, 0x09, 0x2b, 0xca, 0xb2, 0xb2, 0x3a, 0xd3, 0xa8,
	0x3c, 0x7d, 0xb4, 0x5e, 0x8e, 0x36, 0xd8, 0xb6, 0xed, 0x10, 0x53, 0xba, 0xc7, 0x42, 0xd7, 0x77,
	0xcc, 0xd8, 0x50, 0x9b, 0x87, 0x22, 0x23, 0x0f, 0xb0, 0xdf, 0x42, 0x95, 0x1c, 0xf7, 0x31, 0x0b,
	0x62, 0xb9, 0x3d, 0x50, 0xb4, 0x2b, 0x6a, 0x4a, 0xd1, 0xd0, 0xde, 0x87, 0x12, 0xf2, 0x48, 0xcf,
	0x67, 0x2d, 0x54, 0xc9, 0x8b, 0x6d, 0xde, 0x7a, 0xfc, 0x6c, 0x69, 0xea, 0x8f, 0x67, 0x4b, 0x57,
	0xe5, 0x56, 0xd4, 0x7e, 0x50, 0x77, 0x89, 0xe1, 0x21, 0xd6, 0xa9, 0xef, 0xfa, 0xec, 0xe9, 0xa3,
	0x75, 0x88, 0x72, 0xd8, 0xf5, 0x99, 0x59, 0x94, 0xce, 0xdb, 0xa9, 0x38, 0xed, 0xca, 0xf4, 0xc4,
	0x71, 0x1a, 0x5b, 0xd7, 0xbf, 0x3c, 0x3d, 0x5a, 0x8b, 0xeb, 0xf9, 0xe6, 0xf4, 0x68, 0xed, 0x6a,
	0xdc, 0xb6, 0x21, 0x74, 0xf4, 0x9b, 0x70, 0x75, 0x48, 0x60, 0x62, 0x1a, 0x10, 0x9f, 0x62, 0x5e,
	0x69, 0x40, 0x48, 0xb7, 0xe5, 0xda, 0x02, 0xb6, 0xbc, 0x59, 0xe0, 0xcb, 0x5d, 0x5b, 0xff, 0x3e,
	0x07, 0x73, 0x4d, 0xea, 0x6c, 0xdb, 0xf6, 0x87, 0xee, 0xc3, 0x9e, 0x6b, 0xbb, 0xec, 0x50, 0xbb,
	0x0d, 0xa5, 0x20, 0x24, 0x7d, 0xd7, 0xc6, 0xff, 0x0e, 0x72, 0x62, 0x99, 0xde, 0x22, 0x97, 0xde,
	0x62, 0x08, 0x4c, 0xf5, 0x82, 0xc0, 0xcc, 0x9f, 0x03, 0xcc, 0x1b, 0x1c, 0xcc, 0x24, 0x6f, 0x8e,
	0xe6, 0x7c, 0x0a, 0xcd, 0x34, 0x12, 0xfa, 0x67, 0x30, 0x9f, 0x11, 0x25, 0x88, 0xde, 0x81, 0x02,
	0xed, 0xa0, 0x10, 0xd3, 0x08, 0xa2, 0x17, 0xca, 0x25, 0x72, 0xd5, 0x7f, 0x53, 0x40, 0x6b, 0x52,
	0xc7, 0xc4, 0x1e, 0xe9, 0xe3, 0x97, 0xd6, 0x80, 0x41, 0xaa, 0xea, 0xc4, 0xa9, 0x6e, 0xbd, 0x3d,
	0x82, 0x5a, 0x35, 0x85, 0x5a, 0xa6, 0x02, 0xfd, 0x67, 0x05, 0xaa, 0xa3, 0xe2, 0x04, 0xbc, 0x34,
	0x25, 0x94, 0x0b, 0xa2, 0x44, 0x6e, 0x72, 0x4a, 0xe8, 0x7f, 0xe5, 0xa0, 0xd8, 0xa4, 0xce, 0xde,
	0x3e, 0x0a, 0xb4, 0x9b, 0x50, 0x60, 0x21, 0xfa, 0x2f, 0xd0, 0x47, 0x76, 0x67, 0x03, 0xbf, 0x00,
	0x25, 0x39, 0x5f, 0x5c, 0x3f, 0x1a, 0x30, 0x72, 0xde, 0xec, 0xfa, 0xda, 0x22, 0xcc, 0x48, 0x15,
	0xe9, 0x31, 0xc9, 0x66, 0x53, 0xda, 0xde, 0xeb, 0x31, 0x6d, 0x07, 0x66, 0xa2, 0xb2, 0x5c, 0x7f,
	0x92, 0xb9, 0x11, 0x81, 0xb2, 0xeb, 0x6b, 0x1f, 0xc1, 0x2b, 0x9e, 0xeb, 0xb7, 0xa2, 0x68, 0x7c,
	0xaf, 0xc2, 0x8b, 0x87, 0x9b, 0xf5, 0x5c, 0x7f, 0x5b, 0x44, 0xe0, 0xc9, 0x55, 0xa1, 0x64, 0x63,
	0x64, 0x77, 0x5d, 0x1f, 0x57, 0x8a, 0xcb, 0xca, 0xaa, 0x6a, 0x26, 0xeb, 0xad, 0x25, 0x4e, 0x92,
	0x08, 0x16, 0x4e, 0x91, 0xb9, 0x14, 0x45, 0x38, 0xb8, 0xfa, 0xa7, 0x62, 0xda, 0xf0, 0xcf, 0x84,
	0x0b, 0x77, 0x01, 0x52, 0xe9, 0x4d, 0xc0, 0x86, 0x08, 0xab, 0x7b, 0x3d, 0xa6, 0x7f, 0xa5, 0xc8,
	0xfb, 0x82, 0x78, 0x9e, 0xcb, 0x26, 0xec, 0xe6, 0x22, 0xcc, 0xd0, 0x7d, 0x14, 0xb4, 0x3a, 0x88,
	0x76, 0xa2, 0xfb, 0xa2, 0xc4, 0x05, 0x3b, 0x88, 0x76, 0xb6, 0xde, 0xcc, 0x14, 0x38, 0x34, 0x87,
	0x93, 0x5d, 0xf5, 0xef, 0x14, 0x39, 0x88, 0x13, 0x49, 0x52, 0xed, 0x0a, 0x5c, 0xb6, 0x84, 0xb4,
	0xd5, 0xc1, 0xae, 0xd3, 0x91, 0x05, 0xab, 0xe6, 0xac, 0x14, 0xee, 0x08, 0x99, 0x76, 0x1b, 0x5e,
	0xc7, 0x28, 0xec, 0xba, 0x98, 0xb2, 0x56, 0x88, 0xfb, 0x18, 0x75, 0x63, 0xeb, 0x9c, 0xb0, 0x2e,
	0xc7, 0x5a, 0x53, 0x28, 0x23, 0xaf, 0x15, 0xb8, 0x8c, 0x0f, 0x02, 0x37, 0x3c, 0x8c, 0x8d, 0x55,
	0x19, 0x5a, 0x0a, 0xa5, 0x91, 0xfe, 0xb5, 0x2a, 0x10, 0x92, 0x8e, 0xff, 0xf3, 0xfd, 0x7c, 0x7c,
	0xd7, 0xca, 0x30, 0xed, 0x13, 0xdf, 0xc2, 0x95, 0x92, 0xa8, 0x48, 0x2e, 0xc6, 0x92, 0x64, 0x00,
	0xbc, 0x6e, 0x09, 0x8e, 0x0c, 0x04, 0x2f, 0xe5, 0x44, 0xfc, 0xad, 0xc0, 0x25, 0x19, 0xfc, 0x61,
	0x0f, 0x53, 0x76, 0xe6, 0x43, 0x60, 0xa8, 0x77, 0xb9, 0x31, 0xbd, 0x53, 0xc7, 0xf5, 0x2e, 0x7f,
	0xb1, 0xbd, 0x9b, 0x3e, 0x67, 0xef, 0xf4, 0x5f, 0x15, 0x98, 0x6d, 0x52, 0xa7, 0x81, 0x98, 0xd5,
	0x99, 0x90, 0xec, 0xb7, 0x60, 0x9a, 0x9f, 0x7e, 0x5a, 0xc9, 0x2d, 0xab, 0xab, 0x97, 0x36, 0xe7,
	0xeb, 0x83, 0xb7, 0x71, 0x3d, 0x05, 0x6c, 0x23, 0xcf, 0xb3, 0x34, 0xa5, 0xed, 0x10, 0x67, 0xd4,
	0xcc, 0x8c, 0xbc, 0x96, 0x61, 0x47, 0x39, 0xc5, 0x8e, 0x24, 0x51, 0xfd, 0x27, 0x05, 0xe6, 0x92,
	0x95, 0x89, 0x69, 0xaf, 0x3b, 0xa6, 0x77, 0xc3, 0x84, 0xc9, 0x9d, 0x87, 0x30, 0x5a, 0x05, 0x8a,
	0xb4, 0x67, 0x59, 0x98, 0xca, 0xd7, 0x42, 0xc9, 0x8c, 0x97, 0x9c, 0xec, 0x38, 0x0c, 0x49, 0x18,
	0x1d, 0x5f, 0xb9, 0xd0, 0x7f, 0x50, 0xa0, 0x9c, 0xce, 0x3c, 0x61, 0xf1, 0xbb, 0x50, 0x0c, 0x45,
	0xde, 0xfc, 0x85, 0xc4, 0xa1, 0x5b, 0x4c, 0x43, 0x97, 0xa9, 0x2d, 0x82, 0x2f, 0xf6, 0xd0, 0x96,
	0xe0, 0x12, 0x23, 0x0c, 0x75, 0x5b, 0x31, 0xf6, 0xbc, 0x5c, 0x10, 0xa2, 0x3d, 0x81, 0xf0, 0x0d,
	0x78, 0x35, 0xca, 0xeb, 0xf3, 0x5e, 0x6c, 0xa5, 0x0a, 0xab, 0xb9, 0x81, 0x5c, 0x98, 0x6e, 0xfe,
	0x98, 0x07, 0xb5, 0x49, 0x1d, 0x8e, 0x52, 0xea, 0x8f, 0xc4, 0x42, 0x3a, 0x9b, 0xa1, 0x47, 0x73,
	0xf5, 0x8d, 0x33, 0x55, 0x49, 0x71, 0xf7, 0x61, 0x76, 0xe8, 0xc9, 0xbc, 0x98, 0x71, 0x49, 0x2b,
	0xab, 0x2b, 0x63, 0x94, 0x49, 0xc4, 0x8f, 0x61, 0x2e, 0xfb, 0x0c, 0xac, 0x65, 0xfc, 0x32, 0xfa,
	0xea, 0xf5, 0xf1, 0xfa, 0x24, 0xf4, 0x3b, 0x90, 0x17, 0xe4, 0xbf, 0x92, 0xb1, 0xe7, 0xc2, 0xea,
	0xe2, 0x73, 0x84, 0xe9, 0x49, 0x94, 0xba, 0x4b, 0x47, 0x20, 0x4b, 0x54, 0xa3, 0x90, 0x8d, 0xde,
	0x7c, 0x77, 0x01, 0x52, 0xb7, 0xce, 0xc2, 0x48, 0xee, 0xb1, 0x6a, 0x24, 0xd6, 0x73, 0x26, 0xe4,
	0x07, 0x30, 0x33, 0x38, 0xd3, 0x95, 0x8c, 0x7d, 0xa2, 0xa9, 0x2e, 0x9f, 0xa5, 0x89, 0x03, 0x55,
	0xa7, 0xbf, 0x38, 0x3d, 0x5a, 0x53, 0x1a, 0xef, 0x3d, 0x3e, 0xae, 0x29, 0x4f, 0x8e, 0x6b, 0xca,
	0x9f, 0xc7, 0x35, 0xe5, 0xdb, 0x93, 0xda, 0xd4, 0x93, 0x93, 0xda, 0xd4, 0xef, 0x27, 0xb5, 0xa9,
	0x4f, 0xae, 0x39, 0x2e, 0xeb, 0xf4, 0xda, 0x75, 0x8b, 0x78, 0x46, 0x80, 0xf6, 0xd7, 0xad, 0x0e,
	0x72, 0x7d, 0xfe, 0x65, 0x1c, 0x88, 0x43, 0xcb, 0x0e, 0x03, 0x4c, 0xdb, 0x05, 0xf1, 0x77, 0xf5,
	0xd6, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd3, 0x1a, 0xf8, 0x1d, 0x4e, 0x0f, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// CreatePool defines a method for creating a new liquidity pool
	CreatePool(ctx context.Context, in *MsgCreatePool, opts ...grpc.CallOption) (*MsgCreatePoolResponse, error)
	// AddLiquidity defines a method for adding liquidity to an existing pool
	AddLiquidity(ctx context.Context, in *MsgAddLiquidity, opts ...grpc.CallOption) (*MsgAddLiquidityResponse, error)
	// RemoveLiquidity defines a method for removing liquidity from a pool
	RemoveLiquidity(ctx context.Context, in *MsgRemoveLiquidity, opts ...grpc.CallOption) (*MsgRemoveLiquidityResponse, error)
	// Swap defines a method for swapping tokens using AMM
	Swap(ctx context.Context, in *MsgSwap, opts ...grpc.CallOption) (*MsgSwapResponse, error)
	// CommitSwap defines a method for committing to a swap without revealing details
	// This is the first phase of the commit-reveal MEV protection scheme
	CommitSwap(ctx context.Context, in *MsgCommitSwap, opts ...grpc.CallOption) (*MsgCommitSwapResponse, error)
	// RevealSwap defines a method for revealing and executing a committed swap
	// This is the second phase of the commit-reveal MEV protection scheme
	RevealSwap(ctx context.Context, in *MsgRevealSwap, opts ...grpc.CallOption) (*MsgRevealSwapResponse, error)
	// BatchSwap defines a method for executing multiple swaps in a single transaction
	// AGENT-1: Enables agents to submit multiple swaps atomically with reduced gas
	BatchSwap(ctx context.Context, in *MsgBatchSwap, opts ...grpc.CallOption) (*MsgBatchSwapResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) CreatePool(ctx context.Context, in *MsgCreatePool, opts ...grpc.CallOption) (*MsgCreatePoolResponse, error) {
	out := new(MsgCreatePoolResponse)
	err := c.cc.Invoke(ctx, "/paw.dex.v1.Msg/CreatePool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddLiquidity(ctx context.Context, in *MsgAddLiquidity, opts ...grpc.CallOption) (*MsgAddLiquidityResponse, error) {
	out := new(MsgAddLiquidityResponse)
	err := c.cc.Invoke(ctx, "/paw.dex.v1.Msg/AddLiquidity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoveLiquidity(ctx context.Context, in *MsgRemoveLiquidity, opts ...grpc.CallOption) (*MsgRemoveLiquidityResponse, error) {
	out := new(MsgRemoveLiquidityResponse)
	err := c.cc.Invoke(ctx, "/paw.dex.v1.Msg/RemoveLiquidity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Swap(ctx context.Context, in *MsgSwap, opts ...grpc.CallOption) (*MsgSwapResponse, error) {
	out := new(MsgSwapResponse)
	err := c.cc.Invoke(ctx, "/paw.dex.v1.Msg/Swap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CommitSwap(ctx context.Context, in *MsgCommitSwap, opts ...grpc.CallOption) (*MsgCommitSwapResponse, error) {
	out := new(MsgCommitSwapResponse)
	err := c.cc.Invoke(ctx, "/paw.dex.v1.Msg/CommitSwap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RevealSwap(ctx context.Context, in *MsgRevealSwap, opts ...grpc.CallOption) (*MsgRevealSwapResponse, error) {
	out := new(MsgRevealSwapResponse)
	err := c.cc.Invoke(ctx, "/paw.dex.v1.Msg/RevealSwap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchSwap(ctx context.Context, in *MsgBatchSwap, opts ...grpc.CallOption) (*MsgBatchSwapResponse, error) {
	out := new(MsgBatchSwapResponse)
	err := c.cc.Invoke(ctx, "/paw.dex.v1.Msg/BatchSwap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// CreatePool defines a method for creating a new liquidity pool
	CreatePool(context.Context, *MsgCreatePool) (*MsgCreatePoolResponse, error)
	// AddLiquidity defines a method for adding liquidity to an existing pool
	AddLiquidity(context.Context, *MsgAddLiquidity) (*MsgAddLiquidityResponse, error)
	// RemoveLiquidity defines a method for removing liquidity from a pool
	RemoveLiquidity(context.Context, *MsgRemoveLiquidity) (*MsgRemoveLiquidityResponse, error)
	// Swap defines a method for swapping tokens using AMM
	Swap(context.Context, *MsgSwap) (*MsgSwapResponse, error)
	// CommitSwap defines a method for committing to a swap without revealing details
	// This is the first phase of the commit-reveal MEV protection scheme
	CommitSwap(context.Context, *MsgCommitSwap) (*MsgCommitSwapResponse, error)
	// RevealSwap defines a method for revealing and executing a committed swap
	// This is the second phase of the commit-reveal MEV protection scheme
	RevealSwap(context.Context, *MsgRevealSwap) (*MsgRevealSwapResponse, error)
	// BatchSwap defines a method for executing multiple swaps in a single transaction
	// AGENT-1: Enables agents to submit multiple swaps atomically with reduced gas
	BatchSwap(context.Context, *MsgBatchSwap) (*MsgBatchSwapResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) CreatePool(ctx context.Context, req *MsgCreatePool) (*MsgCreatePoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePool not implemented")
}
func (*UnimplementedMsgServer) AddLiquidity(ctx context.Context, req *MsgAddLiquidity) (*MsgAddLiquidityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLiquidity not implemented")
}
func (*UnimplementedMsgServer) RemoveLiquidity(ctx context.Context, req *MsgRemoveLiquidity) (*MsgRemoveLiquidityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveLiquidity not implemented")
}
func (*UnimplementedMsgServer) Swap(ctx context.Context, req *MsgSwap) (*MsgSwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Swap not implemented")
}
func (*UnimplementedMsgServer) CommitSwap(ctx context.Context, req *MsgCommitSwap) (*MsgCommitSwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitSwap not implemented")
}
func (*UnimplementedMsgServer) RevealSwap(ctx context.Context, req *MsgRevealSwap) (*MsgRevealSwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevealSwap not implemented")
}
func (*UnimplementedMsgServer) BatchSwap(ctx context.Context, req *MsgBatchSwap) (*MsgBatchSwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchSwap not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_CreatePool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreatePool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreatePool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paw.dex.v1.Msg/CreatePool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreatePool(ctx, req.(*MsgCreatePool))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddLiquidity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddLiquidity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddLiquidity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paw.dex.v1.Msg/AddLiquidity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddLiquidity(ctx, req.(*MsgAddLiquidity))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoveLiquidity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoveLiquidity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoveLiquidity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paw.dex.v1.Msg/RemoveLiquidity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoveLiquidity(ctx, req.(*MsgRemoveLiquidity))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Swap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSwap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Swap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paw.dex.v1.Msg/Swap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Swap(ctx, req.(*MsgSwap))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CommitSwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCommitSwap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CommitSwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paw.dex.v1.Msg/CommitSwap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CommitSwap(ctx, req.(*MsgCommitSwap))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RevealSwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRevealSwap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RevealSwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paw.dex.v1.Msg/RevealSwap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RevealSwap(ctx, req.(*MsgRevealSwap))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchSwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchSwap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchSwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paw.dex.v1.Msg/BatchSwap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchSwap(ctx, req.(*MsgBatchSwap))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "paw.dex.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePool",
			Handler:    _Msg_CreatePool_Handler,
		},
		{
			MethodName: "AddLiquidity",
			Handler:    _Msg_AddLiquidity_Handler,
		},
		{
			MethodName: "RemoveLiquidity",
			Handler:    _Msg_RemoveLiquidity_Handler,
		},
		{
			MethodName: "Swap",
			Handler:    _Msg_Swap_Handler,
		},
		{
			MethodName: "CommitSwap",
			Handler:    _Msg_CommitSwap_Handler,
		},
		{
			MethodName: "RevealSwap",
			Handler:    _Msg_RevealSwap_Handler,
		},
		{
			MethodName: "BatchSwap",
			Handler:    _Msg_BatchSwap_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "paw/dex/v1/tx.proto",
}

func (m *MsgCreatePool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreatePool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreatePool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AmountB.Size()
		i -= size
		if _, err := m.AmountB.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.AmountA.Size()
		i -= size
		if _, err := m.AmountA.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.TokenB) > 0 {
		i -= len(m.TokenB)
		copy(dAtA[i:], m.TokenB)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenB)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TokenA) > 0 {
		i -= len(m.TokenA)
		copy(dAtA[i:], m.TokenA)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenA)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreatePoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreatePoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreatePoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddLiquidity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddLiquidity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddLiquidity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AmountB.Size()
		i -= size
		if _, err := m.AmountB.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.AmountA.Size()
		i -= size
		if _, err := m.AmountA.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddLiquidityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddLiquidityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddLiquidityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Shares.Size()
		i -= size
		if _, err := m.Shares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgRemoveLiquidity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveLiquidity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveLiquidity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Shares.Size()
		i -= size
		if _, err := m.Shares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoveLiquidityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveLiquidityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveLiquidityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AmountB.Size()
		i -= size
		if _, err := m.AmountB.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.AmountA.Size()
		i -= size
		if _, err := m.AmountA.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Deadline != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Deadline))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.MinAmountOut.Size()
		i -= size
		if _, err := m.MinAmountOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.AmountIn.Size()
		i -= size
		if _, err := m.AmountIn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.TokenOut) > 0 {
		i -= len(m.TokenOut)
		copy(dAtA[i:], m.TokenOut)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenOut)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TokenIn) > 0 {
		i -= len(m.TokenIn)
		copy(dAtA[i:], m.TokenIn)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenIn)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Trader) > 0 {
		i -= len(m.Trader)
		copy(dAtA[i:], m.Trader)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Trader)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSwapResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSwapResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSwapResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AmountOut.Size()
		i -= size
		if _, err := m.AmountOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCommitSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCommitSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCommitSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SwapHash) > 0 {
		i -= len(m.SwapHash)
		copy(dAtA[i:], m.SwapHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SwapHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Trader) > 0 {
		i -= len(m.Trader)
		copy(dAtA[i:], m.Trader)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Trader)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCommitSwapResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCommitSwapResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCommitSwapResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ExpiryHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.EarliestRevealHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.EarliestRevealHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.CommitHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.CommitHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevealSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevealSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevealSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x42
	}
	if m.Deadline != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Deadline))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.MinAmountOut.Size()
		i -= size
		if _, err := m.MinAmountOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.AmountIn.Size()
		i -= size
		if _, err := m.AmountIn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.TokenOut) > 0 {
		i -= len(m.TokenOut)
		copy(dAtA[i:], m.TokenOut)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenOut)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TokenIn) > 0 {
		i -= len(m.TokenIn)
		copy(dAtA[i:], m.TokenIn)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenIn)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Trader) > 0 {
		i -= len(m.Trader)
		copy(dAtA[i:], m.Trader)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Trader)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevealSwapResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevealSwapResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevealSwapResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AmountOut.Size()
		i -= size
		if _, err := m.AmountOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SwapRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinAmountOut.Size()
		i -= size
		if _, err := m.MinAmountOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.AmountIn.Size()
		i -= size
		if _, err := m.AmountIn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.TokenOut) > 0 {
		i -= len(m.TokenOut)
		copy(dAtA[i:], m.TokenOut)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenOut)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TokenIn) > 0 {
		i -= len(m.TokenIn)
		copy(dAtA[i:], m.TokenIn)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenIn)))
		i--
		dAtA[i] = 0x12
	}
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Deadline != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Deadline))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Swaps) > 0 {
		for iNdEx := len(m.Swaps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Swaps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Trader) > 0 {
		i -= len(m.Trader)
		copy(dAtA[i:], m.Trader)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Trader)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchSwapResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSwapResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSwapResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x22
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.AmountOut.Size()
		i -= size
		if _, err := m.AmountOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgBatchSwapResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBatchSwapResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBatchSwapResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SuccessfulSwaps != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SuccessfulSwaps))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalSwaps != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TotalSwaps))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Results[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreatePool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenA)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenB)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.AmountA.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.AmountB.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreatePoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	return n
}

func (m *MsgAddLiquidity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	l = m.AmountA.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.AmountB.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgAddLiquidityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Shares.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRemoveLiquidity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	l = m.Shares.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRemoveLiquidityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AmountA.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.AmountB.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Trader)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	l = len(m.TokenIn)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenOut)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.AmountIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinAmountOut.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.Deadline != 0 {
		n += 1 + sovTx(uint64(m.Deadline))
	}
	return n
}

func (m *MsgSwapResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AmountOut.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCommitSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Trader)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SwapHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCommitSwapResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommitHeight != 0 {
		n += 1 + sovTx(uint64(m.CommitHeight))
	}
	if m.EarliestRevealHeight != 0 {
		n += 1 + sovTx(uint64(m.EarliestRevealHeight))
	}
	if m.ExpiryHeight != 0 {
		n += 1 + sovTx(uint64(m.ExpiryHeight))
	}
	return n
}

func (m *MsgRevealSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Trader)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	l = len(m.TokenIn)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenOut)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.AmountIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinAmountOut.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.Deadline != 0 {
		n += 1 + sovTx(uint64(m.Deadline))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRevealSwapResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AmountOut.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *SwapRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	l = len(m.TokenIn)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenOut)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.AmountIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinAmountOut.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgBatchSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Trader)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Swaps) > 0 {
		for _, e := range m.Swaps {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Deadline != 0 {
		n += 1 + sovTx(uint64(m.Deadline))
	}
	return n
}

func (m *BatchSwapResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	l = m.AmountOut.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.Success {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBatchSwapResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.TotalSwaps != 0 {
		n += 1 + sovTx(uint64(m.TotalSwaps))
	}
	if m.SuccessfulSwaps != 0 {
		n += 1 + sovTx(uint64(m.SuccessfulSwaps))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreatePool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreatePool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreatePool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenA = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenB", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenB = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountB", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountB.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreatePoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreatePoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreatePoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddLiquidity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddLiquidity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddLiquidity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountB", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountB.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddLiquidityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddLiquidityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddLiquidityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveLiquidity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveLiquidity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveLiquidity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveLiquidityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveLiquidityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveLiquidityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountB", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountB.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAmountOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinAmountOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			m.Deadline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deadline |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSwapResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSwapResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSwapResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCommitSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCommitSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCommitSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwapHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCommitSwapResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCommitSwapResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCommitSwapResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitHeight", wireType)
			}
			m.CommitHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarliestRevealHeight", wireType)
			}
			m.EarliestRevealHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EarliestRevealHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
			}
			m.ExpiryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevealSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevealSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevealSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAmountOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinAmountOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			m.Deadline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deadline |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevealSwapResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevealSwapResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevealSwapResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAmountOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinAmountOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swaps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Swaps = append(m.Swaps, SwapRequest{})
			if err := m.Swaps[len(m.Swaps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			m.Deadline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deadline |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSwapResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSwapResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSwapResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBatchSwapResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBatchSwapResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBatchSwapResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, BatchSwapResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSwaps", wireType)
			}
			m.TotalSwaps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSwaps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessfulSwaps", wireType)
			}
			m.SuccessfulSwaps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessfulSwaps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
