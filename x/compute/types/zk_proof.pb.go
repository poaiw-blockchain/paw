// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: paw/compute/v1/zk_proof.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ZKProof represents a zero-knowledge proof for compute result verification.
// This uses Groth16 proving system for efficient on-chain verification.
type ZKProof struct {
	// proof is the serialized Groth16 proof
	Proof []byte `protobuf:"bytes,1,opt,name=proof,proto3" json:"proof,omitempty"`
	// public_inputs are the public parameters of the circuit:
	// - requestID (uint64)
	// - resultHash (bytes32)
	// - providerAddress (bytes20)
	PublicInputs []byte `protobuf:"bytes,2,opt,name=public_inputs,json=publicInputs,proto3" json:"public_inputs,omitempty"`
	// proof_system identifies the proving system (currently "groth16")
	ProofSystem string `protobuf:"bytes,3,opt,name=proof_system,json=proofSystem,proto3" json:"proof_system,omitempty"`
	// circuit_id identifies which verification circuit was used
	CircuitId string `protobuf:"bytes,4,opt,name=circuit_id,json=circuitId,proto3" json:"circuit_id,omitempty"`
	// generated_at is when the proof was generated
	GeneratedAt time.Time `protobuf:"bytes,5,opt,name=generated_at,json=generatedAt,proto3,stdtime" json:"generated_at"`
}

func (m *ZKProof) Reset()         { *m = ZKProof{} }
func (m *ZKProof) String() string { return proto.CompactTextString(m) }
func (*ZKProof) ProtoMessage()    {}
func (*ZKProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_53c5840932f155cc, []int{0}
}
func (m *ZKProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKProof.Merge(m, src)
}
func (m *ZKProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKProof proto.InternalMessageInfo

func (m *ZKProof) GetProof() []byte {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *ZKProof) GetPublicInputs() []byte {
	if m != nil {
		return m.PublicInputs
	}
	return nil
}

func (m *ZKProof) GetProofSystem() string {
	if m != nil {
		return m.ProofSystem
	}
	return ""
}

func (m *ZKProof) GetCircuitId() string {
	if m != nil {
		return m.CircuitId
	}
	return ""
}

func (m *ZKProof) GetGeneratedAt() time.Time {
	if m != nil {
		return m.GeneratedAt
	}
	return time.Time{}
}

// VerifyingKey represents the verification key for a ZK circuit.
// This is stored in module params and used to verify all proofs.
type VerifyingKey struct {
	// vk_data is the serialized verifying key
	VkData []byte `protobuf:"bytes,1,opt,name=vk_data,json=vkData,proto3" json:"vk_data,omitempty"`
	// circuit_id identifies which circuit this key verifies
	CircuitId string `protobuf:"bytes,2,opt,name=circuit_id,json=circuitId,proto3" json:"circuit_id,omitempty"`
	// curve identifies the elliptic curve (e.g., "bn254", "bls12-381")
	Curve string `protobuf:"bytes,3,opt,name=curve,proto3" json:"curve,omitempty"`
	// proof_system identifies the proving system (e.g., "groth16")
	ProofSystem string `protobuf:"bytes,4,opt,name=proof_system,json=proofSystem,proto3" json:"proof_system,omitempty"`
	// created_at is when this key was created
	CreatedAt time.Time `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
	// public_input_count is the number of public inputs expected
	PublicInputCount uint32 `protobuf:"varint,6,opt,name=public_input_count,json=publicInputCount,proto3" json:"public_input_count,omitempty"`
}

func (m *VerifyingKey) Reset()         { *m = VerifyingKey{} }
func (m *VerifyingKey) String() string { return proto.CompactTextString(m) }
func (*VerifyingKey) ProtoMessage()    {}
func (*VerifyingKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_53c5840932f155cc, []int{1}
}
func (m *VerifyingKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyingKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyingKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyingKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyingKey.Merge(m, src)
}
func (m *VerifyingKey) XXX_Size() int {
	return m.Size()
}
func (m *VerifyingKey) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyingKey.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyingKey proto.InternalMessageInfo

func (m *VerifyingKey) GetVkData() []byte {
	if m != nil {
		return m.VkData
	}
	return nil
}

func (m *VerifyingKey) GetCircuitId() string {
	if m != nil {
		return m.CircuitId
	}
	return ""
}

func (m *VerifyingKey) GetCurve() string {
	if m != nil {
		return m.Curve
	}
	return ""
}

func (m *VerifyingKey) GetProofSystem() string {
	if m != nil {
		return m.ProofSystem
	}
	return ""
}

func (m *VerifyingKey) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *VerifyingKey) GetPublicInputCount() uint32 {
	if m != nil {
		return m.PublicInputCount
	}
	return 0
}

// CircuitParams defines the parameters for the compute verification circuit.
type CircuitParams struct {
	// circuit_id is the unique identifier for this circuit
	CircuitId string `protobuf:"bytes,1,opt,name=circuit_id,json=circuitId,proto3" json:"circuit_id,omitempty"`
	// description describes what this circuit verifies
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// verifying_key is the key used to verify proofs from this circuit
	VerifyingKey VerifyingKey `protobuf:"bytes,3,opt,name=verifying_key,json=verifyingKey,proto3" json:"verifying_key"`
	// max_proof_size is the maximum allowed size for proofs (bytes)
	MaxProofSize uint32 `protobuf:"varint,4,opt,name=max_proof_size,json=maxProofSize,proto3" json:"max_proof_size,omitempty"`
	// gas_cost is the gas cost for verifying a proof from this circuit
	GasCost uint64 `protobuf:"varint,5,opt,name=gas_cost,json=gasCost,proto3" json:"gas_cost,omitempty"`
	// enabled indicates whether this circuit is currently active
	Enabled bool `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *CircuitParams) Reset()         { *m = CircuitParams{} }
func (m *CircuitParams) String() string { return proto.CompactTextString(m) }
func (*CircuitParams) ProtoMessage()    {}
func (*CircuitParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_53c5840932f155cc, []int{2}
}
func (m *CircuitParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CircuitParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CircuitParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CircuitParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CircuitParams.Merge(m, src)
}
func (m *CircuitParams) XXX_Size() int {
	return m.Size()
}
func (m *CircuitParams) XXX_DiscardUnknown() {
	xxx_messageInfo_CircuitParams.DiscardUnknown(m)
}

var xxx_messageInfo_CircuitParams proto.InternalMessageInfo

func (m *CircuitParams) GetCircuitId() string {
	if m != nil {
		return m.CircuitId
	}
	return ""
}

func (m *CircuitParams) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CircuitParams) GetVerifyingKey() VerifyingKey {
	if m != nil {
		return m.VerifyingKey
	}
	return VerifyingKey{}
}

func (m *CircuitParams) GetMaxProofSize() uint32 {
	if m != nil {
		return m.MaxProofSize
	}
	return 0
}

func (m *CircuitParams) GetGasCost() uint64 {
	if m != nil {
		return m.GasCost
	}
	return 0
}

func (m *CircuitParams) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// ZKMetrics tracks ZK proof verification statistics.
type ZKMetrics struct {
	// total_proofs_generated is the total number of proofs generated
	TotalProofsGenerated uint64 `protobuf:"varint,1,opt,name=total_proofs_generated,json=totalProofsGenerated,proto3" json:"total_proofs_generated,omitempty"`
	// total_proofs_verified is the total number of proofs successfully verified
	TotalProofsVerified uint64 `protobuf:"varint,2,opt,name=total_proofs_verified,json=totalProofsVerified,proto3" json:"total_proofs_verified,omitempty"`
	// total_proofs_failed is the total number of proofs that failed verification
	TotalProofsFailed uint64 `protobuf:"varint,3,opt,name=total_proofs_failed,json=totalProofsFailed,proto3" json:"total_proofs_failed,omitempty"`
	// average_verification_time_ms is the average time to verify a proof
	AverageVerificationTimeMs uint64 `protobuf:"varint,4,opt,name=average_verification_time_ms,json=averageVerificationTimeMs,proto3" json:"average_verification_time_ms,omitempty"`
	// total_gas_consumed is the total gas consumed for proof verification
	TotalGasConsumed uint64 `protobuf:"varint,5,opt,name=total_gas_consumed,json=totalGasConsumed,proto3" json:"total_gas_consumed,omitempty"`
	// last_updated is when these metrics were last updated
	LastUpdated time.Time `protobuf:"bytes,6,opt,name=last_updated,json=lastUpdated,proto3,stdtime" json:"last_updated"`
}

func (m *ZKMetrics) Reset()         { *m = ZKMetrics{} }
func (m *ZKMetrics) String() string { return proto.CompactTextString(m) }
func (*ZKMetrics) ProtoMessage()    {}
func (*ZKMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_53c5840932f155cc, []int{3}
}
func (m *ZKMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKMetrics.Merge(m, src)
}
func (m *ZKMetrics) XXX_Size() int {
	return m.Size()
}
func (m *ZKMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_ZKMetrics proto.InternalMessageInfo

func (m *ZKMetrics) GetTotalProofsGenerated() uint64 {
	if m != nil {
		return m.TotalProofsGenerated
	}
	return 0
}

func (m *ZKMetrics) GetTotalProofsVerified() uint64 {
	if m != nil {
		return m.TotalProofsVerified
	}
	return 0
}

func (m *ZKMetrics) GetTotalProofsFailed() uint64 {
	if m != nil {
		return m.TotalProofsFailed
	}
	return 0
}

func (m *ZKMetrics) GetAverageVerificationTimeMs() uint64 {
	if m != nil {
		return m.AverageVerificationTimeMs
	}
	return 0
}

func (m *ZKMetrics) GetTotalGasConsumed() uint64 {
	if m != nil {
		return m.TotalGasConsumed
	}
	return 0
}

func (m *ZKMetrics) GetLastUpdated() time.Time {
	if m != nil {
		return m.LastUpdated
	}
	return time.Time{}
}

// ProofGenerationMetadata contains metadata about proof generation.
type ProofGenerationMetadata struct {
	// request_id is the ID of the compute request
	RequestId uint64 `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// provider is the address of the provider generating the proof
	Provider string `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"`
	// computation_hash is the hash of the actual computation performed
	ComputationHash []byte `protobuf:"bytes,3,opt,name=computation_hash,json=computationHash,proto3" json:"computation_hash,omitempty"`
	// witness_data is the private witness data (not stored on-chain)
	WitnessData []byte `protobuf:"bytes,4,opt,name=witness_data,json=witnessData,proto3" json:"witness_data,omitempty"`
	// proving_time_ms is how long it took to generate the proof
	ProvingTimeMs uint64 `protobuf:"varint,5,opt,name=proving_time_ms,json=provingTimeMs,proto3" json:"proving_time_ms,omitempty"`
	// proof_size is the size of the generated proof in bytes
	ProofSize uint32 `protobuf:"varint,6,opt,name=proof_size,json=proofSize,proto3" json:"proof_size,omitempty"`
}

func (m *ProofGenerationMetadata) Reset()         { *m = ProofGenerationMetadata{} }
func (m *ProofGenerationMetadata) String() string { return proto.CompactTextString(m) }
func (*ProofGenerationMetadata) ProtoMessage()    {}
func (*ProofGenerationMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_53c5840932f155cc, []int{4}
}
func (m *ProofGenerationMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProofGenerationMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProofGenerationMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProofGenerationMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProofGenerationMetadata.Merge(m, src)
}
func (m *ProofGenerationMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ProofGenerationMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ProofGenerationMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ProofGenerationMetadata proto.InternalMessageInfo

func (m *ProofGenerationMetadata) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *ProofGenerationMetadata) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *ProofGenerationMetadata) GetComputationHash() []byte {
	if m != nil {
		return m.ComputationHash
	}
	return nil
}

func (m *ProofGenerationMetadata) GetWitnessData() []byte {
	if m != nil {
		return m.WitnessData
	}
	return nil
}

func (m *ProofGenerationMetadata) GetProvingTimeMs() uint64 {
	if m != nil {
		return m.ProvingTimeMs
	}
	return 0
}

func (m *ProofGenerationMetadata) GetProofSize() uint32 {
	if m != nil {
		return m.ProofSize
	}
	return 0
}

func init() {
	proto.RegisterType((*ZKProof)(nil), "paw.compute.v1.ZKProof")
	proto.RegisterType((*VerifyingKey)(nil), "paw.compute.v1.VerifyingKey")
	proto.RegisterType((*CircuitParams)(nil), "paw.compute.v1.CircuitParams")
	proto.RegisterType((*ZKMetrics)(nil), "paw.compute.v1.ZKMetrics")
	proto.RegisterType((*ProofGenerationMetadata)(nil), "paw.compute.v1.ProofGenerationMetadata")
}

func init() { proto.RegisterFile("paw/compute/v1/zk_proof.proto", fileDescriptor_53c5840932f155cc) }

var fileDescriptor_53c5840932f155cc = []byte{
	// 772 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0x4f, 0x4f, 0xe3, 0x46,
	0x18, 0xc6, 0x63, 0x30, 0xf9, 0x33, 0x71, 0x80, 0x0e, 0x69, 0x09, 0x11, 0x84, 0x34, 0xad, 0xaa,
	0x54, 0x6a, 0x6d, 0x41, 0x7b, 0xaf, 0x48, 0xaa, 0xa6, 0x08, 0x21, 0x21, 0xd3, 0x72, 0xe0, 0x62,
	0x4d, 0xec, 0x89, 0x33, 0x4a, 0xec, 0xf1, 0x7a, 0xc6, 0x0e, 0xe1, 0x53, 0xf0, 0xb1, 0xb8, 0x2d,
	0xc7, 0xbd, 0xec, 0x1f, 0xc1, 0x69, 0xaf, 0xab, 0xfd, 0x00, 0x2b, 0xcf, 0x4c, 0x22, 0x13, 0x4e,
	0xbb, 0xb7, 0xcc, 0xf3, 0xbe, 0xaf, 0x67, 0x9e, 0x9f, 0x9e, 0x37, 0xe0, 0x20, 0x42, 0x33, 0xcb,
	0xa5, 0x41, 0x94, 0x70, 0x6c, 0xa5, 0x47, 0xd6, 0xed, 0xc4, 0x89, 0x62, 0x4a, 0x47, 0x66, 0x14,
	0x53, 0x4e, 0xe1, 0x66, 0x84, 0x66, 0xa6, 0x2a, 0x9b, 0xe9, 0x51, 0xb3, 0xee, 0x53, 0x9f, 0x8a,
	0x92, 0x95, 0xfd, 0x92, 0x5d, 0xcd, 0x43, 0x9f, 0x52, 0x7f, 0x8a, 0x2d, 0x71, 0x1a, 0x26, 0x23,
	0x8b, 0x93, 0x00, 0x33, 0x8e, 0x82, 0x48, 0x36, 0x74, 0x5e, 0x6b, 0xa0, 0x74, 0x7d, 0x76, 0x91,
	0x7d, 0x18, 0xd6, 0xc1, 0x86, 0xb8, 0xa1, 0xa1, 0xb5, 0xb5, 0xae, 0x61, 0xcb, 0x03, 0xfc, 0x09,
	0xd4, 0xa2, 0x64, 0x38, 0x25, 0xae, 0x43, 0xc2, 0x28, 0xe1, 0xac, 0xb1, 0x26, 0xaa, 0x86, 0x14,
	0x4f, 0x85, 0x06, 0x7f, 0x04, 0x86, 0xe8, 0x76, 0xd8, 0x9c, 0x71, 0x1c, 0x34, 0xd6, 0xdb, 0x5a,
	0xb7, 0x62, 0x57, 0x85, 0x76, 0x29, 0x24, 0x78, 0x00, 0x80, 0x4b, 0x62, 0x37, 0x21, 0xdc, 0x21,
	0x5e, 0x43, 0x17, 0x0d, 0x15, 0xa5, 0x9c, 0x7a, 0x70, 0x00, 0x0c, 0x1f, 0x87, 0x38, 0x46, 0x1c,
	0x7b, 0x0e, 0xe2, 0x8d, 0x8d, 0xb6, 0xd6, 0xad, 0x1e, 0x37, 0x4d, 0x69, 0xc0, 0x5c, 0x18, 0x30,
	0xff, 0x5b, 0x18, 0xe8, 0x95, 0xef, 0xdf, 0x1d, 0x16, 0xee, 0xde, 0x1f, 0x6a, 0x76, 0x75, 0x39,
	0x79, 0xc2, 0x3b, 0x9f, 0x34, 0x60, 0x5c, 0xe1, 0x98, 0x8c, 0xe6, 0x24, 0xf4, 0xcf, 0xf0, 0x1c,
	0xee, 0x82, 0x52, 0x3a, 0x71, 0x3c, 0xc4, 0x91, 0x32, 0x56, 0x4c, 0x27, 0x7f, 0x23, 0x8e, 0x56,
	0x5e, 0xb4, 0xb6, 0xfa, 0xa2, 0x3a, 0xd8, 0x70, 0x93, 0x38, 0xc5, 0xca, 0x8c, 0x3c, 0xbc, 0x70,
	0xaa, 0xbf, 0x74, 0xda, 0x07, 0xc0, 0x8d, 0xf1, 0xb7, 0x18, 0xa9, 0xa8, 0xb9, 0x13, 0x0e, 0x7f,
	0x03, 0x30, 0x8f, 0xdd, 0x71, 0x69, 0x12, 0xf2, 0x46, 0xb1, 0xad, 0x75, 0x6b, 0xf6, 0x76, 0x8e,
	0x7d, 0x3f, 0xd3, 0x3b, 0x9f, 0x35, 0x50, 0xeb, 0xcb, 0x97, 0x5f, 0xa0, 0x18, 0x05, 0x6c, 0xc5,
	0x9c, 0xb6, 0x6a, 0xae, 0x0d, 0xaa, 0x1e, 0x66, 0x6e, 0x4c, 0x22, 0x4e, 0x68, 0xa8, 0xcc, 0xe7,
	0x25, 0x38, 0x00, 0xb5, 0x74, 0x81, 0xd1, 0x99, 0xe0, 0xb9, 0xc0, 0x50, 0x3d, 0xde, 0x37, 0x9f,
	0x07, 0xcf, 0xcc, 0xb3, 0xee, 0xe9, 0x99, 0x15, 0xdb, 0x48, 0xf3, 0xfc, 0x7f, 0x06, 0x9b, 0x01,
	0xba, 0x71, 0x14, 0x35, 0x72, 0x8b, 0x05, 0xb3, 0x9a, 0x6d, 0x04, 0xe8, 0x46, 0x04, 0xef, 0x92,
	0xdc, 0x62, 0xb8, 0x07, 0xca, 0x3e, 0x62, 0x8e, 0x4b, 0x99, 0x44, 0xa6, 0xdb, 0x25, 0x1f, 0xb1,
	0x3e, 0x65, 0x1c, 0x36, 0x40, 0x09, 0x87, 0x68, 0x38, 0xc5, 0x9e, 0xf0, 0x5f, 0xb6, 0x17, 0xc7,
	0xce, 0xdb, 0x35, 0x50, 0xb9, 0x3e, 0x3b, 0xc7, 0x3c, 0x26, 0x2e, 0x83, 0x7f, 0x82, 0x1f, 0x38,
	0xe5, 0x68, 0x2a, 0xaf, 0x62, 0xce, 0x32, 0x15, 0xc2, 0xbe, 0x6e, 0xd7, 0x45, 0x55, 0x5c, 0xc9,
	0x06, 0x8b, 0x1a, 0x3c, 0x06, 0xdf, 0x3f, 0x9b, 0x12, 0x6f, 0x27, 0x58, 0x06, 0x42, 0xb7, 0x77,
	0x72, 0x43, 0x57, 0xaa, 0x04, 0x4d, 0xb0, 0xf3, 0x6c, 0x66, 0x84, 0x48, 0xf6, 0xba, 0x75, 0x31,
	0xf1, 0x5d, 0x6e, 0xe2, 0x1f, 0x51, 0x80, 0x7f, 0x81, 0x7d, 0x94, 0xe2, 0x18, 0xf9, 0x58, 0x7d,
	0xde, 0x45, 0x19, 0x63, 0x27, 0xdb, 0x46, 0x27, 0x60, 0x02, 0x88, 0x6e, 0xef, 0xa9, 0x9e, 0xab,
	0x5c, 0x4b, 0x96, 0x92, 0x73, 0x96, 0xa5, 0x41, 0x5e, 0x28, 0x19, 0x85, 0x2c, 0x09, 0xb0, 0xa7,
	0x38, 0x6d, 0x8b, 0xca, 0x20, 0x83, 0x25, 0xf5, 0x6c, 0x97, 0xa6, 0x88, 0x71, 0x27, 0x89, 0x3c,
	0x61, 0xbf, 0xf8, 0x35, 0xbb, 0x94, 0x4d, 0xfe, 0x2f, 0x07, 0x3b, 0x1f, 0x35, 0xb0, 0x2b, 0x8c,
	0x28, 0x5c, 0x84, 0x86, 0xe7, 0x98, 0x23, 0x4f, 0x6d, 0x4f, 0x8c, 0x5f, 0x25, 0x98, 0x2d, 0x03,
	0xa6, 0xdb, 0x15, 0xa5, 0x9c, 0x7a, 0xb0, 0x09, 0xca, 0x51, 0x4c, 0x53, 0xe2, 0xe1, 0x58, 0xa5,
	0x6b, 0x79, 0x86, 0xbf, 0x82, 0x6d, 0x19, 0x20, 0x49, 0x61, 0x8c, 0xd8, 0x58, 0xb0, 0x33, 0xec,
	0xad, 0x9c, 0xfe, 0x2f, 0x62, 0xe3, 0x6c, 0xdd, 0x66, 0x84, 0x87, 0x98, 0x31, 0xb9, 0xc1, 0xba,
	0x68, 0xab, 0x2a, 0x4d, 0xac, 0xf1, 0x2f, 0x60, 0x4b, 0x7c, 0x39, 0xf4, 0x97, 0x3c, 0x25, 0x98,
	0x9a, 0x92, 0x15, 0xc3, 0x03, 0x00, 0x72, 0x19, 0x94, 0x9b, 0x54, 0x89, 0x16, 0x01, 0xec, 0xf5,
	0xee, 0x1f, 0x5b, 0xda, 0xc3, 0x63, 0x4b, 0xfb, 0xf0, 0xd8, 0xd2, 0xee, 0x9e, 0x5a, 0x85, 0x87,
	0xa7, 0x56, 0xe1, 0xcd, 0x53, 0xab, 0x70, 0xdd, 0xf5, 0x09, 0x1f, 0x27, 0xc3, 0x2c, 0xf4, 0x56,
	0x84, 0x66, 0xbf, 0xbb, 0x63, 0x44, 0xc2, 0xec, 0x97, 0x75, 0xb3, 0xfc, 0x83, 0xe6, 0xf3, 0x08,
	0xb3, 0x61, 0x51, 0xa0, 0xfd, 0xe3, 0x4b, 0x00, 0x00, 0x00, 0xff, 0xff, 0x46, 0x79, 0x9e, 0xcb,
	0xbc, 0x05, 0x00, 0x00,
}

func (m *ZKProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.GeneratedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.GeneratedAt):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintZkProof(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x2a
	if len(m.CircuitId) > 0 {
		i -= len(m.CircuitId)
		copy(dAtA[i:], m.CircuitId)
		i = encodeVarintZkProof(dAtA, i, uint64(len(m.CircuitId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ProofSystem) > 0 {
		i -= len(m.ProofSystem)
		copy(dAtA[i:], m.ProofSystem)
		i = encodeVarintZkProof(dAtA, i, uint64(len(m.ProofSystem)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PublicInputs) > 0 {
		i -= len(m.PublicInputs)
		copy(dAtA[i:], m.PublicInputs)
		i = encodeVarintZkProof(dAtA, i, uint64(len(m.PublicInputs)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Proof) > 0 {
		i -= len(m.Proof)
		copy(dAtA[i:], m.Proof)
		i = encodeVarintZkProof(dAtA, i, uint64(len(m.Proof)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyingKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyingKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyingKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PublicInputCount != 0 {
		i = encodeVarintZkProof(dAtA, i, uint64(m.PublicInputCount))
		i--
		dAtA[i] = 0x30
	}
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintZkProof(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x2a
	if len(m.ProofSystem) > 0 {
		i -= len(m.ProofSystem)
		copy(dAtA[i:], m.ProofSystem)
		i = encodeVarintZkProof(dAtA, i, uint64(len(m.ProofSystem)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Curve) > 0 {
		i -= len(m.Curve)
		copy(dAtA[i:], m.Curve)
		i = encodeVarintZkProof(dAtA, i, uint64(len(m.Curve)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CircuitId) > 0 {
		i -= len(m.CircuitId)
		copy(dAtA[i:], m.CircuitId)
		i = encodeVarintZkProof(dAtA, i, uint64(len(m.CircuitId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VkData) > 0 {
		i -= len(m.VkData)
		copy(dAtA[i:], m.VkData)
		i = encodeVarintZkProof(dAtA, i, uint64(len(m.VkData)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CircuitParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CircuitParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CircuitParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.GasCost != 0 {
		i = encodeVarintZkProof(dAtA, i, uint64(m.GasCost))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxProofSize != 0 {
		i = encodeVarintZkProof(dAtA, i, uint64(m.MaxProofSize))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.VerifyingKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintZkProof(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintZkProof(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CircuitId) > 0 {
		i -= len(m.CircuitId)
		copy(dAtA[i:], m.CircuitId)
		i = encodeVarintZkProof(dAtA, i, uint64(len(m.CircuitId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZKMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastUpdated, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdated):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintZkProof(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x32
	if m.TotalGasConsumed != 0 {
		i = encodeVarintZkProof(dAtA, i, uint64(m.TotalGasConsumed))
		i--
		dAtA[i] = 0x28
	}
	if m.AverageVerificationTimeMs != 0 {
		i = encodeVarintZkProof(dAtA, i, uint64(m.AverageVerificationTimeMs))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalProofsFailed != 0 {
		i = encodeVarintZkProof(dAtA, i, uint64(m.TotalProofsFailed))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalProofsVerified != 0 {
		i = encodeVarintZkProof(dAtA, i, uint64(m.TotalProofsVerified))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalProofsGenerated != 0 {
		i = encodeVarintZkProof(dAtA, i, uint64(m.TotalProofsGenerated))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProofGenerationMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProofGenerationMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofGenerationMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProofSize != 0 {
		i = encodeVarintZkProof(dAtA, i, uint64(m.ProofSize))
		i--
		dAtA[i] = 0x30
	}
	if m.ProvingTimeMs != 0 {
		i = encodeVarintZkProof(dAtA, i, uint64(m.ProvingTimeMs))
		i--
		dAtA[i] = 0x28
	}
	if len(m.WitnessData) > 0 {
		i -= len(m.WitnessData)
		copy(dAtA[i:], m.WitnessData)
		i = encodeVarintZkProof(dAtA, i, uint64(len(m.WitnessData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ComputationHash) > 0 {
		i -= len(m.ComputationHash)
		copy(dAtA[i:], m.ComputationHash)
		i = encodeVarintZkProof(dAtA, i, uint64(len(m.ComputationHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintZkProof(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x12
	}
	if m.RequestId != 0 {
		i = encodeVarintZkProof(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintZkProof(dAtA []byte, offset int, v uint64) int {
	offset -= sovZkProof(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ZKProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Proof)
	if l > 0 {
		n += 1 + l + sovZkProof(uint64(l))
	}
	l = len(m.PublicInputs)
	if l > 0 {
		n += 1 + l + sovZkProof(uint64(l))
	}
	l = len(m.ProofSystem)
	if l > 0 {
		n += 1 + l + sovZkProof(uint64(l))
	}
	l = len(m.CircuitId)
	if l > 0 {
		n += 1 + l + sovZkProof(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.GeneratedAt)
	n += 1 + l + sovZkProof(uint64(l))
	return n
}

func (m *VerifyingKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VkData)
	if l > 0 {
		n += 1 + l + sovZkProof(uint64(l))
	}
	l = len(m.CircuitId)
	if l > 0 {
		n += 1 + l + sovZkProof(uint64(l))
	}
	l = len(m.Curve)
	if l > 0 {
		n += 1 + l + sovZkProof(uint64(l))
	}
	l = len(m.ProofSystem)
	if l > 0 {
		n += 1 + l + sovZkProof(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovZkProof(uint64(l))
	if m.PublicInputCount != 0 {
		n += 1 + sovZkProof(uint64(m.PublicInputCount))
	}
	return n
}

func (m *CircuitParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CircuitId)
	if l > 0 {
		n += 1 + l + sovZkProof(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovZkProof(uint64(l))
	}
	l = m.VerifyingKey.Size()
	n += 1 + l + sovZkProof(uint64(l))
	if m.MaxProofSize != 0 {
		n += 1 + sovZkProof(uint64(m.MaxProofSize))
	}
	if m.GasCost != 0 {
		n += 1 + sovZkProof(uint64(m.GasCost))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *ZKMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalProofsGenerated != 0 {
		n += 1 + sovZkProof(uint64(m.TotalProofsGenerated))
	}
	if m.TotalProofsVerified != 0 {
		n += 1 + sovZkProof(uint64(m.TotalProofsVerified))
	}
	if m.TotalProofsFailed != 0 {
		n += 1 + sovZkProof(uint64(m.TotalProofsFailed))
	}
	if m.AverageVerificationTimeMs != 0 {
		n += 1 + sovZkProof(uint64(m.AverageVerificationTimeMs))
	}
	if m.TotalGasConsumed != 0 {
		n += 1 + sovZkProof(uint64(m.TotalGasConsumed))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdated)
	n += 1 + l + sovZkProof(uint64(l))
	return n
}

func (m *ProofGenerationMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != 0 {
		n += 1 + sovZkProof(uint64(m.RequestId))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovZkProof(uint64(l))
	}
	l = len(m.ComputationHash)
	if l > 0 {
		n += 1 + l + sovZkProof(uint64(l))
	}
	l = len(m.WitnessData)
	if l > 0 {
		n += 1 + l + sovZkProof(uint64(l))
	}
	if m.ProvingTimeMs != 0 {
		n += 1 + sovZkProof(uint64(m.ProvingTimeMs))
	}
	if m.ProofSize != 0 {
		n += 1 + sovZkProof(uint64(m.ProofSize))
	}
	return n
}

func sovZkProof(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozZkProof(x uint64) (n int) {
	return sovZkProof(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ZKProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZkProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proof = append(m.Proof[:0], dAtA[iNdEx:postIndex]...)
			if m.Proof == nil {
				m.Proof = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicInputs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicInputs = append(m.PublicInputs[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicInputs == nil {
				m.PublicInputs = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofSystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofSystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CircuitId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.GeneratedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZkProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthZkProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyingKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZkProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyingKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyingKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VkData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VkData = append(m.VkData[:0], dAtA[iNdEx:postIndex]...)
			if m.VkData == nil {
				m.VkData = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CircuitId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curve", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Curve = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofSystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofSystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicInputCount", wireType)
			}
			m.PublicInputCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PublicInputCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZkProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthZkProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CircuitParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZkProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CircuitParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CircuitParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CircuitId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyingKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VerifyingKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProofSize", wireType)
			}
			m.MaxProofSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxProofSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasCost", wireType)
			}
			m.GasCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasCost |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipZkProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthZkProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZKMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZkProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalProofsGenerated", wireType)
			}
			m.TotalProofsGenerated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalProofsGenerated |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalProofsVerified", wireType)
			}
			m.TotalProofsVerified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalProofsVerified |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalProofsFailed", wireType)
			}
			m.TotalProofsFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalProofsFailed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageVerificationTimeMs", wireType)
			}
			m.AverageVerificationTimeMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AverageVerificationTimeMs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalGasConsumed", wireType)
			}
			m.TotalGasConsumed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalGasConsumed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastUpdated, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZkProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthZkProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProofGenerationMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZkProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProofGenerationMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProofGenerationMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputationHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComputationHash = append(m.ComputationHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ComputationHash == nil {
				m.ComputationHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZkProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZkProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WitnessData = append(m.WitnessData[:0], dAtA[iNdEx:postIndex]...)
			if m.WitnessData == nil {
				m.WitnessData = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvingTimeMs", wireType)
			}
			m.ProvingTimeMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProvingTimeMs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofSize", wireType)
			}
			m.ProofSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProofSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZkProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthZkProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipZkProof(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowZkProof
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowZkProof
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthZkProof
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupZkProof
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthZkProof
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthZkProof        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowZkProof          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupZkProof = fmt.Errorf("proto: unexpected end of group")
)
