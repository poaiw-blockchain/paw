// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: paw/oracle/v1/oracle.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the parameters for the oracle module.
type Params struct {
	// vote_period is the number of blocks during which voting takes place
	VotePeriod uint64 `protobuf:"varint,1,opt,name=vote_period,json=votePeriod,proto3" json:"vote_period,omitempty"`
	// vote_threshold is the minimum percentage of votes required (as a decimal string)
	VoteThreshold cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=vote_threshold,json=voteThreshold,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"vote_threshold"`
	// slash_fraction is the fraction slashed for missing votes
	SlashFraction cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=slash_fraction,json=slashFraction,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"slash_fraction"`
	// slash_window is the window of blocks for tracking miss votes
	SlashWindow uint64 `protobuf:"varint,4,opt,name=slash_window,json=slashWindow,proto3" json:"slash_window,omitempty"`
	// min_valid_per_window is minimum number of valid votes per window
	MinValidPerWindow uint64 `protobuf:"varint,5,opt,name=min_valid_per_window,json=minValidPerWindow,proto3" json:"min_valid_per_window,omitempty"`
	// twap_lookback_window is the number of blocks to look back for TWAP calculation
	TwapLookbackWindow uint64 `protobuf:"varint,6,opt,name=twap_lookback_window,json=twapLookbackWindow,proto3" json:"twap_lookback_window,omitempty"`
	// authorized_channels defines IBC port/channel pairs allowed to submit packets
	AuthorizedChannels []AuthorizedChannel `protobuf:"bytes,7,rep,name=authorized_channels,json=authorizedChannels,proto3" json:"authorized_channels"`
	// allowed_regions enumerates permissible geographic regions for validators
	AllowedRegions []string `protobuf:"bytes,8,rep,name=allowed_regions,json=allowedRegions,proto3" json:"allowed_regions,omitempty"`
	// min_geographic_regions enforces minimum distinct regions in active oracle set
	MinGeographicRegions uint64 `protobuf:"varint,9,opt,name=min_geographic_regions,json=minGeographicRegions,proto3" json:"min_geographic_regions,omitempty"`
	// min_voting_power_for_consensus is the minimum total voting power required
	// from validators after outlier filtering to set a price (prevents manipulation
	// by multiple low-stake validators)
	MinVotingPowerForConsensus cosmossdk_io_math.LegacyDec `protobuf:"bytes,10,opt,name=min_voting_power_for_consensus,json=minVotingPowerForConsensus,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"min_voting_power_for_consensus"`
	// max_validators_per_ip is the maximum number of validators allowed from the same IP address
	// Default: 3 (prevents single entity from running too many validators from one location)
	MaxValidatorsPerIp uint64 `protobuf:"varint,11,opt,name=max_validators_per_ip,json=maxValidatorsPerIp,proto3" json:"max_validators_per_ip,omitempty"`
	// max_validators_per_asn is the maximum number of validators allowed from the same ASN
	// Default: 5 (prevents single ISP/datacenter from dominating the validator set)
	MaxValidatorsPerAsn uint64 `protobuf:"varint,12,opt,name=max_validators_per_asn,json=maxValidatorsPerAsn,proto3" json:"max_validators_per_asn,omitempty"`
	// require_geographic_diversity enforces that GeoIP database must be available
	// When true (mainnet): validators must have valid geographic regions, GeoIP database is mandatory
	// When false (testnet): GeoIP database is optional, allows testing without geographic constraints
	RequireGeographicDiversity bool `protobuf:"varint,13,opt,name=require_geographic_diversity,json=requireGeographicDiversity,proto3" json:"require_geographic_diversity,omitempty"`
	// nonce_ttl_seconds is the time-to-live for IBC nonces in seconds
	// Default: 604800 (7 days). After this time, nonces can be pruned to prevent unbounded state growth.
	// This prevents replay attacks within the TTL window while allowing cleanup of old nonces.
	NonceTtlSeconds uint64 `protobuf:"varint,14,opt,name=nonce_ttl_seconds,json=nonceTtlSeconds,proto3" json:"nonce_ttl_seconds,omitempty"`
	// diversity_check_interval is the number of blocks between geographic diversity checks
	// Default: 100 blocks (~10 minutes). Determines how frequently BeginBlocker checks diversity.
	// Setting to 0 disables periodic checks (not recommended for mainnet).
	DiversityCheckInterval uint64 `protobuf:"varint,15,opt,name=diversity_check_interval,json=diversityCheckInterval,proto3" json:"diversity_check_interval,omitempty"`
	// diversity_warning_threshold is the minimum diversity score below which warnings are emitted
	// Range: 0.0 to 1.0. Default: 0.40 (40% diversity score).
	// Based on Herfindahl-Hirschman Index inverse. Lower scores indicate poor diversity.
	DiversityWarningThreshold cosmossdk_io_math.LegacyDec `protobuf:"bytes,16,opt,name=diversity_warning_threshold,json=diversityWarningThreshold,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"diversity_warning_threshold"`
	// enforce_runtime_diversity when true, rejects validator oracle registrations that would violate
	// geographic diversity requirements. When false, only emits warnings.
	// Default: false for testnet, true for mainnet.
	EnforceRuntimeDiversity bool `protobuf:"varint,17,opt,name=enforce_runtime_diversity,json=enforceRuntimeDiversity,proto3" json:"enforce_runtime_diversity,omitempty"`
	// emergency_admin is the address authorized to trigger emergency pause without governance vote
	// Can only pause (not resume). Only governance can resume to prevent abuse.
	// Set to empty string to disable admin pause capability.
	EmergencyAdmin string `protobuf:"bytes,18,opt,name=emergency_admin,json=emergencyAdmin,proto3" json:"emergency_admin,omitempty"`
	// geoip_cache_ttl_seconds is the time-to-live for GeoIP cache entries in seconds
	// Default: 3600 (1 hour). Cached lookups reduce file I/O on every validation.
	// Lower values ensure fresher data, higher values improve performance.
	GeoipCacheTtlSeconds uint64 `protobuf:"varint,19,opt,name=geoip_cache_ttl_seconds,json=geoipCacheTtlSeconds,proto3" json:"geoip_cache_ttl_seconds,omitempty"`
	// geoip_cache_max_entries is the maximum number of IP addresses to cache
	// Default: 1000. Uses LRU eviction when full. Should be >= number of validators.
	GeoipCacheMaxEntries uint64 `protobuf:"varint,20,opt,name=geoip_cache_max_entries,json=geoipCacheMaxEntries,proto3" json:"geoip_cache_max_entries,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_12b0d32940c9cc63, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetVotePeriod() uint64 {
	if m != nil {
		return m.VotePeriod
	}
	return 0
}

func (m *Params) GetSlashWindow() uint64 {
	if m != nil {
		return m.SlashWindow
	}
	return 0
}

func (m *Params) GetMinValidPerWindow() uint64 {
	if m != nil {
		return m.MinValidPerWindow
	}
	return 0
}

func (m *Params) GetTwapLookbackWindow() uint64 {
	if m != nil {
		return m.TwapLookbackWindow
	}
	return 0
}

func (m *Params) GetAuthorizedChannels() []AuthorizedChannel {
	if m != nil {
		return m.AuthorizedChannels
	}
	return nil
}

func (m *Params) GetAllowedRegions() []string {
	if m != nil {
		return m.AllowedRegions
	}
	return nil
}

func (m *Params) GetMinGeographicRegions() uint64 {
	if m != nil {
		return m.MinGeographicRegions
	}
	return 0
}

func (m *Params) GetMaxValidatorsPerIp() uint64 {
	if m != nil {
		return m.MaxValidatorsPerIp
	}
	return 0
}

func (m *Params) GetMaxValidatorsPerAsn() uint64 {
	if m != nil {
		return m.MaxValidatorsPerAsn
	}
	return 0
}

func (m *Params) GetRequireGeographicDiversity() bool {
	if m != nil {
		return m.RequireGeographicDiversity
	}
	return false
}

func (m *Params) GetNonceTtlSeconds() uint64 {
	if m != nil {
		return m.NonceTtlSeconds
	}
	return 0
}

func (m *Params) GetDiversityCheckInterval() uint64 {
	if m != nil {
		return m.DiversityCheckInterval
	}
	return 0
}

func (m *Params) GetEnforceRuntimeDiversity() bool {
	if m != nil {
		return m.EnforceRuntimeDiversity
	}
	return false
}

func (m *Params) GetEmergencyAdmin() string {
	if m != nil {
		return m.EmergencyAdmin
	}
	return ""
}

func (m *Params) GetGeoipCacheTtlSeconds() uint64 {
	if m != nil {
		return m.GeoipCacheTtlSeconds
	}
	return 0
}

func (m *Params) GetGeoipCacheMaxEntries() uint64 {
	if m != nil {
		return m.GeoipCacheMaxEntries
	}
	return 0
}

// AuthorizedChannel represents a permitted source port/channel combination
type AuthorizedChannel struct {
	PortId    string `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
	ChannelId string `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
}

func (m *AuthorizedChannel) Reset()         { *m = AuthorizedChannel{} }
func (m *AuthorizedChannel) String() string { return proto.CompactTextString(m) }
func (*AuthorizedChannel) ProtoMessage()    {}
func (*AuthorizedChannel) Descriptor() ([]byte, []int) {
	return fileDescriptor_12b0d32940c9cc63, []int{1}
}
func (m *AuthorizedChannel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizedChannel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizedChannel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizedChannel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizedChannel.Merge(m, src)
}
func (m *AuthorizedChannel) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizedChannel) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizedChannel.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizedChannel proto.InternalMessageInfo

func (m *AuthorizedChannel) GetPortId() string {
	if m != nil {
		return m.PortId
	}
	return ""
}

func (m *AuthorizedChannel) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

// Price represents the aggregated price for an asset
type Price struct {
	// asset is the identifier of the asset (e.g., "BTC", "ETH")
	Asset string `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset,omitempty"`
	// price is the aggregated price value
	Price cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=price,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"price"`
	// block_height is the block when this price was set
	BlockHeight int64 `protobuf:"varint,3,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// block_time is the timestamp when this price was set
	BlockTime int64 `protobuf:"varint,4,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
	// num_validators is the number of validators who voted
	NumValidators uint32 `protobuf:"varint,5,opt,name=num_validators,json=numValidators,proto3" json:"num_validators,omitempty"`
}

func (m *Price) Reset()         { *m = Price{} }
func (m *Price) String() string { return proto.CompactTextString(m) }
func (*Price) ProtoMessage()    {}
func (*Price) Descriptor() ([]byte, []int) {
	return fileDescriptor_12b0d32940c9cc63, []int{2}
}
func (m *Price) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Price) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Price.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Price) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Price.Merge(m, src)
}
func (m *Price) XXX_Size() int {
	return m.Size()
}
func (m *Price) XXX_DiscardUnknown() {
	xxx_messageInfo_Price.DiscardUnknown(m)
}

var xxx_messageInfo_Price proto.InternalMessageInfo

func (m *Price) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *Price) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *Price) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *Price) GetNumValidators() uint32 {
	if m != nil {
		return m.NumValidators
	}
	return 0
}

// ValidatorPrice represents a price submission by a validator
type ValidatorPrice struct {
	// validator_addr is the address of the validator
	ValidatorAddr string `protobuf:"bytes,1,opt,name=validator_addr,json=validatorAddr,proto3" json:"validator_addr,omitempty"`
	// asset is the asset identifier
	Asset string `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset,omitempty"`
	// price is the submitted price
	Price cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=price,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"price"`
	// block_height is when the price was submitted
	BlockHeight int64 `protobuf:"varint,4,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// voting_power is the validator's voting power at submission time
	VotingPower int64 `protobuf:"varint,5,opt,name=voting_power,json=votingPower,proto3" json:"voting_power,omitempty"`
}

func (m *ValidatorPrice) Reset()         { *m = ValidatorPrice{} }
func (m *ValidatorPrice) String() string { return proto.CompactTextString(m) }
func (*ValidatorPrice) ProtoMessage()    {}
func (*ValidatorPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_12b0d32940c9cc63, []int{3}
}
func (m *ValidatorPrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorPrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorPrice.Merge(m, src)
}
func (m *ValidatorPrice) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorPrice.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorPrice proto.InternalMessageInfo

func (m *ValidatorPrice) GetValidatorAddr() string {
	if m != nil {
		return m.ValidatorAddr
	}
	return ""
}

func (m *ValidatorPrice) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *ValidatorPrice) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ValidatorPrice) GetVotingPower() int64 {
	if m != nil {
		return m.VotingPower
	}
	return 0
}

// ValidatorOracle represents oracle information for a validator
type ValidatorOracle struct {
	// validator_addr is the address of the validator
	ValidatorAddr string `protobuf:"bytes,1,opt,name=validator_addr,json=validatorAddr,proto3" json:"validator_addr,omitempty"`
	// miss_counter tracks consecutive missed votes
	MissCounter uint64 `protobuf:"varint,2,opt,name=miss_counter,json=missCounter,proto3" json:"miss_counter,omitempty"`
	// total_submissions is the total number of price submissions
	TotalSubmissions uint64 `protobuf:"varint,3,opt,name=total_submissions,json=totalSubmissions,proto3" json:"total_submissions,omitempty"`
	// is_active indicates if the validator is actively participating
	IsActive bool `protobuf:"varint,4,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	// geographic_region tracks the validator's region (e.g., "na", "eu", "apac")
	GeographicRegion string `protobuf:"bytes,5,opt,name=geographic_region,json=geographicRegion,proto3" json:"geographic_region,omitempty"`
	// ip_address is the validator's IP address for diversity enforcement
	IpAddress string `protobuf:"bytes,6,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	// asn is the validator's Autonomous System Number for ISP diversity
	Asn uint64 `protobuf:"varint,7,opt,name=asn,proto3" json:"asn,omitempty"`
}

func (m *ValidatorOracle) Reset()         { *m = ValidatorOracle{} }
func (m *ValidatorOracle) String() string { return proto.CompactTextString(m) }
func (*ValidatorOracle) ProtoMessage()    {}
func (*ValidatorOracle) Descriptor() ([]byte, []int) {
	return fileDescriptor_12b0d32940c9cc63, []int{4}
}
func (m *ValidatorOracle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorOracle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorOracle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorOracle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorOracle.Merge(m, src)
}
func (m *ValidatorOracle) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorOracle) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorOracle.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorOracle proto.InternalMessageInfo

func (m *ValidatorOracle) GetValidatorAddr() string {
	if m != nil {
		return m.ValidatorAddr
	}
	return ""
}

func (m *ValidatorOracle) GetMissCounter() uint64 {
	if m != nil {
		return m.MissCounter
	}
	return 0
}

func (m *ValidatorOracle) GetTotalSubmissions() uint64 {
	if m != nil {
		return m.TotalSubmissions
	}
	return 0
}

func (m *ValidatorOracle) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *ValidatorOracle) GetGeographicRegion() string {
	if m != nil {
		return m.GeographicRegion
	}
	return ""
}

func (m *ValidatorOracle) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *ValidatorOracle) GetAsn() uint64 {
	if m != nil {
		return m.Asn
	}
	return 0
}

// PriceSnapshot represents a historical price snapshot for TWAP
type PriceSnapshot struct {
	// asset is the asset identifier
	Asset string `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset,omitempty"`
	// price is the price at this snapshot
	Price cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=price,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"price"`
	// block_height is when this snapshot was taken
	BlockHeight int64 `protobuf:"varint,3,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// block_time is the timestamp of this snapshot
	BlockTime int64 `protobuf:"varint,4,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
}

func (m *PriceSnapshot) Reset()         { *m = PriceSnapshot{} }
func (m *PriceSnapshot) String() string { return proto.CompactTextString(m) }
func (*PriceSnapshot) ProtoMessage()    {}
func (*PriceSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_12b0d32940c9cc63, []int{5}
}
func (m *PriceSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceSnapshot.Merge(m, src)
}
func (m *PriceSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *PriceSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_PriceSnapshot proto.InternalMessageInfo

func (m *PriceSnapshot) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *PriceSnapshot) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *PriceSnapshot) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

// GenesisState defines the oracle module's genesis state.
type GenesisState struct {
	// params defines all the parameters of the module
	Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
	// prices defines all the current prices
	Prices []Price `protobuf:"bytes,2,rep,name=prices,proto3" json:"prices"`
	// validator_prices defines all validator price submissions
	ValidatorPrices []ValidatorPrice `protobuf:"bytes,3,rep,name=validator_prices,json=validatorPrices,proto3" json:"validator_prices"`
	// validator_oracles defines all validator oracle info
	ValidatorOracles []ValidatorOracle `protobuf:"bytes,4,rep,name=validator_oracles,json=validatorOracles,proto3" json:"validator_oracles"`
	// price_snapshots defines historical price snapshots
	PriceSnapshots []PriceSnapshot `protobuf:"bytes,5,rep,name=price_snapshots,json=priceSnapshots,proto3" json:"price_snapshots"`
}

func (m *GenesisState) Reset()         { *m = GenesisState{} }
func (m *GenesisState) String() string { return proto.CompactTextString(m) }
func (*GenesisState) ProtoMessage()    {}
func (*GenesisState) Descriptor() ([]byte, []int) {
	return fileDescriptor_12b0d32940c9cc63, []int{6}
}
func (m *GenesisState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisState.Merge(m, src)
}
func (m *GenesisState) XXX_Size() int {
	return m.Size()
}
func (m *GenesisState) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisState.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

func (m *GenesisState) GetPrices() []Price {
	if m != nil {
		return m.Prices
	}
	return nil
}

func (m *GenesisState) GetValidatorPrices() []ValidatorPrice {
	if m != nil {
		return m.ValidatorPrices
	}
	return nil
}

func (m *GenesisState) GetValidatorOracles() []ValidatorOracle {
	if m != nil {
		return m.ValidatorOracles
	}
	return nil
}

func (m *GenesisState) GetPriceSnapshots() []PriceSnapshot {
	if m != nil {
		return m.PriceSnapshots
	}
	return nil
}

func init() {
	proto.RegisterType((*Params)(nil), "paw.oracle.v1.Params")
	proto.RegisterType((*AuthorizedChannel)(nil), "paw.oracle.v1.AuthorizedChannel")
	proto.RegisterType((*Price)(nil), "paw.oracle.v1.Price")
	proto.RegisterType((*ValidatorPrice)(nil), "paw.oracle.v1.ValidatorPrice")
	proto.RegisterType((*ValidatorOracle)(nil), "paw.oracle.v1.ValidatorOracle")
	proto.RegisterType((*PriceSnapshot)(nil), "paw.oracle.v1.PriceSnapshot")
	proto.RegisterType((*GenesisState)(nil), "paw.oracle.v1.GenesisState")
}

func init() { proto.RegisterFile("paw/oracle/v1/oracle.proto", fileDescriptor_12b0d32940c9cc63) }

var fileDescriptor_12b0d32940c9cc63 = []byte{
	// 1236 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0x4f, 0x6f, 0x13, 0x47,
	0x14, 0x8f, 0x63, 0x27, 0xc4, 0xe3, 0xd8, 0x8e, 0x27, 0x06, 0x96, 0x00, 0x4e, 0x40, 0xaa, 0x88,
	0xa8, 0xb0, 0x1b, 0x68, 0x25, 0xc4, 0xa5, 0x75, 0x42, 0xa1, 0x51, 0x69, 0x1b, 0x36, 0x08, 0xaa,
	0x5e, 0x56, 0x93, 0xdd, 0x61, 0x77, 0x94, 0xdd, 0x99, 0x65, 0x66, 0x6c, 0x27, 0xfd, 0x08, 0x3d,
	0xf5, 0x23, 0x20, 0xf5, 0xd2, 0x23, 0x07, 0xd4, 0xcf, 0xc0, 0x11, 0x21, 0x55, 0xaa, 0x7a, 0x40,
	0x15, 0x1c, 0xe8, 0xa1, 0x1f, 0xa1, 0x87, 0x6a, 0xde, 0x8c, 0xff, 0xc4, 0xd0, 0x1e, 0xd2, 0x1e,
	0x7a, 0xb1, 0x76, 0x7f, 0xbf, 0xf7, 0xfb, 0xed, 0x7b, 0x6f, 0x66, 0xde, 0x18, 0xad, 0xe4, 0x64,
	0xd0, 0x11, 0x92, 0x84, 0x29, 0xed, 0xf4, 0x37, 0xdc, 0x53, 0x3b, 0x97, 0x42, 0x0b, 0x5c, 0xcd,
	0xc9, 0xa0, 0xed, 0x90, 0xfe, 0xc6, 0x4a, 0x33, 0x16, 0xb1, 0x00, 0xa6, 0x63, 0x9e, 0x6c, 0xd0,
	0xca, 0x99, 0x50, 0xa8, 0x4c, 0xa8, 0xc0, 0x12, 0xf6, 0xc5, 0x51, 0x0d, 0x92, 0x31, 0x2e, 0x3a,
	0xf0, 0x6b, 0xa1, 0x8b, 0x8f, 0x11, 0x9a, 0xdf, 0x21, 0x92, 0x64, 0x0a, 0xaf, 0xa2, 0x4a, 0x5f,
	0x68, 0x1a, 0xe4, 0x54, 0x32, 0x11, 0x79, 0x85, 0xb5, 0xc2, 0x7a, 0xc9, 0x47, 0x06, 0xda, 0x01,
	0x04, 0x7f, 0x8d, 0x6a, 0x10, 0xa0, 0x13, 0x49, 0x55, 0x22, 0xd2, 0xc8, 0x9b, 0x5d, 0x2b, 0xac,
	0x97, 0x37, 0x37, 0x9e, 0xbd, 0x5c, 0x9d, 0xf9, 0xf5, 0xe5, 0xea, 0x59, 0xfb, 0x31, 0x15, 0xed,
	0xb7, 0x99, 0xe8, 0x64, 0x44, 0x27, 0xed, 0x3b, 0x34, 0x26, 0xe1, 0xe1, 0x4d, 0x1a, 0xbe, 0x78,
	0x7a, 0x05, 0xb9, 0x5c, 0x6e, 0xd2, 0xd0, 0xaf, 0x1a, 0xa3, 0x7b, 0x43, 0x1f, 0xe3, 0xac, 0x52,
	0xa2, 0x92, 0xe0, 0xa1, 0x24, 0xa1, 0x66, 0x82, 0x7b, 0xc5, 0x63, 0x3b, 0x83, 0xd1, 0x2d, 0xe7,
	0x83, 0x2f, 0xa0, 0x45, 0xeb, 0x3c, 0x60, 0x3c, 0x12, 0x03, 0xaf, 0x04, 0x55, 0x55, 0x00, 0x7b,
	0x00, 0x10, 0xee, 0xa0, 0x66, 0xc6, 0x78, 0xd0, 0x27, 0x29, 0x8b, 0x4c, 0xf1, 0xc3, 0xd0, 0x39,
	0x08, 0x6d, 0x64, 0x8c, 0xdf, 0x37, 0xd4, 0x0e, 0x95, 0x4e, 0xf0, 0x01, 0x6a, 0xea, 0x01, 0xc9,
	0x83, 0x54, 0x88, 0xfd, 0x3d, 0x12, 0xee, 0x0f, 0x05, 0xf3, 0x20, 0xc0, 0x86, 0xbb, 0xe3, 0x28,
	0xa7, 0x78, 0x80, 0x96, 0x49, 0x4f, 0x27, 0x42, 0xb2, 0x6f, 0x69, 0x14, 0x84, 0x09, 0xe1, 0x9c,
	0xa6, 0xca, 0x3b, 0xb1, 0x56, 0x5c, 0xaf, 0x5c, 0x5d, 0x6b, 0x1f, 0x59, 0xd6, 0x76, 0x77, 0x14,
	0xb9, 0x65, 0x03, 0x37, 0x4b, 0xa6, 0x0d, 0x3e, 0x26, 0xd3, 0x84, 0xc2, 0x97, 0x50, 0x9d, 0xa4,
	0xa9, 0x18, 0xd0, 0x28, 0x90, 0x34, 0x66, 0x82, 0x2b, 0x6f, 0x61, 0xad, 0xb8, 0x5e, 0xf6, 0x6b,
	0x0e, 0xf6, 0x2d, 0x8a, 0x3f, 0x44, 0xa7, 0x4c, 0x91, 0x31, 0x15, 0xb1, 0x24, 0x79, 0xc2, 0xc2,
	0x51, 0x7c, 0x19, 0xb2, 0x36, 0x2d, 0xb8, 0x3d, 0x22, 0x87, 0xaa, 0x1e, 0x6a, 0x41, 0x6b, 0x84,
	0x66, 0x3c, 0x0e, 0x72, 0x31, 0xa0, 0x32, 0x78, 0x28, 0x64, 0x10, 0x0a, 0xae, 0x28, 0x57, 0x3d,
	0xe5, 0xa1, 0xe3, 0xae, 0xd3, 0x8a, 0xe9, 0x2b, 0xf8, 0xee, 0x18, 0xdb, 0x5b, 0x42, 0x6e, 0x0d,
	0x4d, 0xf1, 0x06, 0x3a, 0x99, 0x91, 0x03, 0xbb, 0x22, 0x44, 0x0b, 0xa9, 0x60, 0x59, 0x58, 0xee,
	0x55, 0x6c, 0x87, 0x33, 0x72, 0x70, 0x7f, 0xc4, 0xed, 0x50, 0xb9, 0x9d, 0xe3, 0x6b, 0xe8, 0xd4,
	0x3b, 0x24, 0x44, 0x71, 0x6f, 0x11, 0x34, 0xcb, 0xd3, 0x9a, 0xae, 0xe2, 0xf8, 0x13, 0x74, 0x4e,
	0xd2, 0x47, 0x3d, 0x26, 0xe9, 0x64, 0x63, 0x22, 0xd6, 0xa7, 0x52, 0x31, 0x7d, 0xe8, 0x55, 0xd7,
	0x0a, 0xeb, 0x0b, 0xfe, 0x8a, 0x8b, 0x19, 0xb7, 0xe7, 0xe6, 0x30, 0x02, 0x5f, 0x46, 0x0d, 0x2e,
	0x78, 0x48, 0x03, 0xad, 0xd3, 0x40, 0xd1, 0x50, 0xf0, 0x48, 0x79, 0x35, 0xf8, 0x62, 0x1d, 0x88,
	0x7b, 0x3a, 0xdd, 0xb5, 0x30, 0xbe, 0x8e, 0xbc, 0x91, 0x75, 0x10, 0x26, 0x34, 0xdc, 0x0f, 0x18,
	0xd7, 0x54, 0xf6, 0x49, 0xea, 0xd5, 0x41, 0x72, 0x6a, 0xc4, 0x6f, 0x19, 0x7a, 0xdb, 0xb1, 0xf8,
	0x11, 0x3a, 0x3b, 0x56, 0x0e, 0x88, 0xe4, 0x66, 0x35, 0xc6, 0xa7, 0x70, 0xe9, 0xb8, 0x6b, 0x70,
	0x66, 0xe4, 0xfa, 0xc0, 0x9a, 0x8e, 0x4f, 0xe4, 0x0d, 0x74, 0x86, 0xf2, 0x87, 0x42, 0x86, 0x34,
	0x90, 0x3d, 0xae, 0x59, 0x46, 0x27, 0xfa, 0xd2, 0x80, 0xbe, 0x9c, 0x76, 0x01, 0xbe, 0xe5, 0xc7,
	0x4d, 0xe9, 0xa2, 0x3a, 0xcd, 0xa8, 0x8c, 0x29, 0x0f, 0x0f, 0x03, 0x12, 0x65, 0x8c, 0x7b, 0x18,
	0x52, 0xf4, 0x5e, 0x3c, 0xbd, 0xd2, 0x74, 0xdf, 0xef, 0x46, 0x91, 0xa4, 0x4a, 0xed, 0x6a, 0xc9,
	0x78, 0xec, 0xd7, 0x46, 0x82, 0xae, 0x89, 0xc7, 0x1f, 0xa1, 0xd3, 0x31, 0x15, 0x2c, 0x0f, 0x42,
	0x12, 0x26, 0x47, 0xbb, 0xbb, 0x6c, 0xf7, 0x2b, 0xd0, 0x5b, 0x86, 0x9d, 0x68, 0xf1, 0x94, 0xcc,
	0xec, 0x08, 0xca, 0xb5, 0x64, 0x54, 0x79, 0xcd, 0x69, 0xd9, 0x17, 0xe4, 0xe0, 0x53, 0xcb, 0xdd,
	0x38, 0xf7, 0xfb, 0xe3, 0xd5, 0xc2, 0x77, 0x6f, 0x9e, 0x5c, 0x5e, 0x36, 0xc3, 0xf7, 0x60, 0x38,
	0x7e, 0xed, 0x5c, 0xbc, 0x78, 0x17, 0x35, 0xde, 0x3a, 0x92, 0xf8, 0x34, 0x3a, 0x91, 0x0b, 0xa9,
	0x03, 0x66, 0x07, 0x65, 0xd9, 0x9f, 0x37, 0xaf, 0xdb, 0x11, 0x3e, 0x8f, 0x90, 0x3b, 0xdf, 0x86,
	0x83, 0x01, 0xe9, 0x97, 0x1d, 0xb2, 0x1d, 0xdd, 0x28, 0x99, 0x4f, 0x5d, 0xfc, 0xb9, 0x80, 0xe6,
	0x76, 0x24, 0x0b, 0x29, 0x6e, 0xa2, 0x39, 0xa2, 0x14, 0xd5, 0xce, 0xc5, 0xbe, 0xe0, 0xdb, 0x68,
	0x2e, 0x37, 0xf4, 0xf1, 0x07, 0xac, 0xd5, 0x9b, 0xf1, 0xb7, 0x97, 0x8a, 0x70, 0x3f, 0x48, 0x28,
	0x8b, 0x13, 0x0d, 0x63, 0xb5, 0xe8, 0x57, 0x00, 0xfb, 0x0c, 0x20, 0x93, 0xb0, 0x0d, 0x31, 0x8b,
	0x08, 0xf3, 0xb1, 0xe8, 0x97, 0x01, 0xb9, 0xc7, 0x32, 0x8a, 0xdf, 0x43, 0x35, 0xde, 0xcb, 0x26,
	0x0e, 0x16, 0xcc, 0xc5, 0xaa, 0x5f, 0xe5, 0xbd, 0x6c, 0x7c, 0xa0, 0x5c, 0x5d, 0x7f, 0x16, 0x50,
	0x6d, 0x04, 0xda, 0x02, 0x3f, 0x46, 0xb5, 0x91, 0x36, 0x20, 0x51, 0x24, 0x6d, 0xa5, 0xff, 0xb0,
	0x17, 0xaa, 0xa3, 0x78, 0x83, 0x8f, 0x3b, 0x34, 0xfb, 0xce, 0x0e, 0x15, 0xff, 0xe3, 0x0e, 0x95,
	0xde, 0xee, 0xd0, 0x05, 0xb4, 0x38, 0x39, 0x01, 0xa1, 0x01, 0x45, 0xbf, 0xd2, 0x1f, 0x4f, 0x2f,
	0x57, 0xfe, 0x0f, 0xb3, 0xa8, 0x3e, 0x2a, 0xff, 0x2b, 0xd8, 0x44, 0xff, 0xbe, 0xfe, 0x0b, 0x68,
	0x31, 0x63, 0x4a, 0x05, 0xa1, 0xe8, 0x99, 0x79, 0x00, 0x6d, 0x28, 0xf9, 0x15, 0x83, 0x6d, 0x59,
	0x08, 0xbf, 0x8f, 0x1a, 0x5a, 0x68, 0x92, 0x06, 0xaa, 0xb7, 0x67, 0x70, 0x98, 0xeb, 0x45, 0x88,
	0x5b, 0x02, 0x62, 0x77, 0x8c, 0xe3, 0xb3, 0xa8, 0xcc, 0x54, 0x60, 0xae, 0xc7, 0xbe, 0x5d, 0xee,
	0x05, 0x7f, 0x81, 0xa9, 0x2e, 0xbc, 0x1b, 0xa7, 0xb7, 0xae, 0x08, 0xa8, 0xb7, 0xec, 0x2f, 0xc5,
	0x53, 0xd7, 0x83, 0xd9, 0x39, 0x2c, 0x87, 0x9a, 0xa8, 0x52, 0x70, 0xfb, 0x95, 0xfd, 0x32, 0xcb,
	0x5d, 0x35, 0x78, 0x09, 0x15, 0xcd, 0xfc, 0x3d, 0x01, 0x79, 0x98, 0x47, 0xd7, 0xa5, 0x9f, 0x0a,
	0xa8, 0x0a, 0x7b, 0x63, 0x97, 0x93, 0x5c, 0x25, 0x42, 0xff, 0xef, 0x0f, 0x81, 0x4b, 0xfc, 0x8f,
	0x59, 0xb4, 0x78, 0x9b, 0x72, 0xaa, 0x98, 0xda, 0xd5, 0x44, 0x53, 0x7c, 0x1d, 0xcd, 0xe7, 0x30,
	0x23, 0x20, 0xf1, 0xca, 0xd5, 0x93, 0x53, 0x37, 0xb9, 0x1d, 0x20, 0x9b, 0x65, 0x93, 0xf9, 0x8f,
	0x6f, 0x9e, 0x5c, 0x2e, 0xf8, 0x2e, 0x1e, 0x5f, 0x45, 0xf3, 0x90, 0x9b, 0xf2, 0x66, 0xe1, 0x3f,
	0x40, 0x73, 0x5a, 0x69, 0x48, 0x77, 0xef, 0xbb, 0x48, 0xfc, 0x25, 0x5a, 0x1a, 0xef, 0x24, 0xa7,
	0x2e, 0x82, 0xfa, 0xfc, 0x94, 0xfa, 0xe8, 0x11, 0x74, 0x36, 0xf5, 0xfe, 0x11, 0x54, 0xe1, 0xbb,
	0xa8, 0x31, 0xf6, 0xb3, 0x62, 0xe5, 0x95, 0xc0, 0xb0, 0xf5, 0x77, 0x86, 0x76, 0x53, 0x3b, 0xc7,
	0x71, 0x3a, 0x16, 0x56, 0xf8, 0x73, 0x54, 0x87, 0xc4, 0x02, 0xe5, 0x96, 0xd6, 0x4c, 0x0b, 0x63,
	0x78, 0xee, 0x5d, 0xf5, 0x0d, 0xd7, 0xdf, 0xd9, 0xd5, 0xf2, 0x49, 0x50, 0x6d, 0x76, 0x9f, 0xbd,
	0x6a, 0x15, 0x9e, 0xbf, 0x6a, 0x15, 0x7e, 0x7b, 0xd5, 0x2a, 0x7c, 0xff, 0xba, 0x35, 0xf3, 0xfc,
	0x75, 0x6b, 0xe6, 0x97, 0xd7, 0xad, 0x99, 0x6f, 0x2e, 0xc5, 0x4c, 0x27, 0xbd, 0xbd, 0x76, 0x28,
	0xb2, 0x4e, 0x4e, 0x06, 0x57, 0xc2, 0x84, 0x30, 0xde, 0x39, 0x32, 0xbb, 0xf5, 0x61, 0x4e, 0xd5,
	0xde, 0x3c, 0xfc, 0xc9, 0xbd, 0xf6, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x54, 0xa2, 0x16, 0x6c,
	0x55, 0x0b, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VotePeriod != that1.VotePeriod {
		return false
	}
	if !this.VoteThreshold.Equal(that1.VoteThreshold) {
		return false
	}
	if !this.SlashFraction.Equal(that1.SlashFraction) {
		return false
	}
	if this.SlashWindow != that1.SlashWindow {
		return false
	}
	if this.MinValidPerWindow != that1.MinValidPerWindow {
		return false
	}
	if this.TwapLookbackWindow != that1.TwapLookbackWindow {
		return false
	}
	if len(this.AuthorizedChannels) != len(that1.AuthorizedChannels) {
		return false
	}
	for i := range this.AuthorizedChannels {
		if !this.AuthorizedChannels[i].Equal(&that1.AuthorizedChannels[i]) {
			return false
		}
	}
	if len(this.AllowedRegions) != len(that1.AllowedRegions) {
		return false
	}
	for i := range this.AllowedRegions {
		if this.AllowedRegions[i] != that1.AllowedRegions[i] {
			return false
		}
	}
	if this.MinGeographicRegions != that1.MinGeographicRegions {
		return false
	}
	if !this.MinVotingPowerForConsensus.Equal(that1.MinVotingPowerForConsensus) {
		return false
	}
	if this.MaxValidatorsPerIp != that1.MaxValidatorsPerIp {
		return false
	}
	if this.MaxValidatorsPerAsn != that1.MaxValidatorsPerAsn {
		return false
	}
	if this.RequireGeographicDiversity != that1.RequireGeographicDiversity {
		return false
	}
	if this.NonceTtlSeconds != that1.NonceTtlSeconds {
		return false
	}
	if this.DiversityCheckInterval != that1.DiversityCheckInterval {
		return false
	}
	if !this.DiversityWarningThreshold.Equal(that1.DiversityWarningThreshold) {
		return false
	}
	if this.EnforceRuntimeDiversity != that1.EnforceRuntimeDiversity {
		return false
	}
	if this.EmergencyAdmin != that1.EmergencyAdmin {
		return false
	}
	if this.GeoipCacheTtlSeconds != that1.GeoipCacheTtlSeconds {
		return false
	}
	if this.GeoipCacheMaxEntries != that1.GeoipCacheMaxEntries {
		return false
	}
	return true
}
func (this *AuthorizedChannel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthorizedChannel)
	if !ok {
		that2, ok := that.(AuthorizedChannel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PortId != that1.PortId {
		return false
	}
	if this.ChannelId != that1.ChannelId {
		return false
	}
	return true
}
func (this *Price) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Price)
	if !ok {
		that2, ok := that.(Price)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Asset != that1.Asset {
		return false
	}
	if !this.Price.Equal(that1.Price) {
		return false
	}
	if this.BlockHeight != that1.BlockHeight {
		return false
	}
	if this.BlockTime != that1.BlockTime {
		return false
	}
	if this.NumValidators != that1.NumValidators {
		return false
	}
	return true
}
func (this *ValidatorPrice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidatorPrice)
	if !ok {
		that2, ok := that.(ValidatorPrice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ValidatorAddr != that1.ValidatorAddr {
		return false
	}
	if this.Asset != that1.Asset {
		return false
	}
	if !this.Price.Equal(that1.Price) {
		return false
	}
	if this.BlockHeight != that1.BlockHeight {
		return false
	}
	if this.VotingPower != that1.VotingPower {
		return false
	}
	return true
}
func (this *ValidatorOracle) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidatorOracle)
	if !ok {
		that2, ok := that.(ValidatorOracle)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ValidatorAddr != that1.ValidatorAddr {
		return false
	}
	if this.MissCounter != that1.MissCounter {
		return false
	}
	if this.TotalSubmissions != that1.TotalSubmissions {
		return false
	}
	if this.IsActive != that1.IsActive {
		return false
	}
	if this.GeographicRegion != that1.GeographicRegion {
		return false
	}
	if this.IpAddress != that1.IpAddress {
		return false
	}
	if this.Asn != that1.Asn {
		return false
	}
	return true
}
func (this *PriceSnapshot) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PriceSnapshot)
	if !ok {
		that2, ok := that.(PriceSnapshot)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Asset != that1.Asset {
		return false
	}
	if !this.Price.Equal(that1.Price) {
		return false
	}
	if this.BlockHeight != that1.BlockHeight {
		return false
	}
	if this.BlockTime != that1.BlockTime {
		return false
	}
	return true
}
func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GeoipCacheMaxEntries != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.GeoipCacheMaxEntries))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.GeoipCacheTtlSeconds != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.GeoipCacheTtlSeconds))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.EmergencyAdmin) > 0 {
		i -= len(m.EmergencyAdmin)
		copy(dAtA[i:], m.EmergencyAdmin)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.EmergencyAdmin)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.EnforceRuntimeDiversity {
		i--
		if m.EnforceRuntimeDiversity {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	{
		size := m.DiversityWarningThreshold.Size()
		i -= size
		if _, err := m.DiversityWarningThreshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	if m.DiversityCheckInterval != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.DiversityCheckInterval))
		i--
		dAtA[i] = 0x78
	}
	if m.NonceTtlSeconds != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.NonceTtlSeconds))
		i--
		dAtA[i] = 0x70
	}
	if m.RequireGeographicDiversity {
		i--
		if m.RequireGeographicDiversity {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.MaxValidatorsPerAsn != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MaxValidatorsPerAsn))
		i--
		dAtA[i] = 0x60
	}
	if m.MaxValidatorsPerIp != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MaxValidatorsPerIp))
		i--
		dAtA[i] = 0x58
	}
	{
		size := m.MinVotingPowerForConsensus.Size()
		i -= size
		if _, err := m.MinVotingPowerForConsensus.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.MinGeographicRegions != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MinGeographicRegions))
		i--
		dAtA[i] = 0x48
	}
	if len(m.AllowedRegions) > 0 {
		for iNdEx := len(m.AllowedRegions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedRegions[iNdEx])
			copy(dAtA[i:], m.AllowedRegions[iNdEx])
			i = encodeVarintOracle(dAtA, i, uint64(len(m.AllowedRegions[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.AuthorizedChannels) > 0 {
		for iNdEx := len(m.AuthorizedChannels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AuthorizedChannels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.TwapLookbackWindow != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.TwapLookbackWindow))
		i--
		dAtA[i] = 0x30
	}
	if m.MinValidPerWindow != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MinValidPerWindow))
		i--
		dAtA[i] = 0x28
	}
	if m.SlashWindow != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.SlashWindow))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.SlashFraction.Size()
		i -= size
		if _, err := m.SlashFraction.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.VoteThreshold.Size()
		i -= size
		if _, err := m.VoteThreshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.VotePeriod != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.VotePeriod))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizedChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizedChannel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizedChannel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Price) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Price) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Price) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumValidators != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.NumValidators))
		i--
		dAtA[i] = 0x28
	}
	if m.BlockTime != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x20
	}
	if m.BlockHeight != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Asset) > 0 {
		i -= len(m.Asset)
		copy(dAtA[i:], m.Asset)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Asset)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorPrice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorPrice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VotingPower != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.VotingPower))
		i--
		dAtA[i] = 0x28
	}
	if m.BlockHeight != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Asset) > 0 {
		i -= len(m.Asset)
		copy(dAtA[i:], m.Asset)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Asset)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ValidatorAddr) > 0 {
		i -= len(m.ValidatorAddr)
		copy(dAtA[i:], m.ValidatorAddr)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ValidatorAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorOracle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorOracle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorOracle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Asn != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Asn))
		i--
		dAtA[i] = 0x38
	}
	if len(m.IpAddress) > 0 {
		i -= len(m.IpAddress)
		copy(dAtA[i:], m.IpAddress)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.IpAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.GeographicRegion) > 0 {
		i -= len(m.GeographicRegion)
		copy(dAtA[i:], m.GeographicRegion)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.GeographicRegion)))
		i--
		dAtA[i] = 0x2a
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.TotalSubmissions != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.TotalSubmissions))
		i--
		dAtA[i] = 0x18
	}
	if m.MissCounter != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MissCounter))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ValidatorAddr) > 0 {
		i -= len(m.ValidatorAddr)
		copy(dAtA[i:], m.ValidatorAddr)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ValidatorAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PriceSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockTime != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x20
	}
	if m.BlockHeight != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Asset) > 0 {
		i -= len(m.Asset)
		copy(dAtA[i:], m.Asset)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Asset)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PriceSnapshots) > 0 {
		for iNdEx := len(m.PriceSnapshots) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PriceSnapshots[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ValidatorOracles) > 0 {
		for iNdEx := len(m.ValidatorOracles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidatorOracles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ValidatorPrices) > 0 {
		for iNdEx := len(m.ValidatorPrices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidatorPrices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Prices) > 0 {
		for iNdEx := len(m.Prices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Prices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintOracle(dAtA []byte, offset int, v uint64) int {
	offset -= sovOracle(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VotePeriod != 0 {
		n += 1 + sovOracle(uint64(m.VotePeriod))
	}
	l = m.VoteThreshold.Size()
	n += 1 + l + sovOracle(uint64(l))
	l = m.SlashFraction.Size()
	n += 1 + l + sovOracle(uint64(l))
	if m.SlashWindow != 0 {
		n += 1 + sovOracle(uint64(m.SlashWindow))
	}
	if m.MinValidPerWindow != 0 {
		n += 1 + sovOracle(uint64(m.MinValidPerWindow))
	}
	if m.TwapLookbackWindow != 0 {
		n += 1 + sovOracle(uint64(m.TwapLookbackWindow))
	}
	if len(m.AuthorizedChannels) > 0 {
		for _, e := range m.AuthorizedChannels {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if len(m.AllowedRegions) > 0 {
		for _, s := range m.AllowedRegions {
			l = len(s)
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if m.MinGeographicRegions != 0 {
		n += 1 + sovOracle(uint64(m.MinGeographicRegions))
	}
	l = m.MinVotingPowerForConsensus.Size()
	n += 1 + l + sovOracle(uint64(l))
	if m.MaxValidatorsPerIp != 0 {
		n += 1 + sovOracle(uint64(m.MaxValidatorsPerIp))
	}
	if m.MaxValidatorsPerAsn != 0 {
		n += 1 + sovOracle(uint64(m.MaxValidatorsPerAsn))
	}
	if m.RequireGeographicDiversity {
		n += 2
	}
	if m.NonceTtlSeconds != 0 {
		n += 1 + sovOracle(uint64(m.NonceTtlSeconds))
	}
	if m.DiversityCheckInterval != 0 {
		n += 1 + sovOracle(uint64(m.DiversityCheckInterval))
	}
	l = m.DiversityWarningThreshold.Size()
	n += 2 + l + sovOracle(uint64(l))
	if m.EnforceRuntimeDiversity {
		n += 3
	}
	l = len(m.EmergencyAdmin)
	if l > 0 {
		n += 2 + l + sovOracle(uint64(l))
	}
	if m.GeoipCacheTtlSeconds != 0 {
		n += 2 + sovOracle(uint64(m.GeoipCacheTtlSeconds))
	}
	if m.GeoipCacheMaxEntries != 0 {
		n += 2 + sovOracle(uint64(m.GeoipCacheMaxEntries))
	}
	return n
}

func (m *AuthorizedChannel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *Price) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Asset)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = m.Price.Size()
	n += 1 + l + sovOracle(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovOracle(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovOracle(uint64(m.BlockTime))
	}
	if m.NumValidators != 0 {
		n += 1 + sovOracle(uint64(m.NumValidators))
	}
	return n
}

func (m *ValidatorPrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddr)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Asset)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = m.Price.Size()
	n += 1 + l + sovOracle(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovOracle(uint64(m.BlockHeight))
	}
	if m.VotingPower != 0 {
		n += 1 + sovOracle(uint64(m.VotingPower))
	}
	return n
}

func (m *ValidatorOracle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddr)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.MissCounter != 0 {
		n += 1 + sovOracle(uint64(m.MissCounter))
	}
	if m.TotalSubmissions != 0 {
		n += 1 + sovOracle(uint64(m.TotalSubmissions))
	}
	if m.IsActive {
		n += 2
	}
	l = len(m.GeographicRegion)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.Asn != 0 {
		n += 1 + sovOracle(uint64(m.Asn))
	}
	return n
}

func (m *PriceSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Asset)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = m.Price.Size()
	n += 1 + l + sovOracle(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovOracle(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovOracle(uint64(m.BlockTime))
	}
	return n
}

func (m *GenesisState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovOracle(uint64(l))
	if len(m.Prices) > 0 {
		for _, e := range m.Prices {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if len(m.ValidatorPrices) > 0 {
		for _, e := range m.ValidatorPrices {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if len(m.ValidatorOracles) > 0 {
		for _, e := range m.ValidatorOracles {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if len(m.PriceSnapshots) > 0 {
		for _, e := range m.PriceSnapshots {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	return n
}

func sovOracle(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOracle(x uint64) (n int) {
	return sovOracle(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotePeriod", wireType)
			}
			m.VotePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotePeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VoteThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashFraction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SlashFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashWindow", wireType)
			}
			m.SlashWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashWindow |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValidPerWindow", wireType)
			}
			m.MinValidPerWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinValidPerWindow |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwapLookbackWindow", wireType)
			}
			m.TwapLookbackWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TwapLookbackWindow |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizedChannels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizedChannels = append(m.AuthorizedChannels, AuthorizedChannel{})
			if err := m.AuthorizedChannels[len(m.AuthorizedChannels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedRegions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedRegions = append(m.AllowedRegions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinGeographicRegions", wireType)
			}
			m.MinGeographicRegions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinGeographicRegions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinVotingPowerForConsensus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinVotingPowerForConsensus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValidatorsPerIp", wireType)
			}
			m.MaxValidatorsPerIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxValidatorsPerIp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValidatorsPerAsn", wireType)
			}
			m.MaxValidatorsPerAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxValidatorsPerAsn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireGeographicDiversity", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireGeographicDiversity = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonceTtlSeconds", wireType)
			}
			m.NonceTtlSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NonceTtlSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiversityCheckInterval", wireType)
			}
			m.DiversityCheckInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiversityCheckInterval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiversityWarningThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DiversityWarningThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnforceRuntimeDiversity", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnforceRuntimeDiversity = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmergencyAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmergencyAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoipCacheTtlSeconds", wireType)
			}
			m.GeoipCacheTtlSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GeoipCacheTtlSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoipCacheMaxEntries", wireType)
			}
			m.GeoipCacheMaxEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GeoipCacheMaxEntries |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizedChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizedChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizedChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Price) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Price: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Price: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Asset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumValidators", wireType)
			}
			m.NumValidators = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumValidators |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorPrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorPrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorPrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Asset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPower", wireType)
			}
			m.VotingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPower |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorOracle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorOracle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorOracle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissCounter", wireType)
			}
			m.MissCounter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MissCounter |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSubmissions", wireType)
			}
			m.TotalSubmissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSubmissions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeographicRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeographicRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asn", wireType)
			}
			m.Asn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Asn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Asset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prices = append(m.Prices, Price{})
			if err := m.Prices[len(m.Prices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorPrices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorPrices = append(m.ValidatorPrices, ValidatorPrice{})
			if err := m.ValidatorPrices[len(m.ValidatorPrices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorOracles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorOracles = append(m.ValidatorOracles, ValidatorOracle{})
			if err := m.ValidatorOracles[len(m.ValidatorOracles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceSnapshots", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceSnapshots = append(m.PriceSnapshots, PriceSnapshot{})
			if err := m.PriceSnapshots[len(m.PriceSnapshots)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOracle(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOracle
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOracle
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOracle
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOracle        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOracle          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOracle = fmt.Errorf("proto: unexpected end of group")
)
