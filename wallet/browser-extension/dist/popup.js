var w="apiHost",M="walletPrivateKey";var ee=new TextEncoder().encode("walletconnect-trade");async function H(){return new Promise(e=>{chrome.storage.local.get([w],t=>{e(t[w]||"http://localhost:1317")})})}async function S(){return new Promise(e=>{chrome.storage.local.get([M],t=>{e(t[M]||null)})})}async function D(e){return new Promise(t=>{chrome.storage.local.set({[M]:e},()=>t())})}async function I(){try{if(await S()&&!confirm("You already have a wallet. Creating a new one will replace it. Make sure you have backed up your current private key! Continue?"))return;o("walletMessage","Generating new wallet...");let t=COSMOS_SDK.generatePrivateKey();if(t.length!==32)throw new Error("Invalid private key length");let a=COSMOS_SDK.bytesToHex(t),s=await COSMOS_SDK.getPublicKey(t),i=COSMOS_SDK.publicKeyToAddress(s);if(!C(i))throw new Error("Generated address validation failed");await D(a),n("#walletAddress").value=i,chrome.storage.local.set({walletAddress:i}),o("walletMessage",`New wallet created: ${i}`),setTimeout(()=>{alert(`IMPORTANT: Back up your private key!

Use the "Export Private Key" button to view and save your private key. Without it, you cannot recover your wallet if you lose access to this browser.`)},500),await y()}catch(e){o("walletMessage",`Error creating wallet: ${e.message}`,!0),console.error("Wallet generation error:",e)}}async function B(e){try{if(!e||typeof e!="string")throw new Error("Private key is required");if(e=e.trim().toLowerCase(),!/^[0-9a-f]{64}$/i.test(e))throw new Error("Invalid private key format. Must be 64 hex characters (32 bytes)");o("walletMessage","Importing wallet...");let t=COSMOS_SDK.hexToBytes(e);if(t.length!==32)throw new Error("Invalid private key length. Must be 32 bytes");let a=await COSMOS_SDK.getPublicKey(t),s=COSMOS_SDK.publicKeyToAddress(a);if(!C(s))throw new Error("Generated address validation failed");let i=await S();if(i&&i!==e&&!confirm("You already have a wallet. Importing will replace it. Make sure you have backed up your current private key! Continue?"))return;await D(e),n("#walletAddress").value=s,chrome.storage.local.set({walletAddress:s}),o("walletMessage",`Wallet imported successfully: ${s}`),await y()}catch(t){o("walletMessage",`Error importing wallet: ${t.message}`,!0),console.error("Wallet import error:",t)}}async function y(){let e=n("#walletAddress").value.trim();if(!e){n("#balanceDisplay").textContent="Balance: Enter address";return}try{let t=await COSMOS_SDK.getBalance(e);if(t.length===0){n("#balanceDisplay").textContent="Balance: 0 PAW";return}let a=t.map(s=>{let i=parseInt(s.amount)/Math.pow(10,COSMOS_SDK.config.coinDecimals),r=s.denom==="upaw"?"PAW":s.denom;return`${i} ${r}`}).join(", ");n("#balanceDisplay").textContent=`Balance: ${a}`}catch(t){n("#balanceDisplay").textContent=`Balance: Error - ${t.message}`}}async function x(e,t,a,s,i){let r=n("#walletAddress").value.trim();if(!r)return o("tradeMessage","Please enter your wallet address",!0),null;if(!C(r))return o("tradeMessage","Invalid wallet address format",!0),null;if(!e||e<=0)return o("tradeMessage","Invalid pool ID",!0),null;if(!a||a<=0)return o("tradeMessage","Invalid swap amount. Must be greater than 0",!0),null;if(!t||!s)return o("tradeMessage","Token denominations required",!0),null;let c=await S();if(!c)return o("tradeMessage","No private key found. Create or import a wallet first.",!0),null;try{o("tradeMessage","Preparing swap transaction...");let l=COSMOS_SDK.hexToBytes(c),u=await COSMOS_SDK.getPublicKey(l),f=await COSMOS_SDK.getAccount(r),m=COSMOS_SDK.buildSwapTx({sender:r,poolId:e,tokenIn:{denom:t,amount:a.toString()},tokenOutDenom:s,minAmountOut:i.toString(),memo:"DEX Swap from PAW Browser Wallet"});o("tradeMessage","Signing swap transaction...");let h=await COSMOS_SDK.signTx(m,l,f,u);o("tradeMessage","Broadcasting swap transaction...");let p=await COSMOS_SDK.broadcastTx(h);return o("tradeMessage",`Swap successful! Hash: ${p.txhash}`),await y(),await K(),await k(),p}catch(l){let u=l.message||"Unknown swap error occurred";return o("tradeMessage",`Swap failed: ${u}`,!0),console.error("Swap execution error:",l),null}}function o(e,t,a=!1){let s=n(`#${e}`);s&&(s.textContent=t,s.classList.toggle("error",a),setTimeout(()=>{s.textContent="",s.classList.remove("error")},1e4))}async function L(e){chrome.storage.local.set({[w]:e}),COSMOS_SDK.config.restEndpoint=e,COSMOS_SDK.config.rpcEndpoint=e.replace("1317","26657")}async function N(){let e=await S();if(!e){o("walletMessage","No private key found",!0);return}confirm("WARNING: Never share your private key with anyone! Anyone with access to your private key can steal your funds. Are you sure you want to view it?")&&alert(`Your private key:

${e}

Store this securely and never share it!`)}async function W(){confirm("WARNING: This will delete your private key from this browser. Make sure you have backed up your private key first! This action cannot be undone. Continue?")&&(await chrome.storage.local.remove([M,"walletAddress"]),n("#walletAddress").value="",n("#balanceDisplay").textContent="Balance: Wallet deleted",o("walletMessage","Wallet deleted successfully"))}async function j(){let e=n("#walletAddress").value.trim();if(!e){o("walletMessage","Enter a wallet address first",!0);return}try{let t=await COSMOS_SDK.getAccount(e),a=`Account Number: ${t.accountNumber}
Sequence: ${t.sequence}
Address: ${t.address}`;alert(a)}catch(t){o("walletMessage",`Error fetching account: ${t.message}`,!0)}}function C(e){return!e||typeof e!="string"?!1:e.startsWith(COSMOS_SDK.config.bech32Prefix)&&e.length>=39}async function T(){try{let e=await fetch(`${COSMOS_SDK.config.rpcEndpoint}/status`);if(e.ok){let t=await e.json();return{connected:!0,chainId:t.result?.node_info?.network,latestHeight:t.result?.sync_info?.latest_block_height}}return{connected:!1}}catch(e){return{connected:!1,error:e.message}}}function n(e){return document.querySelector(e)}async function O(){if(!n("#walletAddress").value.trim()){n("#miningStatus").textContent="Status: wallet address required";return}try{let t=`${COSMOS_SDK.config.rpcEndpoint}/validators`,a=await fetch(t);if(!a.ok){n("#miningStatus").textContent="Status: unable to reach validator API";return}let s=await a.json();n("#miningStatus").textContent="Status: Network connected",n("#miningMeta").textContent=`Validators: ${s.result?.validators?.length||0}`}catch(t){n("#miningStatus").textContent=`Status: ${t.message}`,n("#miningMeta").textContent="Network unavailable"}}async function R(){if(!n("#walletAddress").value.trim()){o("miningMessage","Enter a wallet address first",!0);return}o("miningMessage","Note: PAW uses Proof-of-Stake. Use staking instead of mining."),await O()}async function q(){o("miningMessage","Note: PAW uses Proof-of-Stake. Check staking section."),await O()}async function K(){try{let e=await COSMOS_SDK.queryPools(),t=n("#ordersList");e&&e.length>0?t.innerHTML=e.slice(0,10).map(a=>`
        <div class="entry">
          <strong>Pool ${a.id}</strong>
          <br />
          ${a.token0} / ${a.token1} | Liquidity: ${a.liquidity||"N/A"}
        </div>`).join(""):t.innerHTML='<div class="list-placeholder">No pools available</div>'}catch(e){n("#ordersList").innerHTML=`<div class="list-placeholder">Error loading pools: ${e.message}</div>`}}async function $(){await K()}async function _(){try{let e=await COSMOS_SDK.queryOraclePrices(),t=n("#matchesList");e&&e.length>0?t.innerHTML=e.slice(0,10).map(a=>`
        <div class="entry">
          ${a.symbol}: $${a.price}
          <br />
          Updated: ${new Date(a.timestamp*1e3).toLocaleTimeString()}
        </div>`).join(""):t.innerHTML='<div class="list-placeholder">No price feeds available</div>'}catch(e){n("#matchesList").innerHTML=`<div class="list-placeholder">Error loading prices: ${e.message}</div>`}}async function k(){let e=n("#walletAddress").value.trim();if(!e){n("#tradeHistory").innerHTML='<div class="list-placeholder">Enter wallet address</div>';return}try{let t=`${COSMOS_SDK.config.restEndpoint}/cosmos/tx/v1beta1/txs?events=message.sender='${e}'&order_by=ORDER_BY_DESC&limit=5`,a=await fetch(t);if(!a.ok){n("#tradeHistory").innerHTML='<div class="list-placeholder">Unable to fetch history</div>';return}let s=await a.json(),i=n("#tradeHistory");s.txs&&s.txs.length>0?i.innerHTML=s.txs.map(r=>`
        <div class="entry">
          TX @ height ${r.height||"pending"}
          <br />
          Hash: ${r.txhash?.substring(0,12)}... | Fee: ${r.auth_info?.fee?.amount?.[0]?.amount||0}
        </div>`).join(""):i.innerHTML='<div class="list-placeholder">No transactions found</div>'}catch(t){n("#tradeHistory").innerHTML=`<div class="list-placeholder">Error: ${t.message}</div>`}}async function F(){let e=n("#walletAddress").value.trim();if(!e){n("#minerStats").textContent="Enter address for staking stats";return}try{let t=`${COSMOS_SDK.config.restEndpoint}/cosmos/staking/v1beta1/delegations/${e}`,a=await fetch(t);if(!a.ok){n("#minerStats").textContent="No staking data",n("#minerHistory").textContent="Not staking";return}let i=(await a.json()).delegation_responses||[];if(i.length>0){let r=i.reduce((c,l)=>c+parseInt(l.balance?.amount||0),0)/Math.pow(10,COSMOS_SDK.config.coinDecimals);n("#minerStats").textContent=`Staked: ${r} PAW | Delegations: ${i.length}`,n("#minerHistory").textContent="Active validator delegations"}else n("#minerStats").textContent="No active delegations",n("#minerHistory").textContent="Not staking"}catch(t){n("#minerStats").textContent=`Error: ${t.message}`,n("#minerHistory").textContent="Unable to fetch staking data"}}async function U(e){e.preventDefault();let t=e.target,a=new FormData(t),s=a.get("tokenOffered"),i=parseFloat(a.get("amountOffered")),r=a.get("tokenRequested"),c=parseFloat(a.get("amountRequested"));if(!s||!r||!i||!c){o("tradeMessage","Please fill in all fields",!0);return}try{let u=Math.floor(c*.95),f=await x(1,s,Math.floor(i*Math.pow(10,COSMOS_SDK.config.coinDecimals)),r,u);f&&(o("tradeMessage",`Swap successful! Hash: ${f.txhash}`),await K(),await k())}catch(l){o("tradeMessage",`Swap failed: ${l.message}`,!0)}}function g(e,t=!1){let a=n("#aiStatus");a.textContent=e,a.classList.toggle("error",t)}function A(e){n("#aiKeyDeleted").textContent=e}function P(){let e=n("#aiApiKey");e.value="",A("Your AI API key has been deleted from this wallet.")}async function Y(){let e=n("#walletAddress").value.trim(),t=n("#aiKeyMode").value,a=n("#aiApiKey").value.trim(),s=n("#aiProvider").value.trim()||"anthropic",i=n("#aiModel").value.trim()||"claude-sonnet-4-5",r={from_coin:n("#aiFromCoin").value.trim()||"PAW",to_coin:n("#aiToCoin").value.trim()||"USDC",amount:parseFloat(n("#aiAmount").value)||0,recipient_address:n("#aiRecipient").value.trim()||e};if(!e){g("Provide your wallet address before using the assistant",!0);return}if(t==="session"&&(a=a||await G()),!a){g("Enter your AI API key for this session",!0);return}if(t==="session"&&z(a),!r.amount){g("Enter a swap amount before running the assistant",!0);return}g("Preparing AI-assisted swap...");try{let l=Math.floor(r.amount*Math.pow(10,COSMOS_SDK.config.coinDecimals)),u=Math.floor(l*.95),f=await x(1,r.from_coin.toLowerCase(),l,r.to_coin.toLowerCase(),u);if(f)g(`Swap successful! Hash: ${f.txhash}`),A("Transaction complete. API key removed from this extension."),await y(),await k();else throw new Error("Swap transaction failed")}catch(c){g(`Swap error: ${c.message}`,!0)}finally{t==="temporary"||t==="external"?P():t==="session"&&A("Transaction complete. Stored key remains until you click Clear Key.")}}async function G(){return new Promise(e=>{chrome.storage.local.get(["personalAiApiKey"],t=>{e(t.personalAiApiKey||"")})})}function z(e){chrome.storage.local.set({personalAiApiKey:e})}function J(){chrome.storage.local.remove("personalAiApiKey"),P(),A("Stored Personal AI key removed.")}function V(){let e=n("#generateWallet"),t=n("#importWallet"),a=n("#refreshBalance"),s=n("#exportPrivateKey"),i=n("#deleteWallet"),r=n("#accountInfo");e&&e.addEventListener("click",I),t&&t.addEventListener("click",()=>{let v=prompt("Enter your private key (hex):");v&&B(v)}),a&&a.addEventListener("click",y),s&&s.addEventListener("click",N),i&&i.addEventListener("click",W),r&&r.addEventListener("click",j);let c=n("#startMining"),l=n("#stopMining");c&&c.addEventListener("click",R),l&&l.addEventListener("click",q);let u=n("#refreshOrders"),f=n("#refreshMatches"),m=n("#orderForm");u&&u.addEventListener("click",$),f&&f.addEventListener("click",_),m&&m.addEventListener("submit",U);let h=n("#runAiSwap"),p=n("#clearAiKey");h&&h.addEventListener("click",Y),p&&p.addEventListener("click",J);let E=n("#apiHost");E&&E.addEventListener("change",v=>{let b=v.target.value.trim();L(b),COSMOS_SDK.config.restEndpoint=b,COSMOS_SDK.config.rpcEndpoint=b.replace("1317","26657")})}function X(){chrome.storage.local.get(["walletAddress",w],t=>{let a=n("#walletAddress"),s=n("#apiHost");t.walletAddress&&a&&(a.value=t.walletAddress),t[w]&&s&&(s.value=t[w],COSMOS_SDK.config.restEndpoint=t[w],COSMOS_SDK.config.rpcEndpoint=t[w].replace("1317","26657"))});let e=n("#walletAddress");e&&e.addEventListener("change",async t=>{chrome.storage.local.set({walletAddress:t.target.value.trim()}),await y()})}async function Q(){try{let e=await T(),t=n("#networkStatus");e.connected?t&&(t.textContent=`Connected to ${e.chainId||"PAW"} | Block: ${e.latestHeight||"N/A"}`,t.classList.remove("error")):t&&(t.textContent=`Disconnected: ${e.error||"Network unavailable"}`,t.classList.add("error"));let a=await S();if(a){let s=COSMOS_SDK.hexToBytes(a),i=await COSMOS_SDK.getPublicKey(s),r=COSMOS_SDK.publicKeyToAddress(i),c=n("#walletAddress");c&&!c.value&&(c.value=r,chrome.storage.local.set({walletAddress:r})),C(r)||console.warn("Generated address may be invalid:",r)}}catch(e){console.error("Error initializing wallet:",e),o("walletMessage",`Initialization error: ${e.message}`,!0)}}async function Z(){let e=await T(),t=n("#networkStatus");t&&(e.connected?(t.textContent=`Connected to ${e.chainId||"PAW"} | Block: ${e.latestHeight||"N/A"}`,t.classList.remove("error")):(t.textContent=`Disconnected: ${e.error||"Network unavailable"}`,t.classList.add("error")))}document.addEventListener("DOMContentLoaded",async()=>{try{V(),X();let e=n("#apiHost");if(e){let t=await H();e.value=t,COSMOS_SDK.config.restEndpoint=t,COSMOS_SDK.config.rpcEndpoint=t.replace("1317","26657")}await Q(),await d(y,"balance update"),await d($,"pools refresh"),await d(_,"prices refresh"),await d(O,"network status"),await d(F,"staking stats"),await d(k,"transaction history"),setInterval(async()=>{await d(Z,"network status"),await d(y,"balance update"),await d(K,"pools refresh"),await d(_,"prices refresh"),await d(O,"network status")},3e4),console.log("PAW Browser Wallet initialized successfully")}catch(e){console.error("Fatal initialization error:",e),o("walletMessage",`Failed to initialize wallet: ${e.message}`,!0)}});async function d(e,t){try{await e()}catch(a){console.error(`Error during ${t}:`,a)}}
